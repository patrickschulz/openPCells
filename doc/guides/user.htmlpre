<!doctype html>
<html lang="en">
    @make_header sub OpenPCells Documentation
    <body>
        @make_topbar sub opc Command-Line User Guide
        <details open>
            <summary>Introduction</summary>
            <p>
            This guide shows how to use the openPCells command-line utility effectively.
            It will show the basic usage and showcase useful command-line options for various tasks.
            </p>
        </details>
        <details open>
            <summary>Overview</summary>
            <p>
            The 'opc' command-line utility is the main (and only) entry point to the openPCells layout generation system.
            </p>
        </details>
        <details open>
            <summary>Quick Start</summary>
            <p>
            If you did not do this yet, clone the repository:
            </p>
            <pre class="shell"><code>&gt; git clone https://github.com/patrickschulz/openPCells</code></pre>
            <p>
            Go to the repository and create the main program:
            </p>
            <pre class="shell"><code>&gt; ./configure --all-load-paths-local
&gt; make</code></pre>
            <p>
            This sets up the loading of all shared files and compiles the executable.
            The option <code class="shellinline">--all-load-paths-local</code> creates an executable that can be directly used from this directory without any further installation.
            This option assumes that the shared files (cells, export and tech) are not moved after compiling.
            For a quick start, this is the best option.
            </p>
            <p>
            Now run the program:
            </p>
            <pre class="shell"><code>&gt; ./opc</code></pre>
            You should see the following message:
            <pre class="shell"><code>This is the openPCell layout generator (opc), version 0.27.7.
Copyright 2020-2026 Patrick Kurth

To generate a layout, you need to pass the technology,
the export type and a cellname or the name of a cellscript.
Example:
         opc --technology opc --export gds --cell stdcells/not_gate
         opc --technology opc --export gds --cellscript script.lua

You can find out more about the available command line options by running 'opc -h'.
(...more lines...)</code></pre>
            <p>
            This indicates that everything is working fine.
            You should be able to call <code class="shellinline">opc</code> from any path (of course by using the full name including path or modifying your shell PATH variable accordingly).
            </p>
            <p>
            Now call the program from a different location with all the needed data: technology, export and cell.
            Since technology files are usually under non-dislosure agreements, openPCells comes with a generic technology (opc) which can be used to test the setup.
            However, this is a non-physical technology, so for real work you will have to write technology files yourself, which is not too hard.
            See the guide about writing technology files for this (techfiles.pdf).
            Let's call the program to create a GDS file:
            </p>
            <pre class="shell"><code>opc --technology opc --export gds --cell basic/mosfet</code></pre>
            <p>
            or create a SKILL file (for inclusion in cadence virtuoso, notice the changed export format):
            </p>
            <pre class="shell"><code>opc --technology opc --export SKILL --cell basic/mosfet</code></pre>
            <p>
            The gds export creates a <code class="shellinline">openPCells.gds</code> file, the SKILL export a <code class="shellinline">openPCells.il</code>, which can be read with a text editor.
            This example layout generation should work, this means that the installation was successful.
            If it fails a possible reason for failure could be improperly configured paths.
            If <code class="shellinline">--all-load-paths-local</code> (or manual configuration with the same effect) was used then the files must not be moved after building.
            If instead other paths (possibly global system paths) were used, <code class="shellinline">make install</code> must be run.
            Other issues are possible, but unknown.
            If problems still exist at this stage, please file a bug report.
            </p>
            <p>
            This already concludes the quick start.
            </p>
        </details>
        <details>
            <summary>Installation</summary>
            <p>
            The OpenPCells project aims to have zero dependencies (besides a C compiler) by writing all modules from scratch and including a lua interpreter.
            Therefore the installation process is simply:
            </p>
        <pre class="shell"><code>&gt; ./configure
&gt; make
&gt; make install</code></pre>
        <p>
        This should be enough to build the project.
        </p>
        <p>
        As the openPCells has no external dependencies, it is easy to deploy on various systems.
        The project itself uses only the standard C library.
        For use on other systems than it was tested on (linux), a few defines have to be probably set.
        Other than that, porting to other systems should be straight-forward.
        </p>
        <p>
        The configure script writes out the main makefile, and the load paths are hard-coded into the 'opc' binary.
        Therefore the configure script needs to be used accordingly to the type of installation.
        The three standard steps (configure, make and make install) are used for system-wide installation.
        As not every user has installation right, the project can also be installed locally for a user.
        For this, the configure script needs more information:
        </p>
        <pre class="shell"><code>&gt; ./configure \
    --all-load-paths &lt;path&gt; \
    --bin-path &lt;path&gt; \
    --man-path &lt;path&gt;
&gt; make
&gt; make install</code></pre>
        <p>
        If no explicit installation is done, (all files are left where they are built) there is an easier way:
        </p>
        <pre class="shell"><code>&gt; ./configure --all-load-paths-local
&gt; make</code></pre>
        <p>
        With this, the $PATH environment variable needs to be set to include the folder where opc is built or the full path is given when called.
        </p>
        </details>

        <details>
            <summary>Virtuoso Interface</summary>
            <p>
            The virtuoso interface consists of two parts:
            an export module to create .il files to be loaded in virtuoso as well as a menu that helps creating a menu and callling the program with the right options.
            You can install this by loading <code class="shellinline">interface/virtuoso/init.il</code> BEFORE you open a layout view (this installs a trigger).
            This requires a few global variables to be set.
            There is skeleton file (<code class="shellinline">interface/virtuoso/cdsinit.il.sample</code>) which can be used for loading the virtuoso interface.
            Copy and adapt this file to your needs and then load the file (with properly adapted paths):
            <pre class="shell"><code>load("/path/to/opc_cdsinit/cdsinit.il") </code></pre>
            </p>
            <p>
            Now open a layout view, there should be a new menu at the end of the available menus (right) called OpenPCells.
            </p>
        </details>
        @include footer.html
    </body>
</html>

<!--

\section{Introduction}
Semiconductor technologies from the perspective of a designer of integrated circuits is a set of layers, in which shapes are created to make up the physical implementation of integrated circuits, the so-called layout.
It is a long and complex way to get to a final layout that can be sent to the foundry:
The designer has to start with an abstract schematic, check for all sorts of mistakes, processing mismatches, outer influences and so on and finally create the layout from the schematic.
The last activity for itself is quite complex and can take a lot of time.
Designers have to place individual cells such as transistors or passive components and connect them with interconnection metals.
Then the layout has to be checked against design rules and for correctness (layout versus schematic).
The foundry supports designers by offering a process design kit (PDK), which includes parameterized cells (pcells).
Sometimes the pcells have not the needed flexibility or certain types are not available (often an issue for RF designs with lots of passive components), so that designers have to built them themselves.
Beside a static solution, pcells can of course also be built by designers, however, this can get quite complicated with a lot of edge cases.
Furthermore, there are basically two ways of implementing pcells: in cadence virtuoso by using SKILL (a proprietary language based on lisp) or in python with pycells, developed by ciranova (now synopsys).
Cadence pcells are quite closed, since you can only really access them with virtuoso and they are bound to one technolgy.
Pycells are more open as they are developed in python, however, you still have to register with synopsys to access the tools and the cells are still bound to one technology.
Furthermore, both techniques are linked to open access, the cell system IC designs are developed in nowadays.
Despite the name, open access is not really open. You have to be part of the consortium to access the standard.

In general, pcells and pycells function the same way:
They are implementations of the open access abstract pcell interface, which is a good idea in theory, but has some problems in practice.
In my opinion, designers don't need pcells, that is, cells that can be parameterized even after they have been placed but \enquote{pgens} (parameterized cell generators, although I won't name it like that): programmble generators that can create certain cells.
If you need to change anything later on, you have to re-generate it.
To understand why this is beneficial you have to now something about IC layout and creating tape-outs.
In short: Pcells (as opposed to \enquote{pgens}, so pcells and pycells) save all the code, parameters and stuff that is needed to generate that.
If you loose any referenced functions (or more likely: your colleague doesn't have it) or you change anything afterwards, it changes your design.
Of course you can stream out the layout to GDS (which you have to do anyways for the foundry) but this removes the parameterized part, also removing the \enquote{advantage} of pcells.

Besides problems with persistence and sharing of designs, pcells also are inherently technology-bound.
Every PDK comes with its own set of pcells, which can be annyoing.

This project aims to solve all these problems.
We want to built technology-independent cell generators that can be easily accessed from any tool (open or closed source), but are tool-independent.
Therefor the entire project is implemented in an easy-to-learn-install-and-embed language (lua) without any dependencies at all.
A framework for writing tool interfaces is provided as well as templates for technology files.
The project comes with a set of predefined cells which are actively maintained and developed.

-->
