

<head>
    <meta charset="utf-8">
    <title>OpenPCells Documentation</title>
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="topbar">
        <div class="topbar-content">
            <a href="../index.html" class="title">OpenPCells Documentation</a>
            <h2 class="subtitle">Writing Parametric Cells</h2>
        </div>
    </div>
    <details open>
        <summary>Introduction</summary>
        <p>
        This guide shows the various functions and techniques involved in creating parametric cells.
        It first introduces the available functions for implementing cells and then shows a few useful methods for developing useful cells.
        </p>
    </details>
    <details open>
        <summary>Interface Functions</summary>
    <p>
    Parametric cells (p-cells or just pcells) in openPCells are defined by a collection of functions.
    These functions must be global, and no other global variables may be created when writing cells.
    The cell definition code is run in a sandbox, isolated from the rest of the opc run.
    </p>
    <p>
    The following functions define a parametric cells.
    Not all functions need to be defined, it is actually quite unlikely that a cell will define all of them.
    The list shows the functions in their order of when they are called (e.g. prepare() is called after process_parameters()).
    </p>
    <ol>
        <li>info</li>
        <li>requirements</li>
        <li>config</li>
        <li>parameters</li>
        <li>process_parameters</li>
        <li>prepare</li>
        <li>check</li>
        <li>anchors</li>
        <li>layout</li>
    </ol>
    <h2>The info() Function</h2>
    <p>
    The info() function documents the cell usage.
    It should return a string, which is accessed by:
    </p>
    <pre class="shell">opc --cell-info &lt;cellname&gt;</pre>
    <p>
    The info() function does not take any parameters and shall not have any side effects.
    </p>
    <h2>The requirements() Function</h2>
    <p>
    The requirements() function runs preliminary checks whether the cell is supported (mainly by the technology node).
    It does not receive any parameters, as at the time of its calling no cell parameters and no cell itself are defined.
    The return value of it should be 'true' if all checks succeed, otherwise 'false' and a message describing the failure can be returned.
    Not returning 'true' on success is an error and caught by the pcell module.
    </p>
    <p>
    The targeted use of this function is checking for required process node features.
    Consider the following example, where a minimum number of metals in the metal stack is required:
    </p>
    <pre class="opc">function requirements()
    if technology.get_number_of_metals() < 4 then
        return false, "this cell requires a metal stack with at least 4 metals"
    end
    return true -- a missing final 'return true' is an error
end</pre>
    <h2>The config() Function</h2>
    <p>
    The config() function sets certain configuration settings for a cell.
    For example, a cell could be set as 'hidden' to prevent it from being listed.
    This function is used very rarely and not well tested.
    Its use is discouraged.
    </p>
    <h2>The parameters() Function</h2>
    <p>
    The parameters function defines the cell parameters.
    The main API function for this are pcell.add_parameter and pcell.add_parameters.
    Internally they call the same function, so add_parameters (the plural version) is simply a convenience function.
    As most cells will typically use more than one parameter, add_parameters is used more often than add_parameter.
    </p>
    <p>
    Parameters are defined by their name and default value (which determines which types they accept when the cell is called).
    Hence, the signature of pcell.add_parameter has three arguments: the name of the parameter, the default value and an optional table with additional settings:
    </p>
    <pre class="opc"><code>pcell.add_parameters(name, default, opts)</code></pre>
    <p>
    pcell.add_parameters accepts any number of arguments.
    Internally, the function loops over all arguments and call pcell.add_parameter with the contents of each entry.
    Therefore, every argument to pcell.add_parameters should be a table, where its first entry is the parameter name and the second entry is its default value.
    Additional settings can be done by key-value pairs.
    Note: A common mistake is to include a final comma after the last entry, as (with many parameters) the function call resembles a lua table constructor expression.
    This is however a syntax error.
    </p>
    <p>
    An example of a parameters() function definition is given here:
    </p>
    <pre class="opc"><code>function parameters()
    pcell.add_parameters(
        { "metal", 1 },
        { "width", 200 },
        { "space", 200 }
    )
end</code></pre>
    <h2>The process_parameters() Function</h2>
    <p>
    The function process_parameters() receives the parameters table after it has been filled with user-supplied values.
    In this function then some parameters can be modified:
    The function should return a table with key-value pairs.
    Every parameter in the parameters table is updated with the value given here.
    Return a table with keys that are not parameters for this cell raises an error.
    Additionally, only parameters that were not set explicitely in the call to this cell are overwritten.
    Therefore, this function should be used to update sensible defaults of parameters in accordance to other paramters.
    The example will clarify this:
    </p>
    <pre class="opc"><code>function process_parameters(_P)
    local t = {}
    t.width = technology.get_dimension(
        string.format("Minimum M%d Width", _P.metal)
    )
    return t
end</code></pre>
    <p>
    This definition changes 'width' in accordance with the actually used metal.
    This is not possible in parameters(), where the defaults are static.
    </p>
    <h2>The prepare() Function</h2>
    The prepare() function can create a state for this instantiation of the cell that can be shared across all following functions (check and layout).
    This function is usually not needed, it can be useful when complex initial calculations/computations are required to both check and use the supplied parameters.
    Anything here is possible, prepare() receives the parameters table (after process_parameters() is called) and should return a table containing shared values (although it is possible to return non-table values).
    The table (better: value) returned by prepare() is given to the check() and layout() functions.
    An (simple and rather useless) example of the prepare() function is given below:
    <pre class="opc"><code>function prepare(_P)
    local state = {}
    state.nummetals = #_P.metals
    return state
end</code></pre>
    <h2>The check() Function</h2>
    <p>
    The check() function receives the processed parameters after (potentially) calling process_parameters() and also (potentially) the cell state from prepare().
    This function is used to perform checks on the final parameters, before the layout() function is called.
    This can be used to check for basically anything, such as incorrect spacing (creating shorts), unsupported parameter combinations etc.
    This can be implemented via simple if-else clauses, return 'false' and a helpful error message upon failure.
    As in the pcell module the return value of this function is checked, it is necessary (similar to the requirements() function) to return 'true' to signal sucess (no failed parameter checks).
    An example could be:
    <pre class="opc"><code>function check(_P, state)
    if _P.space < _P.cellpitch - 2 * _P.numbits * _P.width then
         return false, string.format(
            "'space' must be large enough to accomodate enough spacing " ..
             "for all bit lines in every cell. Need: %d, got only %d",
            _P.cellpitch - 2 * _P.numbits * _P.width,
            _P.space
         )
    end
    return true
end</code></pre>
    </p>
    <h2>The anchors() Function</h2>
    <p>
    The anchors() function does not change anything in the cell itself, it is a documentation function.
    Ideally, the information given in this function is gathered automatically, but this is currently not the case (and also a tricky problem).
    Therefore, the developer/designer of a cell should document all anchors that are intenden for public use in this function.
    This is done by calling the function pcell.add_anchor_documentation for every anchor.
    This function takes two or three arguments: the name of the anchor, a description and an optional condition (some anchors are possibly only available when a certain part of the layout is also drawn).
    An example is given below:
    </p>
    <pre class="opc"><code>function anchors()
    pcell.add_area_anchor_documentation(
        "active",
        "region of the active diffusion",
        "drawactive == true"
    )
end</code></pre>
    <h2>The layout() Function</h2>
    <p>
    The layout function contains the actual code for layout generation.
    It receives up to four parameters:
    </p>
    <ol>
        <li>The cell in which the shapes and instances are placed</li>
        <li>The parameter table</li>
        <li>The cell environment</li>
        <li>The cell state (obtained from prepare()</li>
    </ol>
    <p>
    Typically, the layout function uses at least the first two parameters, as a layout without a cell is impossible and a layout without parameters is not very useful.
    The cell environment is useful when several different pcells re-use the same settings (for instance width/spacing for metal grids across different cells).
    As cell environments are equal for all cells in one opc call (as opposed to parameters, where every cell gets their own) the use of cell environments can reduce code duplication.
    The cell state is an internal table generated by the prepare() function.
    The goal again is to reduce code duplication, which can occur when calculations with parameters are necessary for, say, parameter checks and layout generation.
    </p>
    <p>
    A layout() definition with full signature looks like this:
    </p>
    <pre class="opc"><code>function layout(cell, _P, env, state)
end</code></pre>
    </details>
    <details open>
        <summary>Cell Implementation</summary>
        <p>
        A typical cell will use the functions parameters() and layout().
        Adding documentation via info() and anchors() is nice, but might not be needed for simple cells.
        </p>
        <h2>Parameter Definition</h2>
        <p>
        The parameters() function defines the parameters of the cell.
        The two required properties are the name of the parameter and its default value.
        As the name is given as a string, technically almost any combination of characters is possible.
        However, typically later on in the layout() function the parameters are referenced as table keys with the dot syntax:
        <pre class="opc"><code>_P.some_parameter</code></pre>
        This is only possible when parameter names are also lua identifiers (they can not start with a digit, they can not contain any spaces and a few other constraints).
        To circumvent this, the square-bracket notation can be used:
        <pre class="opc"><code>_P["some parameter name with spaces"]</code></pre>
        In general, this is discouraged.
        Cells should use parameter names that are lua identifiers.
        </p>
        <p>
        Parameter defaults should make it easy to use the cell without setting too many parameters manually.
        The standard cells in openPCells (not digital standard cells but the parametric cells shipped with openPCells) are designed to be callable without setting any parameters at all.
        This depends on proper technology constraint settings and is hard to test over a large set of technologies, but that should be the goal.
        </p>
        <p>
        There are a few (loosely-defined) classes of parameters: geometric parameters (defining exact sizes, for instance a gate length), parameters that influence geometric generation, but are not related to technology dimensions (e.g. number of fingers in a MOSFET), and configuration parameters (e.g. order of nets on a metal grid).
        In general the recommendation for default parameters of these parameters is:
        <ul>
            <li>
                For geometric parameters, use the technology module to retrieve relevant dimensions, for instance minimum metal widths:
                <pre class="opc"><code>{ "metalwidth", technology.get_dimension("Minimum M1 Width") }</code></pre>
            </li>
            <li>
                For pseudo-geometric parameters, use the minimum sensible value that covers most use-cases.
                This is highly dependent on the cell, as an example consider basic/mosfet:
                Its default number of fingers ('fingers') is set to 2.
            </li>
        </ul>
        </p>
        <h2>Layout Definition</h2>
        <p>
        </p>
    </details>
    <div class="footerbar">
        <hr>
        <footer>
            OpenPCells Documentation
        </footer>
    </div>
</body>
