<!doctype html>
<html lang="en">
    @make_header sub OpenPCells Documentation
    <body>
        @make_topbar sub Writing Exports
        <details open>
            <summary>Introduction</summary>
            <p>
            This guide shows how to add new export types to openPCells.
            </p>
        </details>
        <details open>
            <summary>Overview</summary>
            <p>
            Exports in openPCells can be either written in C or in lua.
            C exports offer better performance, but have to be present at compile time.
            As the gds export is currently the most essential, it is written in C and included in openPCells.
            Other exports may be written in lua and can be defined and loaded by the user without recompiling the binaries.
            For instance, the SKILL export is written in lua.
            Exports work by defining functions that write specific shapes/objects such as rectangles or polygons.
            The functions that need to be defined follow closely the way layouts are represented in opc.
            Some functions (such as writing rectangles) are elementary and are mandatory, other ares optional (such as functions dealing with cell hierarchies).
            The calling environment of an export makes sure to reduce the layout to a representation that the export can understand (for example flattening layout hierarchies).
            In total, 16&nbsp;different functions can be defined, but only 4 are mandatory.
            This is only really true for lua exports, different rules apply to C exports.
            As this guide focuses on lua, it will disregard special treatment of C exports.
            </p>

            <p>
            In the following, all export functions (mandatory and optional) will be discussed in detail and some basic best practices regarding the writing of export types will be given.
            All viewings of export types will be focused on lua exports.
            C exports follow a similar fashion, but have more freedom in their processing of output data.
            The specific differences are shown in later.
            </p>
        </details>
        <details open>
            <summary>Interface Functions</summary>
        <p>
        Export types in openPCells are implemented by a collection of functions.
        Some functions are mandatory (for instance the function to export rectangles), others are optional.
        If optional functions are missing, the to-be-exported data is possibly altered.
        For instance, when no functions for hierarchy support are present, the generated layout is flattened before it is exported.
        </p>
        <p>
        The following functions are available for implementing export types:
        </p>
        <ol>
            <li>initialize(minx, maxx, miny, maxy)</li>
            <li>finalize()</li>
            <li>get_extension()</li>
            <li>get_techexport()</li>
            <li>set_options(opt)</li>
            <li>at_begin()</li>
            <li>at_end()</li>
            <li>at_begin_cell(cellname)</li>
            <li>at_end_cell()</li>
            <li>write_rectangle(layer, bl, tr)</li>
            <li>write_triangle(layer, pt1, pt2, pt3)</li>
            <li>write_polygon(layer, pts)</li>
            <li>write_path(layer, pts, width, extension)</li>
            <li>write_cell_reference(identifier, instname, x, y, orientation)</li>
            <li>write_cell_array(identifier, instbasename, x, y, orientation, xrep, yrep, xpitch, ypitch)</li>
            <li>write_port(name, layer, where, sizehint)</li>
        </ol>

        <h2>The initialize() function</h2>
        <p>
        This function can be used to perform required calculations at the start of the export.
        This function gets the maximum x- and y-coordinates passed as arguments in order to setup the canvas.
        It is called as first function, before <code class="opcinline">at_begin</code>.
        </p>

        <p>
        Example taken from the SVG export:
        </p>
        <pre class="opc"><code>local __width, __height
function M.initialize(minx, maxx, miny, maxy)
    local width = maxx - minx
    local height = maxy - miny
    __xoffset = -minx * __scale + __xmargin + __xoffsetmanual
    __yoffset = -miny * __scale + __ymargin + __yoffsetmanual
    __width = width * __scale + 2 * __xmargin
    __height = height * __scale + 2 * __ymargin
end</code></pre>
        <p>

        This sets up the <code class="opcinline">__width</code>, <code class="opcinline">__height</code>, <code class="opcinline">__xoffset</code> and <code class="opcinline">__yoffset</code> for the SVG canvas.
        These values are required at the beginning, so this function is called first.
        </p>

        <h2>The finalize() function</h2>
        <p>
        This function is called at the end of the export: it should assemble the string/data that is then written to the respective file.
        Often, it simply uses <code class="opcinline">table.concat</code> to produce a string from a data table.
        </p>
        <p>
        Example:
        </p>
        <pre class="opc"><code>local __content = {} -- data table
function M.finalize()
    return table.concat(__content)
end</code></pre>
        <p>
        Required return value: string
        </p>

        <h2>The get_extension() function</h2>
        <p>
        This function provides the file ending of the generated layout (e.g. returns "gds" for the gds export).
        Most of the times, this will be just a simple return of a constant string.
        A call of opc with a given filename 'foo' will then produce a file named 'foo.extension', where 'extension' is returned by this function.
        </p>
        <p>
        Example:
        </p>
        <pre class="opc"><code>function M.get_extension()
    return "gds"
end</code></pre>
        <p>
        Required return value: string
        </p>
        <h2>The get_techexport() function</h2>
        <p>
        This function can be used if the technology data uses a different name than the export.
        This way technology data can be shared between different export types.
        This is used for instance for the OASIS export, which is very similiar to the GDSII export.
        Both exports expect layer data as \luainline{\{ layer = ..., purpose = ... \}}.
        The OASIS export can then define this function to return gds, which will then select the gds data.
        </p>
        <p>
        Example:
        </p>
        <pre class="opc"><code>function M.get_techexport()
    return "gds"
end</code></pre>

        <h2>The set_options() function</h2>
        <p>
        Exports support options that can be given on an opc call with \shellinline{-X}.
        This function receives a table with all collected options.
        The options are not parsed, only separated into tokens.
        It is up to the individual export to parse and process those options.
        </p>
        <p>
        Example:
        </p>
        <pre class="opc"><code>function M.set_options(opt)
    for i = 1, #opt do
        local arg = opt[i]
        if arg == "--foo" then
            -- set option foo
        end
        if arg == "--bar" then
            -- set option bar
        end
    end
end</code></pre>

        <h2>The at_begin() function</h2>
        <p>
        This function is called once at the beginning of the export process, after \luainline{initialize}.
        It is used to write some basic definitions (for instance, a GDSII stream starts with the library name, the unit definition and similar data).
        </p>

        <p>
        Example:
        </p>
        <pre class="opc"><code>function M.at_begin()
    print("Export start")
end</code></pre>

        <h2>The at_end() function</h2>
        <p>
        This function is called once at the end of the export process.
        It is used to finish the output (for instance, a GDSII stream ends with an ENDLIB entry).
        </p>
        <p>
        Example:
        </p>
        <pre class="opc"><code>function M.at_end()
    print("Export end")
end</code></pre>

        <h2>The at_begin_cell() function</h2>
        <p>
        This function marks the beginning of a cell.
        All cell references have to be defined, which is done with the regular functions like <code class="opcinline">write_rectangle</code> and <code class="opcinline">write_polygon</code>.
                In order to group these shapes into cells, the cell start and end are represented by <code class="opcinline">at_begin_cell</code> and <code class="opcinline">at_end_cell</code>.
        The 'begin' function receives the name of the cell as argument.
        </p>
        <p>
        If <code class="opcinline">write_cell_reference</code> is not defined, layouts are flattened before they are exported.
        However, some exports (such as for GDSII streams) still require these functions for flat layouts.
        </p>
        <p>
        Example:
        </p>
        <pre class="opc"><code>function M.at_begin_cell(cellname)
    -- GDSII stream: write BGNSTR record with cellname
end</code></pre>

        <h2>The at_end_cell() function</h2>
        <p>
        This function marks the end of a cell.
        All cell references have to be defined, which is done with the regular functions like <code class="opcinline">write_rectangle</code> and <code class="opcinline">write_polygon</code>.
                In order to group these shapes into cells, the cell start and end are represented by <code class="opcinline">at_begin_cell</code> and <code class="opcinline">at_end_cell</code>.
        The 'end' function receives no arguments.
        </p>
        <pre class="opc"><code>function M.at_end_cell(cellname)
    -- GDSII stream: write ENDSTR record
end</code></pre>

        <h2>The write_rectangle() function</h2>
        <p>
        This function defines how this export writes a rectangle.
        It receives the layer data and the bottom-left (bl) and top-right (tr) point as arguments.
        All arguments are tables, whereas the bl and tr table contain two fields each, x and y.
        The layer data table contains arbitrary data, which should be suitable for this export.
        Therefore, the expected data in this table must match the definition in the technology layermap file.
        </p>

        <p>
        Modified Example from the SKILL export (the real function handles some edge cases and is more complicated):
        </p>
        <pre class="opc"><code>table.insert(__content,
        string.format('dbWriteRect(cv, list("%s" "%s") %d:%d %d:%d)',
            layer.layer, layer.purpose,
            bl.x, bl.y,
            tr.x, tr.y
        )
    ))</code></pre>
        <p>
        The actual call to dbWriteRect is not important, but note how the layer data table and the points are used.
        The SKILL export expects a field layer and purpose in the layer data table.
        In SKILL-exported layouts, <code class="opcinline">cv</code> is defined outside of that file.
        </p>

        <h2>The write_triangle() function</h2>
        <p>
        This function defines how a triangle is written.
        Similar to \luainline{write_rectangle}, it receives the layer data table and three points as arguments.
        This function is only useful, when \luainline{write_polygon} is not defined, as triangles are just a special form of a polygon.
        If \luainline{write_polygon} is not defined but \luainline{write_triangle} is, all polygons are triangulated.
        This is for instance how polygons are represented in the export for the layout editor magic.
        </p>
        <p>
        Example:
        </p>
        <pre class="opc"><code>function M.write_triangle(layer, pt1, pt2, pt3)
    -- layer data is in layer
    -- pt1, pt2 and pt3 are the corner points of the triangle
end</code></pre>

        <h2>The write_polygon() function</h2>
        <p>
        This function defines how a polygon is written.
        It is similar to \luainline{write_rectangle}, it receives the layer data table and a table of points as arguments.
        If this function is not defined, then polygons are triangulated and \luainline{write_triangle} is required, so in fact one of these two functions is mandatory.
        If none of these functions are defined, polygons are not supported (which can get you suprisingly far in integrated electronics).
        </p>
        <p>
        Simplified example from the tikz export:
        </p>
        <pre class="opc"><code>function M.write_polygon(layer, pts)
    local ptstream = {}
    for _, pt in ipairs(pts) do
        table.insert(ptstream, string.format("(%s, %s)", pt.x, pt.y))
    end
    table.insert(__content,
        string.format("\\path[draw, color = %s] %s -- cycle;",
        layer.color, table.concat(ptstream, " -- "))
    )
end</code></pre>

        <h2>The write_path() function</h2>
        <p>
        This function defines how a path is written.
        Semantics-wise, it is very similar to \luainline{write_polygon}, but it receives a path width as third argument and a path extension type as fourth argument.
        If this function is not defined, paths are converted to polygons (which of course then requires \luainline{write_polygon}).
        </p>
        <p>
        Simplified example from the SKILL export:
        </p>
        <pre class="opc"><code>function M.write_path(layer, pts, width, extension)
    local ptrstr = {}
    for _, pt in ipairs(pts) do
        table.insert(ptrstr, string.format("%s:%s", pt.x, pt.y))
    end
    local c = {}
    local extstr = ''
    if extension == "butt" then
        extstr = '"squareFlush"'
    elseif extension == "round" then
        extstr = '"roundRound"'
    elseif extension == "cap" then
        extstr = '"extendExtend"'
    end
    local fmt = 'dbCreatePath(cv list("%s" "%s") list(%s) %f %s)'
    table.insert(__content, string.format(fmt,
            layer.layer, layer.purpose,
            table.concat(ptrstr, " "),
            width, extstr
        )
    )
end</code></pre>

        <h2>The write_cell_reference() function</h2>
        <p>
        With this function, layout hierarchies are possible.
        This function writes a reference to a cell (a child in opc terminology).
        For this, two things are required:
        The definition of the cell (see at_begin_cell) and the reference to that cell (this function).
        This function receives four arguments:
        The identifier of the cell (a string), the x- and y-coordinate and a string representing the orientation of the cell.
        The orientation matrix contains entries for rotation and mirroring.
        It contains 6 entries, which transform every point as follows:
        <pre class="opc"><code>x* = M1 * x + M2 * y + M3
    y* = M4 * x + M5 * y + M6</code></pre>
        It is like a transformation matrix where
        </p>
        <p>
        If write_cell_reference function is not defined, layouts are flattened (cell hierarchies are resolved) before they are exported.
        </p>

        <p>
        Simplified example from the SKILL export (ignoring the orienation):
        </p>
        <pre class="opc"><code>function M.write_cell_reference(identifier, x, y, matrix)
    local orientation = _get_orientation_from_matrix(matrix)
    local fmt = 'dbCreateInstByMasterName(cv libname "%s" "layout" nil %s:%s "R0")'
    table.insert(__content, string.format(fmt,
        identifier,
        x, y,
    )
end</code></pre>
        <p>
        In this example, '_get_orientation_from_matrix' is an internal function of the SKILL export, libname is defined outside of the exported layout file (due to how the SKILL export is used).
        <p>

        <h2>The write_cell_array() function</h2>
        <p>
        This function is very similar to <code class="opcinline">write_cell_reference</code>, but works with \emph{arrays} of cell references.
            Therefore, the first four arguments are the same as in <code class="opcinline">write_cell_reference</code>.
        The last four arguments represent the repetition in x and y and the pitch in x and y.
        </p>
        <p>
        If this function is not defined, cell arrays are manually written out with <code class="opcinline">write_cell_reference</code>.
        </p>
        <p>
        Simplified example from the SKILL export (ignoring the orienation):
        </p>
        <pre class="opc"><code>local __content = {} -- data table
function M.write_cell_array(
    identifier,
    x, y,
    orientation,
    xrep, yrep, xpitch, ypitch
)
    local fmt = 'dbCreateParamSimpleMosaicByMasterName(
        cv libname
        "%s" -- identifier
        "layout"
        nil
        %s:%s -- origin
        "R0"
        %d %d %f %f -- repition/pitch
        nil
    )'
    table.insert(__content, string.format(
        fmt,
        identifier,
        x, y,
        xrep, yrep, xpitch, ypitch
    )
end</code></pre>

        <h2>The write_port() function</h2>
        <p>
        This function exports layout ports (sometimes called labels).
        Ports don't offer physical functionality but are required for connectivity check for layout vs. schematic (LVS).
        This function receives a port name, a layer data table and a location (a point) as arguments.
        A fourth optional argument is a hint for the size, which can make generated layouts more human-readable.
        </p>

        <p>
        Simplified example from the SKILL export:
        </p>
        <pre class="opc"><code>function M.write_port(name, layer, where, sizehint)
    sizehint = sizehint or 0.1
    local fmt = 'dbCreateLabel(cv list("%s" "%s") %s:%s "%s" %f)'
    table.insert(__content, string.format(fmt,
        layer.layer, layer.purpose,
        pt.x, pt.y,
        name, sizehint)
    )
end</code></pre>

        </details>
        @include footer.html
    </body>
</html>
