<!-- The basis of this was taken from https://www.reddit.com/r/HTML/comments/11u1w76/selfcontained_search_bar/ -->

<head>
    <meta charset="utf-8">
    <title>OpenPCells Documentation</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="topbar">
        <a href="index.html" class="title">OpenPCells Documentation</a>
        <h2 class="subtitle">Application Interface Function Reference</h2>
    </div>
    <div class="container">
        <p>
        This page contains searchable API function references.
        (The search is currently slightly broken.
        It works for simple cases, but sometimes misses functions.
        opc --api-search can also be used to search for API functions.)
        </p>
    </div>
    <div class="container">
        <input class="search-bar" type="search" placeholder="Search API functions..." aria-controls="search-results">
    </div>
    <ol id="search-results" class="search-results" aria-live="polite"></ol>
    <template class="result">
        <li class="item">
            <section class="APIref">
                <h2 class="APIref-funcname"></h2>
                <h2 class="APIref-section">Syntax</h2>
                <p class="APIref-syntax"></p>
                <h2 class="APIref-section">Description</h2>
                <p class="APIref-description"></p>
                <h2 class="APIref-section">Examples</h2>
                <p class="APIref-examples"></p>
                <!--<a class="link" href="">Detailed Documentation</a>-->
            </section>
        </li>
    </template>
</body>

<script>

const apirefs = [
    {
        "module": "alignmentgroup",
        "funcname": "create",
        "syntax": "create()",
        "description": "create an alignment group that stores alignment boxes of several different objects. Objects are added subsequently and the alignment group can be given to any object.align/abut function as a target parameter.",
        "examples": "local cell1 = ... local cell2 = ... local cell3 = ... local group = alignmentgroup.create() group:add(cell1) group:add(cell2) cell3:abut_bottom(group)",
    },
    {
        "module": "alignmentgroup",
        "funcname": "add",
        "syntax": "add(self, object)",
        "description": "add the alignment box of a given object to the group",
        "examples": "group:add(cell)",
    },
    {
        "module": "aux",
        "funcname": "assert_one_of",
        "syntax": "assert_one_of(msg, key, ...)",
        "description": "check that a key is within a list of possible candidates",
        "examples": "aux.assert_one_of(\"variable\", variable, \"foo\", \"bar\", \"baz\")",
    },
    {
        "module": "aux",
        "funcname": "clone_shallow",
        "syntax": "clone_shallow(t, predicate)",
        "description": "create a shallow copy of a table. This function does not copy elements in the table, which means that nested tables refer to the same objects. The predicate function can be used to filter out unwanted entries. Only items where the predicate returns true are inserted. Without a predicate, all items are inserted.",
        "examples": "aux.clone_shallow({ 1, 2, 3, \"foo\", \"bar\", \"baz\" }, function(k, v) return type(v) == \"number\") -- { 1, 2, 3 }",
    },
    {
        "module": "aux",
        "funcname": "make_even",
        "syntax": "make_even(num)",
        "description": "return num + 1 if the number is odd",
        "examples": "aux.make_even(7) -- 8 aux.make_even(32) -- 32",
    },
    {
        "module": "aux",
        "funcname": "split_path",
        "syntax": "split_path(path)",
        "description": "split a path into its prefix/suffix (like dirname/basename). If no path separator '/' is present, the function returns \".\" and the full given path",
        "examples": "aux.split_path(\"foo/bar/baz\") -- \"foo/bar\" \"baz\" aux.split_path(\"baz\") -- \".\" \"baz\"",
    },
    {
        "module": "aux",
        "funcname": "pop_top_directory",
        "syntax": "pop_top_directory(path)",
        "description": "remove the last part of a path, separated by '/' (like basename)",
        "examples": "aux.pop_top_directory(\"foo/bar/baz\") -- \"foo/bar\"",
    },
    {
        "module": "aux",
        "funcname": "shuffle",
        "syntax": "shuffle(t)",
        "description": "shuffle the array elements of a table",
        "examples": "aux.shuffle({ 1, 2, 3 }) -- { 3, 1, 2 }",
    },
    {
        "module": "aux",
        "funcname": "strsplit",
        "syntax": "strsplit(str, pattern, plain)",
        "description": "split a string at a given separator pattern. If 'plain' is true, then the separator pattern is taken literally, no lua pattern matching is performed.",
        "examples": "aux.strsplit(\"foo:bar:baz\", \":\") -- { \"foo\", \"bar\", \"baz\" }",
    },
    {
        "module": "aux",
        "funcname": "strgsplit",
        "syntax": "strgsplit(str, pattern, plain)",
        "description": "split a string at a given separator pattern. If 'plain' is true, then the separator pattern is taken literally, no lua pattern matching is performed. This is the iterator version of aux.strsplit.",
        "examples": "for match in aux.strgsplit(\"foo:bar:baz\", \":\") do     -- do something with 'match' end",
    },
    {
        "module": "aux",
        "funcname": "sum",
        "syntax": "sum(t)",
        "description": "calculate the sum of all array entries of the table t. This function assumes that the operator '+' is defined for all the array items.",
        "examples": "aux.sum({ 1, 2, 3 }) -- 6",
    },
    {
        "module": "aux",
        "funcname": "gcd",
        "syntax": "gcd(...)",
        "description": "calculate the greatest common divisor (GDC) of all given input arguments",
        "examples": "aux.gcd(12, 9) -- 3",
    },
    {
        "module": "aux",
        "funcname": "tabgcd",
        "syntax": "tabgcd(t)",
        "description": "calculate the greatest common divisor (GDC) of all elements of the given array",
        "examples": "aux.gcd({ 12, 9 }) -- 3",
    },
    {
        "module": "aux",
        "funcname": "tprint",
        "syntax": "tprint(t)",
        "description": "recursively pretty-print the contents of the given table. This function has a simple implementation and will fail on odd tables, like cycles.",
        "examples": "aux.tprint({ 12, 9, \"foo\", sub = { name = \"name\" }, })",
    },
    {
        "module": "curve",
        "funcname": "arcto",
        "syntax": "arcto(startangle, endangle, radius, clockwise)",
        "description": "create an arc segment for a curve",
        "examples": "geometry.curve(cell, generics.metal(1), point.create(0, 0), { 	curve.arcto(180, 0, 1000, true), }, grid, allow45) ",
    },
    {
        "module": "curve",
        "funcname": "cubicto",
        "syntax": "cubicto(ctp1, ctp2, endpt)",
        "description": "create a cubic bezier segment for a curve",
        "examples": "geometry.curve(cell, generics.metal(1), point.create(0, 0), { 	curve.cubicto(point.create(0, 500), point.create(500, 500), point.create(500, 0)), }, grid, allow45) ",
    },
    {
        "module": "curve",
        "funcname": "lineto",
        "syntax": "lineto(point)",
        "description": "create a line segment for a curve",
        "examples": "geometry.curve(cell, generics.metal(1), point.create(0, 0), { 	curve.lineto(point.create(1000, 1000)), }, grid, allow45) ",
    },
    {
        "module": "generics",
        "funcname": "metal",
        "syntax": "metal(index)",
        "description": "create a generic layer representing a metal. Metals are identified by numeric indices, where 1 denotes the first metal, 2 the second one etc. Metals can also be identified by negative indicies, where -1 denotes the top-most metal, -2 the metal below that etc.",
        "examples": "generics.metal(1) generics.metal(-2)",
    },
    {
        "module": "generics",
        "funcname": "mptmetal",
        "syntax": "mptmetal(index, maskindex)",
        "description": "create a generic layer representing a metal with multiple-patterning (mpt) information. Metals are identified by numeric indices, where 1 denotes the first metal, 2 the second one etc. Metals can also be identified by negative indicies, where -1 denotes the top-most metal, -2 the metal below that etc. The mask information is a numeric indix starting at 1. The number of available masks for the respective metal can be queried by technology.multiple_patterning_number(metalnumber). Whether a metal is a mpt metal can be queried by technology.has_multiple_patterning(metalnumber)",
        "examples": "generics.mptmetal(1, 1) generics.mptmetal(1, 2)",
    },
    {
        "module": "generics",
        "funcname": "metalport",
        "syntax": "metalport(index)",
        "description": "create a generic layer representing a metal port. Metals are identified by numeric indices, where 1 denotes the first metal, 2 the second one etc. Metals can also be identified by negative indicies, where -1 denotes the top-most metal, -2 the metal below that etc.",
        "examples": "generics.metalport(1) generics.metalport(-2)",
    },
    {
        "module": "generics",
        "funcname": "metalfill",
        "syntax": "metalfill(index)",
        "description": "create a generic layer representing a metal fill. Some technologies have special layer for metal fillings, but technology files can also map these to the same layers as generics.metal(). Metals are identified by numeric indices, where 1 denotes the first metal, 2 the second one etc. Metals can also be identified by negative indicies, where -1 denotes the top-most metal, -2 the metal below that etc.",
        "examples": "generics.metalfill(1) generics.metalfill(-2)",
    },
    {
        "module": "generics",
        "funcname": "mptmetalfill",
        "syntax": "mptmetalfill(index, maskindex)",
        "description": "create a generic layer representing a metal fill shape with multiple-patterning (mpt) information. Some technologies have special layer for metal fillings, but technology files can also map these to the same layers as generics.metal(). Metals are identified by numeric indices, where 1 denotes the first metal, 2 the second one etc. Metals can also be identified by negative indicies, where -1 denotes the top-most metal, -2 the metal below that etc. The mask information is a numeric indix starting at 1. The number of available masks for the respective metal can be queried by technology.multiple_patterning_number(metalnumber). Whether a metal is a mpt metal can be queried by technology.has_multiple_patterning(metalnumber)",
        "examples": "generics.mptmetal(1, 1) generics.mptmetal(1, 2)",
    },
    {
        "module": "generics",
        "funcname": "metalexclude",
        "syntax": "metalexclude(index)",
        "description": "create a generic layer representing a metal exclude where automatic filling is blocked. Metals are identified by numeric indices, where 1 denotes the first metal, 2 the second one etc. Metals can also be identified by negative indicies, where -1 denotes the top-most metal, -2 the metal below that etc.",
        "examples": "generics.metalexclude(1) generics.metalexclude(-2)",
    },
    {
        "module": "generics",
        "funcname": "viacut",
        "syntax": "viacut(m1index, m2index)",
        "description": "create a generic layer representing a via cut. This does not calculate the right size for the via cuts. This function is rarely used directly. Via cuts are generated by geometry.via[bltr]. If you are using this function as a user, it is likely you are doing something wrong",
        "examples": "generics.viacut(1, 2)",
    },
    {
        "module": "generics",
        "funcname": "contact",
        "syntax": "contact(region)",
        "description": "create a generic layer representing a contact. This does not calculate the right size for the contact cuts. This function is rarely used directly. Contact cuts are generated by geometry.contact[bltr]. If you are using this function as a user, it is likely you are doing something wrong",
        "examples": "generics.contact(\"gate\")",
    },
    {
        "module": "generics",
        "funcname": "oxide",
        "syntax": "oxide(index)",
        "description": "create a generic layer representing a marking layer for MOSFET gate oxide thickness (e.g. for core or I/O devices)",
        "examples": "generics.oxide(2)",
    },
    {
        "module": "generics",
        "funcname": "implant",
        "syntax": "implant(polarity)",
        "description": "Create a generic layer representing MOSFET source/drain implant polarity",
        "examples": "generics.implant(\"n\")",
    },
    {
        "module": "generics",
        "funcname": "well",
        "syntax": "well(polarity)",
        "description": "Create a generic layer representing a well",
        "examples": "generics.well(\"n\")",
    },
    {
        "module": "generics",
        "funcname": "vthtype",
        "syntax": "vthtype(index)",
        "description": "Create a generic layer representing MOSFET source/drain threshold voltage marking layers",
        "examples": "generics.vthtype(2)",
    },
    {
        "module": "generics",
        "funcname": "active",
        "syntax": "active()",
        "description": "create a generic layer representing active area, for instance for mosfets.",
        "examples": "generics.active()",
    },
    {
        "module": "generics",
        "funcname": "gate",
        "syntax": "gate()",
        "description": "create a generic layer representing gate area of mosfets",
        "examples": "generics.gate()",
    },
    {
        "module": "generics",
        "funcname": "feol",
        "syntax": "feol(identifier)",
        "description": "create a front-end-of-line layer. This is for layers that do not need special processing, such as \"silicideblocker\".",
        "examples": "generics.feol(\"gate\")",
    },
    {
        "module": "generics",
        "funcname": "beol",
        "syntax": "beol(identifier)",
        "description": "create a back-end-of-line layer. This is for layers that do not need special processing, such as \"padopening\".",
        "examples": "generics.beol(\"gate\")",
    },
    {
        "module": "generics",
        "funcname": "marker",
        "syntax": "marker(type, level)",
        "description": "Create a generic layer representing any marker (a non-physical layer)",
        "examples": "generics.marker(\"inductor\") generics.marker(\"lvs\", 2)",
    },
    {
        "module": "generics",
        "funcname": "devicelabel",
        "syntax": "devicelabel(type)",
        "description": "Create a generic device-marking layer (a non-physical layer, used for labels)",
        "examples": "generics.devicelabel(\"resistancelevel2\") generics.marker(\"specialmosfet\")",
    },
    {
        "module": "generics",
        "funcname": "exclude",
        "syntax": "exclude(identifier)",
        "description": "create a generic layer representing an exclude where automatic filling is blocked.",
        "examples": "generics.exclude(\"gate\")",
    },
    {
        "module": "generics",
        "funcname": "fill",
        "syntax": "fill(identifier)",
        "description": "create a generic layer representing a fill. Some technologies have special layer for fillings, but technology files can also map these to the same layers with their main purposes.",
        "examples": "generics.fill(\"gate\")",
    },
    {
        "module": "generics",
        "funcname": "other",
        "syntax": "other(identifier)",
        "description": "create a generic layer representing 'something else'. This is for layers that are special to the used technology node and should not be used for generic layout representation",
        "examples": "generics.other(\"somespecialfoundrylayer\")",
    },
    {
        "module": "generics",
        "funcname": "otherport",
        "syntax": "otherport(identifier)",
        "description": "create a generic layer representing a port for 'something else'. This is for layers that are special to the used technology node and should not be used for generic layout representation",
        "examples": "generics.otherport(\"somespecialfoundrylayer\")",
    },
    {
        "module": "generics",
        "funcname": "outline",
        "syntax": "outline()",
        "description": "create a generic layer representing a block outline",
        "examples": "generics.outline()",
    },
    {
        "module": "generics",
        "funcname": "special",
        "syntax": "special()",
        "description": "Create a 'special' layer. This is used to mark certain things in layouts (usually for debugging, like anchors or alignment boxes). This is not intended to translate to any meaningful layer for fabrication",
        "examples": "generics.special()",
    },
    {
        "module": "generics",
        "funcname": "premapped",
        "syntax": "premapped(name, entries)",
        "description": "Create a non-generic layer from specific layer data for a certain technology. The entries table should contain one table per supported export. The supplied key-value pairs in this table must match the key-value pairs that are expected by the export",
        "examples": "generics.premapped(\"specialmetal\", { gds = { layer = 32, purpose = 17 }, SKILL = { layer = \"specialmetal\", purpose = \"drawing\" } })",
    },
    {
        "module": "geometry",
        "funcname": "rectanglebltr",
        "syntax": "rectanglebltr(cell, layer, bl, tr)",
        "description": "Create a rectangular shape with the given corner points in cell",
        "examples": "geometry.rectanglebltr(cell, generics.other(\"nwell\"), point.create(-100, -100), point.create(100, 100)) geometry.rectanglebltr(cell, generics.metal(1), obj:get_anchor(\"bottomleft\"), obj:get_anchor(\"topright\")) geometry.rectanglebltr(cell, generics.metal(-1), point.create(-100, -100), point.create(100, 100)) ",
    },
    {
        "module": "geometry",
        "funcname": "rectangleblwh",
        "syntax": "rectangleblwh(cell, layer, bl, width, height)",
        "description": "Create a rectangular shape with the given bottom-left corner point and the width and height in cell",
        "examples": "geometry.rectangleblwh(cell, generics.other(\"nwell\"), point.create(-100, -100), 200, 200)",
    },
    {
        "module": "geometry",
        "funcname": "rectanglepoints",
        "syntax": "rectanglepoints(cell, layer, pt1, pt2)",
        "description": "Create a rectangular shape with the given corner points in cell. Similar to geometry.rectanglebltr, but any of the corner points can be given in any order",
        "examples": "geometry.rectanglepoints(cell, generics.metal(1), point.create(100, -100), point(-100, 100))",
    },
    {
        "module": "geometry",
        "funcname": "rectangleareaanchor",
        "syntax": "rectangleareaanchor(cell, layer, anchor)",
        "description": "Create a rectangular shape on an area anchor of the given cell.",
        "examples": "geometry.rectangleareaanchor(cell, generics.metal(1), \"someanchor\")",
    },
    {
        "module": "geometry",
        "funcname": "rectanglepath",
        "syntax": "rectanglepath(cell, layer, pt1, pt2, width, extension)",
        "description": "Create a rectangular shape that is defined by its path-like endpoints. This function behaves like geometry.path, but takes only two points, not a list of points. This function likely will be removed in the future, use geometry.rectanglebltr or geometry.rectanglepoints",
        "examples": "geometry.rectanglepath(cell, generics.metal(1), point.create(-100, 0), point(100, 0), 50)",
    },
    {
        "module": "geometry",
        "funcname": "rectanglearray",
        "syntax": "rectanglearray(cell, layer, width, height, xshift, yshift, xrep, yrep, xpitch, ypitch)",
        "description": "Create an array of rectangles with the given width, height, repetition and pitch in cell",
        "examples": "geometry.rectanglebltr(cell, generics.other(\"nwell\"), 100, 100, 0, 0, 10, 20, 200, 200)",
    },
    {
        "module": "geometry",
        "funcname": "slotted_rectangle",
        "syntax": "slotted_rectangle(cell, layer, bl, tr, slotwidth, slotheight, slotxspace, slotxspace, slotedgexspace, slotedgeyspace)",
        "description": "Create a rectangle with slotting",
        "examples": "geometry.slotted_rectangle(cell, generics.other(\"nwell\"), point.create(-200, -2000), point.create(200, 2000), 50, 50, 50, 50, 100, 100)",
    },
    {
        "module": "geometry",
        "funcname": "rectanglevlines",
        "syntax": "rectanglevlines(cell, layer, pt1, pt2, numlines, ratio)",
        "description": "Fill a rectangular area with vertical lines with a given ratio between width and spacing",
        "examples": "geometry.rectanglevlines(cell, generics.metal(1), point.create(100, -100), point(-100, 100), 8, 1)",
    },
    {
        "module": "geometry",
        "funcname": "rectanglevlines_width_space",
        "syntax": "rectanglevlines_width_space(cell, layer, pt1, pt2, numlines, width)",
        "description": "Fill a rectangular area with a certain number of vertical lines with the given width. The spacing is calculated automatically.",
        "examples": "geometry.rectanglevlines_numlines_width(cell, generics.metal(1), point.create(100, -100), point(-100, 100), 4, 20)",
    },
    {
        "module": "geometry",
        "funcname": "rectanglevlines_width_space",
        "syntax": "rectanglevlines_width_space(cell, layer, pt1, pt2, width, space)",
        "description": "Fill a rectangular area with vertical lines with the given width and spacing. The given numbers are only targets, in some cases they can't be matched exactly.",
        "examples": "geometry.rectanglevlines_width_space(cell, generics.metal(1), point.create(100, -100), point(-100, 100), 20, 20)",
    },
    {
        "module": "geometry",
        "funcname": "rectanglevlines_settings",
        "syntax": "rectanglevlines_settings(cell, layer, pt1, pt2, numlines, ratio)",
        "description": "Calculate the geometries of vertical lines to fill a rectangular area with a given ratio between width and spacing. This function is like geometry.rectanglevlines, but it does not actually create the lines. It returns the width, height, space, offset and number of lines. These parameters can then be used to call geometry.rectanglearray. This function is useful if the parameters of the lines are required for further layout functions like placing vias.",
        "examples": "local width, height, space, offset, numlines = geometry.rectanglevlines_settings(point.create(-100, -100), point(100, 100), 20, 1) geometry.rectanglearray(cell, generics.metal(1), width, height, -100 + offset, -100, numlines, 1, width + space, 0)",
    },
    {
        "module": "geometry",
        "funcname": "rectanglevlines_width_space_settings",
        "syntax": "rectanglevlines_width_space_settings(cell, layer, pt1, pt2, width, space)",
        "description": "Calculate the geometries of vertical lines to fill a rectangular area with a given width and spacing. This function is like geometry.rectanglevlines_width_space, but it does not actually create the lines. It returns the width, height, space, offset and number of lines. These parameters can then be used to call geometry.rectanglearray. This function is useful if the parameters of the lines are required for further layout functions like placing vias.",
        "examples": "local width, height, space, offset, numlines = geometry.rectanglevlines_width_space_settings(point.create(-100, -100), point(100, 100), 20, 20) geometry.rectanglearray(cell, generics.metal(1), width, height, -100 + offset, -100, numlines, 1, width + space, 0)",
    },
    {
        "module": "geometry",
        "funcname": "rectanglevlines_numlines_width_settings",
        "syntax": "rectanglevlines_numlines_width_settings(pt1, pt2, numlines, width)",
        "description": "Calculate the geometries of vertical lines to fill a rectangular area with a given number of lines and width. The function returns the width, height, space, offset and number of lines. These parameters can then be used to call geometry.rectanglearray. This function is useful if the parameters of the lines are required for further layout functions like placing vias.",
        "examples": "local width, height, space, offset, numlines = geometry.rectanglehlines_width_space_settings(point.create(-100, -100), point(100, 100), 4, 20) geometry.rectanglearray(cell, generics.metal(1), width, height, -100, -100 + offset, 1, numlines, 0, height + space)",
    },
    {
        "module": "geometry",
        "funcname": "rectanglehlines",
        "syntax": "rectanglehlines(cell, layer, pt1, pt2, numlines, ratio)",
        "description": "Fill a rectangular area with horizontal lines with a given ratio between width and spacing",
        "examples": "geometry.rectanglehlines(cell, generics.metal(1), point.create(100, -100), point(-100, 100), 8, 1)",
    },
    {
        "module": "geometry",
        "funcname": "rectanglehlines_height_space",
        "syntax": "rectanglehlines_height_space(cell, layer, pt1, pt2, height, space)",
        "description": "Fill a rectangular area with horizontal lines with the given height and spacing. The given numbers are only targets, in some cases they can't be matched exactly.",
        "examples": "geometry.rectanglehlines(cell, generics.metal(1), point.create(100, -100), point(-100, 100), 20, 20)",
    },
    {
        "module": "geometry",
        "funcname": "rectanglehlines_settings",
        "syntax": "rectanglehlines_settings(cell, layer, pt1, pt2, numlines, ratio)",
        "description": "Calculate the geometries of horizontal lines to fill a rectangular area with a given ratio between width and spacing. This function is like geometry.rectanglehlines, but it does not actually create the lines. It returns the width, height, space, offset and number of lines. These parameters can then be used to call geometry.rectanglearray. This function is useful if the parameters of the lines are required for further layout functions like placing vias.",
        "examples": "local width, height, space, offset, numlines = geometry.rectanglehlines_settings(point.create(-100, -100), point(100, 100), 20, 1) geometry.rectanglearray(cell, generics.metal(1), width, height, -100, -100 + offset, 1, numlines, 0, height + space)",
    },
    {
        "module": "geometry",
        "funcname": "rectanglehlines_height_space_settings",
        "syntax": "rectanglehlines_height_space_settings(cell, layer, pt1, pt2, width, space)",
        "description": "Calculate the geometries of horizontal lines to fill a rectangular area with a given height and spacing. This function is like geometry.rectanglehlines_width_space, but it does not actually create the lines. It returns the width, height, space, offset and number of lines. These parameters can then be used to call geometry.rectanglearray. This function is useful if the parameters of the lines are required for further layout functions like placing vias.",
        "examples": "local width, height, space, offset, numlines = geometry.rectanglehlines_height_space_settings(point.create(-100, -100), point(100, 100), 20, 20) geometry.rectanglearray(cell, generics.metal(1), width, height, -100, -100 + offset, 1, numlines, 0, height + space)",
    },
    {
        "module": "geometry",
        "funcname": "rectanglehlines_numlines_height_settings",
        "syntax": "rectanglehlines_numlines_height_settings(pt1, pt2, numlines, height)",
        "description": "Calculate the geometries of horizontal lines to fill a rectangular area with a given number of lines and height. The function returns the width, height, space, offset and number of lines. These parameters can then be used to call geometry.rectanglearray. This function is useful if the parameters of the lines are required for further layout functions like placing vias.",
        "examples": "local width, height, space, offset, numlines = geometry.rectanglehlines_height_space_settings(point.create(-100, -100), point(100, 100), 4, 20) geometry.rectanglearray(cell, generics.metal(1), width, height, -100, -100 + offset, 1, numlines, 0, height + space)",
    },
    {
        "module": "geometry",
        "funcname": "rectangle_fill_in_boundary",
        "syntax": "rectangle_fill_in_boundary(cell, layer, width, height, xpitch, ypitch, xstartshift, ystartshift, boundary, excludes)",
        "description": "Fill a given boundary (a polygon) with rectangles of a given width and height. If given, the rectangles are not placed in the regions defined by the exclude rectangles. Optionally, binary excludes can be given, where no fill is placed. This should be a table containing polygons, which can (for instance) be fetched from cells by object:get_boundary().",
        "examples": "geometry.rectangle_fill_in_boundary(     cell,      generics.metal(1),      100, 100,      200, 200,      { point.create(-10000, -10000), point.create(10000, -10000), point.create(10000, 10000), point.create(-10000, 10000) },      { util.rectangle_to_polygon( point.create(1000, 1000), point.create(2000, 2000)) } )",
    },
    {
        "module": "geometry",
        "funcname": "polygon",
        "syntax": "polygon(cell, layer, pts)",
        "description": "Create a polygon shape with the given points in cell",
        "examples": "geometry.polygon(cell, generics.metal(1), { point.create(-50, 0), point.create(50, 0), point.create(0, 50))",
    },
    {
        "module": "geometry",
        "funcname": "path",
        "syntax": "path(cell, layer, pts, width, extension)",
        "description": "Create a path shape with the given points and width in cell",
        "examples": "geometry.path(cell, generics.metal(1), { point.create(-50, 0), point.create(50, 0), point.create(50, 50))",
    },
    {
        "module": "geometry",
        "funcname": "path_polygon",
        "syntax": "path_polygon(cell, layer, pts, width, extension)",
        "description": "Like geometry.path, but create a polygon with the outline of the path, not the actual path. From a physical standpoint, the result is the same.",
        "examples": "geometry.path_polygon(cell, generics.metal(1), { point.create(-50, 0), point.create(50, 0), point.create(50, 50))",
    },
    {
        "module": "geometry",
        "funcname": "path_manhatten",
        "syntax": "path_manhatten(cell, layer, pts, width, extension)",
        "description": "Create a manhatten path shape with the given points and width in cell. This only allows vertical or horizontal movements",
        "examples": "geometry.path_manhatten(cell, generics.metal(1), { point.create(-50, 0), point.create(50, 50))",
    },
    {
        "module": "geometry",
        "funcname": "path_2x",
        "syntax": "path_2x(cell, layer, ptstart, ptend, width)",
        "description": "Create a path that starts at ptstart and ends at ptend by moving first in x direction, then in y-direction (similar to an 'L')",
        "examples": "geometry.path_2x(cell, generics.metal(2), point.create(0, 0), point.create(200, 200))",
    },
    {
        "module": "geometry",
        "funcname": "path_2x_polygon",
        "syntax": "path_2x_polygon(cell, layer, ptstart, ptend, width)",
        "description": "Like geometry.path_2x, but create a polygon with the outline of the path, not the actual path. From a physical standpoint, the result is the same.",
        "examples": "geometry.path_2x_polygon(cell, generics.metal(2), point.create(0, 0), point.create(200, 200))",
    },
    {
        "module": "geometry",
        "funcname": "path_2y",
        "syntax": "path_2y(cell, layer, ptstart, ptend, width)",
        "description": "Create a path that starts at ptstart and ends at ptend by moving first in y direction, then in x-direction (similar to an capital greek gamma)",
        "examples": "geometry.path_2y(cell, generics.metal(2), point.create(0, 0), point.create(200, 200))",
    },
    {
        "module": "geometry",
        "funcname": "path_2y_polygon",
        "syntax": "path_2y_polygon(cell, layer, ptstart, ptend, width)",
        "description": "Like geometry.path_2y, but create a polygon with the outline of the path, not the actual path. From a physical standpoint, the result is the same.",
        "examples": "geometry.path_2y_polygon(cell, generics.metal(2), point.create(0, 0), point.create(200, 200))",
    },
    {
        "module": "geometry",
        "funcname": "path_3x",
        "syntax": "path_3x(cell, layer, ptstart, ptend, width, position, extension)",
        "description": "Create a path that starts at ptstart and ends at ptend by moving first in x direction, then in y-direction. Different from path_2x this make a bend in the middle between the start and the end point. The position factor influences where the middle point lies. It is a linear interpolation between the start- and the end-point, with a factor of 0.5 leading to exactly the middle. Values closer to 0 shift this point to the beginning, values closer to 1 shift this point to the end.",
        "examples": "geometry.path_3x(cell, generics.metal(2), point.create(0, 0), point.create(200, 200), 0.5)",
    },
    {
        "module": "geometry",
        "funcname": "path_3x_polygon",
        "syntax": "path_3x_polygon(cell, layer, ptstart, ptend, width, position, extension)",
        "description": "Like geometry.path_3x, but create a polygon with the outline of the path, not the actual path. From a physical standpoint, the result is the same.",
        "examples": "geometry.path_3x_polygon(cell, generics.metal(2), point.create(0, 0), point.create(200, 200), 0.5)",
    },
    {
        "module": "geometry",
        "funcname": "path_3x_diagonal",
        "syntax": "path_3x_diagonal(cell, layer, ptstart, ptend, width, position, extension)",
        "description": "Create a path that starts at ptstart and ends at ptend by moving first in x direction, then in x-direction. Different from path_3x the middle segment is diagonal. The position factor influences where the middle point lies. It is a linear interpolation between the start- and the end-point, with a factor of 0.5 leading to exactly the middle. Values closer to 0 shift this point to the beginning, values closer to 1 shift this point to the end.",
        "examples": "geometry.path_3x_diagonal(cell, generics.metal(2), point.create(0, 0), point.create(200, 200), 0.5)",
    },
    {
        "module": "geometry",
        "funcname": "path_3x_diagonal_polygon",
        "syntax": "path_3x_diagonal_polygon(cell, layer, ptstart, ptend, width, position, extension)",
        "description": "Like geometry.path_3x_diagonal_polygon, but create a polygon with the outline of the path, not the actual path. From a physical standpoint, the result is the same.",
        "examples": "geometry.path_3x_diagonal_polygon(cell, generics.metal(2), point.create(0, 0), point.create(200, 200), 0.5)",
    },
    {
        "module": "geometry",
        "funcname": "path_3y",
        "syntax": "path_3y(cell, layer, ptstart, ptend, width, position, extension)",
        "description": "Create a path that starts at ptstart and ends at ptend by moving first in y direction, then in x-direction. Different from path_2x this make a bend in the middle between the start and the end point. The position factor influences where the middle point lies. It is a linear interpolation between the start- and the end-point, with a factor of 0.5 leading to exactly the middle. Values closer to 0 shift this point to the beginning, values closer to 1 shift this point to the end.",
        "examples": "geometry.path_3y(cell, generics.metal(2), point.create(0, 0), point.create(200, 200), 0.5)",
    },
    {
        "module": "geometry",
        "funcname": "path_3y_polygon",
        "syntax": "path_3y_polygon(cell, layer, ptstart, ptend, width, position, extension)",
        "description": "Like geometry.path_3y, but create a polygon with the outline of the path, not the actual path. From a physical standpoint, the result is the same.",
        "examples": "geometry.path_3y_polygon(cell, generics.metal(2), point.create(0, 0), point.create(200, 200), 0.5)",
    },
    {
        "module": "geometry",
        "funcname": "path_3y_diagonal",
        "syntax": "path_3y_diagonal(cell, layer, ptstart, ptend, width, position, extension)",
        "description": "Create a path that starts at ptstart and ends at ptend by moving first in y direction, then in x-direction. Different from path_3y the middle segment is diagonal. The position factor influences where the middle point lies. It is a linear interpolation between the start- and the end-point, with a factor of 0.5 leading to exactly the middle. Values closer to 0 shift this point to the beginning, values closer to 1 shift this point to the end.",
        "examples": "geometry.path_3y_diagonal(cell, generics.metal(2), point.create(0, 0), point.create(200, 200), 0.5)",
    },
    {
        "module": "geometry",
        "funcname": "path_3y_diagonal_polygon",
        "syntax": "path_3y_diagonal_polygon(cell, layer, ptstart, ptend, width, position, extension)",
        "description": "Like geometry.path_3y_diagonal, but create a polygon with the outline of the path, not the actual path. From a physical standpoint, the result is the same.",
        "examples": "geometry.path_3y_diagonal_polygon(cell, generics.metal(2), point.create(0, 0), point.create(200, 200), 0.5)",
    },
    {
        "module": "geometry",
        "funcname": "path_cshape",
        "syntax": "path_cshape(cell, layer, ptstart, ptend, ptoffset, width)",
        "description": "Create a path shape that starts and ends at the start and end point, respectively and passes through the offset point. Only the x-coordinate of the offset point is taken, creating a shape resembling a (possibly inverted) 'C'",
        "examples": "geometry.path_cshape(cell, generics.metal(1), point.create(-50, 50), point.create(-50, -50), point.create(100, 0))",
    },
    {
        "module": "geometry",
        "funcname": "path_ushape",
        "syntax": "path_ushape(cell, layer, ptstart, ptend, ptoffset, width)",
        "description": "Create a path shape that starts and ends at the start and end point, respectively and passes through the offset point. Only the y-coordinate of the offset point is taken, creating a shape resembling a (possibly inverted) 'U'",
        "examples": "geometry.path_ushape(cell, generics.metal(1), point.create(-50, 0), point.create(50, 0), point.create(0, 100))",
    },
    {
        "module": "geometry",
        "funcname": "path_points_xy",
        "syntax": "path_points_xy(ptstart, pts)",
        "description": "Create a point list for use in geometry.path that contains only horizontal and vertical movements based on a list of points or scalars. This function only creates the resulting list of points, no shapes by itself. A movement can be a point, in which case two resulting movements are created: first x, than y (or vice versa, depending on the current state). A scalar movement moves relatively by that amount (in x or y, again depending on the state) This function does the same as geometry.path_points_yx, but starts in x-direction",
        "examples": "geometry.path(cell, generics.metal(2), geometry.path_points_xy(point.create(0, 0), {     100, -- move 100 to the right     100, -- move 200 upwards       0, -- don't move, but switch direction     point.create(300, 300) -- move to (300, 300), first in y-direction, than in x-direction     }), 100)",
    },
    {
        "module": "geometry",
        "funcname": "path_points_yx",
        "syntax": "path_points_yx(ptstart, pts)",
        "description": "Create a point list for use in geometry.path that contains only horizontal and vertical movements based on a list of points or scalars. This function only creates the resulting list of points, no shapes by itself. A movement can be a point, in which case two resulting movements are created: first x, than y (or vice versa, depending on the current state). A scalar movement moves relatively by that amount (in x or y, again depending on the state) This function does the same as geometry.path_points_xy, but starts in y-direction",
        "examples": "geometry.path(cell, generics.metal(2), geometry.path_points_yx(point.create(0, 0), {     100, -- move 100 to the right     100, -- move 200 upwards       0, -- don't move, but switch direction     point.create(300, 300) -- move to (300, 300), first in y-direction, than in x-direction     }), 100)",
    },
    {
        "module": "geometry",
        "funcname": "check_viabltr",
        "syntax": "check_viabltr(firstmetal, lastmetal, bl, tr, properties)",
        "description": "Check whether a via can be created. This is essentially a dry-run of geometry.viabltr(). It is useful for cells that (for instance) place vias on the intersections of vertical and horizontal powerlines with non-matching pitch. Here it can occur that a via is built only on a partial overlap, making the creation fail. As this does not actually create a via, a cell as target is not present as function parameter. The properties table is the same as for geometry.viabltr()",
        "examples": "geometry.check_viabltr(1, 3, point.create(-100, -20), point.create(100, 20))",
    },
    {
        "module": "geometry",
        "funcname": "check_viabltrov",
        "syntax": "check_viabltrov(firstmetal, lastmetal, bl1, tr1, bl2, tr2)",
        "description": "Check whether an overlap via can be created. This is essentially a dry-run of geometry.viabltrov(). It is useful for cells that (for instance) place vias on the intersections of vertical and horizontal powerlines with non-matching pitch. Here it can occur that a via is built only on a partial overlap, making the creation fail. As this does not actually create a via, a cell as target is not present as function parameter.",
        "examples": "geometry.check_viabltrov(1, 3, point.create(-100, -20), point.create(100, 20), point.create(-20, -100), point.create(20, 100))",
    },
    {
        "module": "geometry",
        "funcname": "calculate_viabltr",
        "syntax": "calculate_viabltr(firstmetal, lastmetal, bl, tr, properties)",
        "description": "Calculates possible via arrayzation in an area and returns a table with the results. Internally, the same functions as for direct creation of vias is used, so the same results can be obtained. The table contains tables with the following items (one per solution): \"layer\" (the via cut layer), \"width\" and \"height\" of the to-be-drawn cuts, \"xrep\" and \"yrep\" (repetition in x and y of the cuts), \"xspace\" and \"yspace\" (spacing of the contacts), and \"xoffset\" and \"yoffset\" (x/y offset with regard to array placement, for instance for geometry.rectanglearray)",
        "examples": "local via = geometry.calculate_viabltr(1, 3, point.create(-100, -20), point.create(100, 20))",
    },
    {
        "module": "geometry",
        "funcname": "calculate_viabltr",
        "syntax": "calculate_viabltr(firstmetal, lastmetal, bl1, tr1, bl2, tr2, properties)",
        "description": "Calculates possible via arrayzation in an area and returns a table with the results. Internally, the same functions as for direct creation of vias is used, so the same results can be obtained. The table contains tables with the following items (one per solution): \"layer\" (the via cut layer), \"width\" and \"height\" of the to-be-drawn cuts, \"xrep\" and \"yrep\" (repetition in x and y of the cuts), \"xspace\" and \"yspace\" (spacing of the contacts), and \"xoffset\" and \"yoffset\" (x/y offset with regard to array placement, for instance for geometry.rectanglearray). This function is like viabltr2, where two regions are given, with possibly-different sizes. Note though that only consecutive metals can be given (with a difference of 1).",
        "examples": "local via = geometry.calculate_viabltr(1, 3, point.create(-100, -20), point.create(100, 20))",
    },
    {
        "module": "geometry",
        "funcname": "viabltr",
        "syntax": "viabltr(cell, firstmetal, lastmetal, bl, tr, debugstring, options)",
        "description": "Create vias (single or stack) in a rectangular area with the given corner points in cell. Special properties can be passed to the via generation function: 'xcontinuous' (create vias that can be abutted in x-direction, boolean), 'ycontinuous' (create vias that can be abutted in y-direction, boolean), 'minxspace' (minimum x space), 'minyspace' (minimum y space), 'equal_pitch' (use equal spacing in both x- and y-direction, boolean) and 'widthclass' (give a width of the surrounding metal that the via is placed in and create the via as if it had this width. This is useful to solve DRC issues. Numeric parameter)",
        "examples": "geometry.viabltr(cell, 1, 3, point.create(-100, -20), point.create(100, 20))",
    },
    {
        "module": "geometry",
        "funcname": "viapoints",
        "syntax": "viapoints(cell, firstmetal, lastmetal, pt1, pt2, debugstring, options)",
        "description": "Create vias (single or stack) in a rectangular area with the given corner points in cell. Similar to geometry.rectanglepoints, the order o the points does not matter, any corner points of the rectangle can be given. Special properties can be passed to the via generation function: 'xcontinuous' (create vias that can be abutted in x-direction, boolean), 'ycontinuous' (create vias that can be abutted in y-direction, boolean), 'minxspace' (minimum x space), 'minyspace' (minimum y space), 'equal_pitch' (use equal spacing in both x- and y-direction, boolean) and 'widthclass' (give a width of the surrounding metal that the via is placed in and create the via as if it had this width. This is useful to solve DRC issues. Numeric parameter)",
        "examples": "geometry.viapoints(cell, 1, 3, point.create(100, 20), point.create(-100, -20))",
    },
    {
        "module": "geometry",
        "funcname": "viabltr",
        "syntax": "viabltr(cell, firstmetal, lastmetal, bl1, tr1, bl2, tr2, debugstring, options)",
        "description": "Create vias (single or stack) in a rectangular area with the given corner points in cell. Two regions are given, one for each metal. This allows vias with tighter spacing, as lower metals might require less enclosure around the via cuts. The usage of this function only makes sense if contacts are defined with '[x/y]enclosure[1/2], instead of unnumbered enclosures. Special properties can be passed to the via generation function: 'minxspace' (minimum x space), 'minyspace' (minimum y space), and 'widthclass' (give a width of the surrounding metal that the via is placed in and create the via as if it had this width. This is useful to solve DRC issues. Numeric parameter)",
        "examples": "geometry.viabltr2(cell, 1, 3, point.create(-100, -20), point.create(100, 20), point.create(-150, -50), point.create(150, 50))",
    },
    {
        "module": "geometry",
        "funcname": "viabarebltr",
        "syntax": "viabarebltr(cell, firstmetal, lastmetal, bl, tr, debugstring, options)",
        "description": "Create vias (single or stack) in a rectangular area with the given corner points in cell. This function is like viabltr, but no metals are drawn",
        "examples": "geometry.viabarebltr(cell, 1, 3, point.create(-100, -20), point.create(100, 20))",
    },
    {
        "module": "geometry",
        "funcname": "viabltr_xcontinuous",
        "syntax": "viabltr_xcontinuous(cell, firstmetal, lastmetal, bl, tr, debugstring, options)",
        "description": "Create vias (single or stack) in a rectangular area with the given corner points in cell. This function creates vias that can be abutted in x-direction. For this, the space between cuts and the surroundings are equalized",
        "examples": "geometry.viabltr_xcontinuous(cell, 1, 3, point.create(-100, -20), point.create(100, 20))",
    },
    {
        "module": "geometry",
        "funcname": "viabltr_ycontinuous",
        "syntax": "viabltr_ycontinuous(cell, firstmetal, lastmetal, bl, tr, debugstring, options)",
        "description": "Create vias (single or stack) in a rectangular area with the given corner points in cell. This function creates vias that can be abutted in y-direction. For this, the space between cuts and the surroundings are equalized",
        "examples": "geometry.viabltr_ycontinuous(cell, 1, 3, point.create(-100, -20), point.create(100, 20))",
    },
    {
        "module": "geometry",
        "funcname": "viabltr_continuous",
        "syntax": "viabltr_continuous(cell, firstmetal, lastmetal, bl, tr, debugstring, options)",
        "description": "Create vias (single or stack) in a rectangular area with the given corner points in cell. This function creates vias that can be abutted in both x- and y-direction. For this, the space between cuts and the surroundings are equalized",
        "examples": "geometry.viabltr_continuous(cell, 1, 3, point.create(-100, -20), point.create(100, 20))",
    },
    {
        "module": "geometry",
        "funcname": "viabarebltr_xcontinuous",
        "syntax": "viabarebltr_xcontinuous(cell, firstmetal, lastmetal, bl, tr, debugstring, options)",
        "description": "Create vias (single or stack) in a rectangular area with the given corner points in cell. This function creates vias that can be abutted in x-direction. For this, the space between cuts and the surroundings are equalized. This function is like viabltr_xcontinuous, but no metals are drawn",
        "examples": "geometry.viabltr_xcontinuous(cell, 1, 3, point.create(-100, -20), point.create(100, 20))",
    },
    {
        "module": "geometry",
        "funcname": "viabarebltr_ycontinuous",
        "syntax": "viabarebltr_ycontinuous(cell, firstmetal, lastmetal, bl, tr, debugstring, options)",
        "description": "Create vias (single or stack) in a rectangular area with the given corner points in cell. This function creates vias that can be abutted in y-direction. For this, the space between cuts and the surroundings are equalized. This function is like viabltr_ycontinuous, but no metals are drawn",
        "examples": "geometry.viabltr_ycontinuous(cell, 1, 3, point.create(-100, -20), point.create(100, 20))",
    },
    {
        "module": "geometry",
        "funcname": "viabarebltr_continuous",
        "syntax": "viabarebltr_continuous(cell, firstmetal, lastmetal, bl, tr, debugstring, options)",
        "description": "Create vias (single or stack) in a rectangular area with the given corner points in cell. This function creates vias that can be abutted in both x- and y-direction. For this, the space between cuts and the surroundings are equalized. This function is like viabltr_continuous, but no metals are drawn",
        "examples": "geometry.viabltr_continuous(cell, 1, 3, point.create(-100, -20), point.create(100, 20))",
    },
    {
        "module": "geometry",
        "funcname": "viabltrov",
        "syntax": "viabltrov(cell, firstmetal, lastmetal, bl1, tr1, bl2, tr2, debugstring)",
        "description": "Create vias (only single transition) defined by the overlap of two rectangular areas. The typical usage is to define a overlap region by vertical and horizontal metal strips. With this approach metal enclosure rules can be satisfied for both metal layers, even though the overlap is technically too small to allow for via generation (where geometry.viabltr would fail). This allows for vias in highly constrained regions, but it is more restrictive than the geometry.viabltr family. The first and last metals need to be consecutive, it can only generate a single transition via (e.g. from metal 3 to metal 4) and it does not support any of the additional parameters (e.g. xcontinuous). While two arguments for the metals are technically not needed, the second metal argument is kept for compatibility reasons with geometry.viabltr",
        "examples": "geometry.viabltrov(cell,     1, 2,     point.create(-20, -100),     point.create(20, 100)     point.create(-100, -20)     point.create(100, 20) ) -- throws an error: geometry.viabltrov(cell,     1, 3,     point.create(-20, -100),     point.create(20, 100)     point.create(-100, -20)     point.create(100, 20) ) ",
    },
    {
        "module": "geometry",
        "funcname": "viabarebltrov",
        "syntax": "viabarebltrov(cell, firstmetal, lastmetal, bl1, tr1, bl2, tr2, debugstring)",
        "description": "Like viabltrov, but only create via cuts, not the metals.",
        "examples": "geometry.viabarebltrov(cell,     1, 2,     point.create(-20, -100),     point.create(20, 100)     point.create(-100, -20)     point.create(100, 20) )",
    },
    {
        "module": "geometry",
        "funcname": "viabltr",
        "syntax": "viabltr(cell, firstmetal, lastmetal, bl1, tr1, bl2, tr2, debugstring, options)",
        "description": "Like geometry.viabltr2, but only create the via cuts, not the metal regions.",
        "examples": "geometry.viabarebltr2(cell, 1, 3, point.create(-100, -20), point.create(100, 20), point.create(-150, -50), point.create(150, 50))",
    },
    {
        "module": "geometry",
        "funcname": "contactbltr",
        "syntax": "contactbltr(cell, region, bl, tr, debugstring, options)",
        "description": "Create contacts in a rectangular area with the given corner points in cell",
        "examples": "geometry.contactbltr(cell, \"sourcedrain\", point.create(-20, -250), point.create(20, 500))",
    },
    {
        "module": "geometry",
        "funcname": "contactbltrov",
        "syntax": "contactbltrov(cell, region, bl1, tr1, bl2, tr2, debugstring)",
        "description": "Create contacts defined by the overlap of two rectangular areas. With this approach enclosure rules can be satisfied for both layers (FEOL and metal), even though the overlap is technically too small to allow for contact generation (where geometry.contactbltr would fail). This allows for contacts in highly constrained regions, but it is more restrictive than the geometry.contactbltr family. This function does not support any of the additional parameters (e.g. xcontinuous).",
        "examples": "geometry.contactbltrov(cell,     \"gate\",     point.create(-20, -100),     point.create(20, 100)     point.create(-100, -20)     point.create(100, 20) ) ",
    },
    {
        "module": "geometry",
        "funcname": "contactbltr2",
        "syntax": "contactbltr2(cell, region, bl1, tr1, bl2, tr2, debugstring, options)",
        "description": "Create contacts in a rectangular area with the given corner points in cell. This function supports unequal target regions for the FEOL layer and the metal 1 layer. The usage of this function only makes sense if contacts are defined with '[x/y]enclosure[1/2], instead of unnumbered enclosures.",
        "examples": "geometry.contactbltr2(cell, \"sourcedrain\", point.create(-20, -250), point.create(20, 500), point.create(-10, -220), point.create(10, 400))",
    },
    {
        "module": "geometry",
        "funcname": "contactbarebltr",
        "syntax": "contactbarebltr(cell, region, bl, tr, debugstring, options)",
        "description": "Create contacts in a rectangular area with the given corner points in cell. This function creates 'bare' contacts, so only the cut layers, no surrouning metals or semi-conductor layers",
        "examples": "geometry.contactbarebltr(cell, \"sourcedrain\", point.create(-20, -250), point.create(20, 500))",
    },
    {
        "module": "geometry",
        "funcname": "cross",
        "syntax": "cross(cell, layer, width, height, crosssize)",
        "description": "Create a cross shape in the given cell. The cross is made up by two overlapping rectangles in horizontal and in vertical direction.",
        "examples": "geometry.cross(cell, generics.metal(2), 1000, 1000, 100)",
    },
    {
        "module": "geometry",
        "funcname": "unequal_ring_pts",
        "syntax": "unequal_ring_pts(cell, layer, outerbl, outertr, innerbl, innertr)",
        "description": "Create a ring shape with unequal ring widths in the given cell, defined by the corner points",
        "examples": "geometry.unequal_ring_pts(cell, generics.other(\"nwell\"), point.create(-1000, -1000), point.create(1000, 1000), point.create(-800, -800), point.create(800, 800))",
    },
    {
        "module": "geometry",
        "funcname": "unequal_ring",
        "syntax": "unequal_ring(cell, layer, center, width, height, leftringwidth, rightringwidth, topringwidth, bottomringwidth)",
        "description": "Create a ring shape with unequal ring widths in the given cell",
        "examples": "geometry.unequal_ring(cell, generics.other(\"nwell\"), point.create(0, 0), 2000, 2000, 100, 80, 20, 20)",
    },
    {
        "module": "geometry",
        "funcname": "ring",
        "syntax": "ring(cell, layer, center, width, height, ringwidth)",
        "description": "Create a ring shape width equal ring widths in the given cell. Like geometry.unequal_ring, but all widths are the same",
        "examples": "geometry.ring(cell, generics.other(\"nwell\"), point.create(0, 0), 2000, 2000, 100)",
    },
    {
        "module": "geometry",
        "funcname": "curve",
        "syntax": "curve(cell, layer, origin, segments, grid, allow45)",
        "description": "Create a curve shape width in the given cell. Segments must be added for a curve to be meaningful. See the functions for adding curve segments: curve.lineto, curve.arcto and curve.cubicto",
        "examples": "geometry.curve(cell, generics.metal(-1), _pt(radius * math.cos(math.pi / 180 * angle), radius * math.sin(math.pi / 180 * angle)), {  curve.arcto(135, 180, cornerradius, false),  }, grid, allow45)  geometry.curve(cell, generics.metal(-2), _pt((radius + cornerradius) * math.cos(math.pi / 180 * angle) - cornerradius, (radius + cornerradius) * math.sin(math.pi / 180 * angle)), {  curve.arcto(180, 135, cornerradius, true),  }, grid, allow45)",
    },
    {
        "module": "geometry",
        "funcname": "curve_rasterized",
        "syntax": "curve_rasterized(cell, layer, origin, segments, grid, allow45)",
        "description": "Like geometry.curve, but rasterize the curve right now. Typically, the rasterization happens later in the layout generation process (it is resolved when the design is exported, depending whether the export format supports arbitrary curves, in which case there is no rasterization). This function is useful to generate rasterized curves for export formats that support arbitrary curves.",
        "examples": "geometry.curve_rasterized(cell, generics.metal(-1), _pt(radius * math.cos(math.pi / 180 * angle), radius * math.sin(math.pi / 180 * angle)), {  curve.arcto(135, 180, cornerradius, false),  }, grid, allow45)  geometry.curve(cell, generics.metal(-2), _pt((radius + cornerradius) * math.cos(math.pi / 180 * angle) - cornerradius, (radius + cornerradius) * math.sin(math.pi / 180 * angle)), {  curve.arcto(180, 135, cornerradius, true),  }, grid, allow45)",
    },
    {
        "module": "geometry",
        "funcname": "get_side_path_points",
        "syntax": "get_side_path_points(pts, width)",
        "description": "Get one side of the edge points of a path given by the center points and the width. The sign of the width is significant: With positive values, the right-hand-side points are created, with negative values the left-hand-side (in the direction of the path). This function does not create any shapes.",
        "examples": "geometry.get_side_path_points({ point.create(0, 0), point.create(1000, 0) }, 50)",
    },
    {
        "module": "geometry",
        "funcname": "path_points_to_polygon",
        "syntax": "path_points_to_polygon(pts, width)",
        "description": "Get the edge points of a path given by the center points and the width. This function does not create any shapes. The result of this function can be put into geometry.polygon to create the path shape.",
        "examples": "geometry.path_points_to_polygon({ point.create(0, 0), point.create(1000, 0) }, 50)",
    },
    {
        "module": "geometry",
        "funcname": "offset_polygon_points",
        "syntax": "offset_polygon_points(pts, offset)",
        "description": "Create a table with new polygon points by offsetting (moving the edges towards the outside or inside).",
        "examples": "geometry.offset_polygon_points(polygonpts, 200)",
    },
    {
        "module": "<none>",
        "funcname": "parameters",
        "syntax": "parameters()",
        "description": "Cell definition function. Define cell parameters. This function takes no arguments and does not return anything (the value will be ignored). This function is optional, but a cell without parameters is not very useful.",
        "examples": "function parameters()     pcell.add_parameters(         { \"param1\", 0 },         { \"param2\", 100 }    ) end",
    },
    {
        "module": "<none>",
        "funcname": "process_parameters",
        "syntax": "process_parameters(_P)",
        "description": "Cell definition function. Process parameters after user values have been set. This can be used to re-evaluate parameters based on different settings. As an example the width of a metal line could be set to the minimum width value of the used metal. This can not be done in regular parameter definitions for cells. The function receives the table with all parameter values and should return a new table with altered parameters. Every parameter in this new table will overwrite a parameter in the main parameter table, but only if it was not explicitly modified when calling the cell. This function is optional.",
        "examples": "function process_parameters(_P)     local t = {}     t.width = technology.get_dimension(string.format(\"Minimum M%d Width\"), _P.metal)     t.length = _P.totallength -- simple follower parameter     return t end",
    },
    {
        "module": "<none>",
        "funcname": "prepare",
        "syntax": "prepare(_P)",
        "description": "Cell definition function. Prepare a state for further cell functions. This function is useful when some calculations/logic have to be run for different functions (for instance check() and layout()). In order to avoid code duplication, the prepare() function can be used. It receives the final parameters table (after a possible call to process_parameters()) and is expected to return a table as a common state for all following cell functions. This function is optional.",
        "examples": "function process_parameters(_P)     local t = {}     t.width = technology.get_dimension(string.format(\"Minimum M%d Width\"), _P.metal)     _P.length = _P.totallength -- simple follower parameter end",
    },
    {
        "module": "<none>",
        "funcname": "check",
        "syntax": "check(_P, cellstate)",
        "description": "Cell definition function. Check parameters for sane values. This function should return 'true' if all checks succeed. This means that an empty check function should still return 'true'. Any arbitrary checks can be implemented (typically simply 'if ... then return false, message end') and if a check fails the function should return 'false' and a message. This function can receive (if present) the cellstate from prepare(). This function is optional, but if present the last statement should be 'return true'.",
        "examples": "function check(_P, cellstate)     if _P.topmetal > 4 then         return false, string.format(\"the top metal must not exceed 4, got %d\", _P.topmetal)     end     return true -- final return end",
    },
    {
        "module": "<none>",
        "funcname": "layout",
        "syntax": "layout(cell, _P, env, cellstate)",
        "description": "Cell definition function. Main layout definition of a cell. This function receives an object where shapes, instances, ports etc. are to be placed in. This function should not create its own top-level layout object (even if it did, it would simply be ignored). As inputs the function receives (besides the object) the final parameter values, and possibly a cell environment and the common cell state. The parameter table controls the layout creation and should always be present (just like 'parameters()', although both are technically optional). The cell environment is equal for all called cells (invocations but also cell types) within one opc call, there is only one cell environment. This can be used for cells of one project that only work together. For this reason, it is not used in standard cell implementations in openPCells. The cellstate is the shared common cellstate from a potential 'prepare()' call. This function is technically optional, but only in very rare cases it is not needed (a base cell defining parameters can be created, see stdcells/base).",
        "examples": "function layout(cell, _P)     geometry.rectanglebltr(cell, generics.metal(1), point.create(0, 0), point.create(_P.width, _P.height)) end  function layout(cell, _P, env)     if env.XXX then ... end end  function layout(cell, _P, _envnotused, state)     if state.XXX then ... end end",
    },
    {
        "module": "<none>",
        "funcname": "set",
        "syntax": "set(...)",
        "description": "define a set of possible values that a parameter can take. Only useful within a parameter definition of a pcell",
        "examples": "pcell.add_parameters({ { \"mostype\", \"nmos\", posvals = set(\"nmos\", \"pmos\") } })",
    },
    {
        "module": "<none>",
        "funcname": "interval",
        "syntax": "interval(lower, upper)",
        "description": "define an interval of possible values that a parameter can take. Only useful within a parameter definition of a pcell",
        "examples": "pcell.add_parameters({ { \"fingers\", 2, posvals = interval = (1, inf) } })",
    },
    {
        "module": "<none>",
        "funcname": "even",
        "syntax": "even()",
        "description": "define that a parameter must be even. Only useful within a parameter definition of a pcell",
        "examples": "pcell.add_parameters({ { fingerwidth, 100, posvals = even() } })",
    },
    {
        "module": "<none>",
        "funcname": "odd",
        "syntax": "odd()",
        "description": "define that a parameter must be odd. Only useful within a parameter definition of a pcell",
        "examples": "pcell.add_parameters({ { fingerwidth, 100, posvals = odd() } })",
    },
    {
        "module": "<none>",
        "funcname": "positive",
        "syntax": "positive()",
        "description": "define that a parameter must be positive. Only useful within a parameter definition of a pcell",
        "examples": "pcell.add_parameters({ { fingerwidth, 100, posvals = positive() } })",
    },
    {
        "module": "<none>",
        "funcname": "negative",
        "syntax": "negative()",
        "description": "define that a parameter must be negative. Only useful within a parameter definition of a pcell",
        "examples": "pcell.add_parameters({ { offset, -100, posvals = negative() } })",
    },
    {
        "module": "<none>",
        "funcname": "enable",
        "syntax": "enable(bool, value)",
        "description": "multiply a value with 1 or 0, depending on a boolean parameter. Essentially val * (bool and 1 or 0)",
        "examples": "enable(_P.drawguardring, _P.guardringspace)",
    },
    {
        "module": "<none>",
        "funcname": "evenodddiv2",
        "syntax": "evenodddiv2(value)",
        "description": "divide a value by 2. If it is odd, return floor(val / 2) and ceil(val / 2), otherwise return val / 2",
        "examples": "local low, high = evenodddiv2(13) -- return 6 and 7",
    },
    {
        "module": "<none>",
        "funcname": "divevenup",
        "syntax": "divevenup(value, div)",
        "description": "approximately divide a value by the divisor, so that the result is even. If this can't be achieved with the original value, increment it until it works",
        "examples": "local result = divevenup(6, 2) -- returns 4",
    },
    {
        "module": "<none>",
        "funcname": "divevendown",
        "syntax": "divevendown(value, div)",
        "description": "approximately divide a value by the divisor, so that the result is even. If this can't be achieved with the original value, decrement it until it works",
        "examples": "local result = divevendown(6, 2) -- returns 2",
    },
    {
        "module": "<none>",
        "funcname": "dprint",
        "syntax": "dprint(...)",
        "description": "debug print. Works like regular print (which is not available in pcell definitions). Only prints something when opc is called with --enable-dprint",
        "examples": "dprint(_P.fingers)",
    },
    {
        "module": "graphics",
        "funcname": "quartercircle",
        "syntax": "quartercircle(origin, radius, startangle, endangle, grid, allow45)",
        "description": "Create a rasterized circle quarter (a polygon) with the given parameters. The generated quadrant is the first (between 0 and 90 degrees). The rasterization is governed by the grid, a finer grid produces more points, a looser grid fewer. With 'allow45' false, only a single x- or y-movement is allowed at each step, with 'allow45' true there can also be simultaneous x/y moves (diagonal edges). This function does not create any shapes, use with geometry.polygon if you want to actually have a circle shape.",
        "examples": "local pts = graphics.quartercircle(point.create(0, 0), 5000, 100, false)",
    },
    {
        "module": "graphics",
        "funcname": "quarterellipse",
        "syntax": "quarterellipse(origin, x-radius, y-radius, startangle, endangle, grid, allow45)",
        "description": "Create a rasterized ellipse quarter (a polygon) with the given parameters. The generated quadrant is the first (between 0 and 90 degrees). The rasterization is governed by the grid, a finer grid produces more points, a looser grid fewer. With 'allow45' false, only a single x- or y-movement is allowed at each step, with 'allow45' true there can also be simultaneous x/y moves (diagonal edges). This function does not create any shapes, use with geometry.polygon if you want to actually have a ellipse shape.",
        "examples": "local pts = graphics.quarterellipse(point.create(0, 0), 5000, 100, false)",
    },
    {
        "module": "graphics",
        "funcname": "circle",
        "syntax": "circle(origin, radius, startangle, endangle, grid, allow45)",
        "description": "Create a rasterized circle (a polygon) with the given parameters. The rasterization is governed by the grid, a finer grid produces more points, a looser grid fewer. With 'allow45' false, only a single x- or y-movement is allowed at each step, with 'allow45' true there can also be simultaneous x/y moves (diagonal edges). This function does not create any shapes, use with geometry.polygon if you want to actually have a circle shape.",
        "examples": "local pts = graphics.circle(point.create(0, 0), 5000, 0, 360, 100, false)",
    },
    {
        "module": "graphics",
        "funcname": "ellipse",
        "syntax": "ellipse(origin, xradius, yradius, startangle, endangle, grid, allow45)",
        "description": "Create a rasterized ellipse (a polygon) with the given parameters. The rasterization is governed by the grid, a finer grid produces more points, a looser grid fewer. With 'allow45' false, only a single x- or y-movement is allowed at each step, with 'allow45' true there can also be simultaneous x/y moves (diagonal edges). This function does not create any shapes, use with geometry.polygon if you want to actually have a ellipse shape.",
        "examples": "local pts = graphics.ellipse(point.create(0, 0), 5000, 10000, 0, 360, 100, false)",
    },
    {
        "module": "graphics",
        "funcname": "circle",
        "syntax": "circle(origin, numpoints, startangle)",
        "description": "Create a coarse rendering of a circle, where points lying on the circle are simply connected by polygon edges. No rasterization is performed. This function creates regular polygons, for instance with 8 points an octagonal shape is generated.",
        "examples": "local pts = graphics.coarse_circle(point.create(0, 0), 5000, 0)",
    },
    {
        "module": "layouthelpers",
        "funcname": "via_area_anchor_multiple",
        "syntax": "via_area_anchor_multiple(cell, startmetal, endmetal, fmt, startindex, endindex, increment)",
        "description": "place a via stack on an area anchor of the given cell (also places the via stack in the given cell). The via stack starts at the startmetal and ends at the endmetal. The vias are created within a for-loop that starts at the given startindex and ends at the given endindex. Optionally, an increment value (default 1) can be given. The fourth argument is a base name for the area anchor, in with the percent sign ('%') is replaced by the current iterator value.",
        "examples": "layouthelpers.via_area_anchor_multiple(cell, 1, 2, \"gate_%\", 1, 8 )",
    },
    {
        "module": "layouthelpers",
        "funcname": "place_bus",
        "syntax": "place_bus(cell, layer, pts, numbits, width, space)",
        "description": "place a bus with 'numbits' lines with the given 'width' and 'space'. The bus is defined by the path points (like a regular path), which define the center of the bus.",
        "examples": "layouthelpers.place_bus(cell,     generics.metal(2),     pts,     16     100, 100 )",
    },
    {
        "module": "layouthelpers",
        "funcname": "place_guardring",
        "syntax": "place_guardring(cell, bl, tr, xspace, yspace, anchorprefix, options)",
        "description": "place a guardring in a cell with a defined boundary and spacing",
        "examples": "layouthelpers.place_guardring(cell,     nmos:get_area_anchor(\"active\").bl,     nmos:get_area_anchor(\"active\").tr,     200, 200,     \"guardring_\",     {         contype = \"n\",         ringwidth = 100,         drawdeepwell = true,     } )",
    },
    {
        "module": "layouthelpers",
        "funcname": "place_guardring_quantized",
        "syntax": "place_guardring_quantized(cell, bl, tr, xspace, yspace, basexsize, baseysize, anchorprefix, options)",
        "description": "place a guardring in a cell with a defined boundary and spacing. The guardring hole width and height are quantized so that they fit a multiple of the specified basesize (x and y). This does NOT account for the width of the guardring. While this might be a short-coming of this function, this issue can easily be circumvented by using a ring width that is also a multiple of the basesize.",
        "examples": "layouthelpers.place_guardring_quantized(cell,     nmos:get_area_anchor(\"active\").bl,     nmos:get_area_anchor(\"active\").tr,     200, 200,     500, 500,     \"guardring_\",     {         contype = \"n\",         ringwidth = 100,         drawdeepwell = true,     } )",
    },
    {
        "module": "layouthelpers",
        "funcname": "place_guardring_with_hole",
        "syntax": "place_guardring_with_hole(cell, bl, tr, hbl, htr, xspace, yspace, wellxoffset, wellyoffset, anchorprefix, options)",
        "description": "place a guardring with a well hole in a cell with a defined boundary and spacing. This function is like placement.place_guardring, but expects two more points that define the hole boundary. The placed guardring then has a hole in the well which encompasses exactly the given boundary. The connection to this inner well is not placed, this has to be done manually.",
        "examples": "layouthelpers.place_guardring_with_hole(cell,     nmos:get_area_anchor(\"active\").bl,     pmos:get_area_anchor(\"active\").tr,     pmos:get_area_anchor(\"active\").bl,     pmos:get_area_anchor(\"active\").tr),     200, 200,     0, 0,     \"guardring_\",     {         contype = \"n\",         ringwidth = 100,         drawdeepwell = true,     } )",
    },
    {
        "module": "layouthelpers",
        "funcname": "place_guardring_with_hole_quantized",
        "syntax": "place_guardring_with_hole_quantized(cell, bl, tr, hbl, htr, xspace, yspace, basexsize, baseysize, wellxoffset, wellyoffset, anchorprefix, options)",
        "description": "This function is like placement.place_guardring_with_hole, but creates a guardring whose hole width and height are made a multiple of the given basesize (x and y). See also the information on placement.place_guardring_quantized.",
        "examples": "layouthelpers.place_guardring_with_hole_quantized(cell,     nmos:get_area_anchor(\"active\").bl,     nmos:get_area_anchor(\"active\").tr,     pmos:get_area_anchor(\"active\").bl,     pmos:get_area_anchor(\"active\").tr,     200, 200,     0, 0,     500, 500,     \"guardring_\",     {         contype = \"n\",         ringwidth = 100,         drawdeepwell = true,     } )",
    },
    {
        "module": "layouthelpers",
        "funcname": "place_double_guardring",
        "syntax": "place_double_guardring(cell, bl, tr, xspace, yspace, innercontype, anchorprefix1, anchorprefix2, options)",
        "description": "place a guardring in a cell with a defined boundary and spacing",
        "examples": "layouthelpers.place_double_guardring(cell,     nmos:get_area_anchor(\"active\").bl,     nmos:get_area_anchor(\"active\").tr,     200, 200,     \"p\",     \"innerguardring_\", \"outerguardring_\",     {         contype = \"n\",         ringwidth = 100,     } )",
    },
    {
        "module": "layouthelpers",
        "funcname": "place_welltap",
        "syntax": "place_welltap(cell, bl, tr, anchorprefix, options)",
        "description": "place a welltap in a cell with a defined boundary and spacing",
        "examples": "layouthelpers.place_welltap(cell,     nmos:get_area_anchor(\"sourcestrap\").bl,     nmos:get_area_anchor(\"sourcestrap\").tr,     {         contype = \"n\",     } )",
    },
    {
        "module": "layouthelpers",
        "funcname": "place_maximum_width_via",
        "syntax": "place_maximum_width_via(cell, firstmetal, lastmetal, pt1, pt2)",
        "description": "place a via (or a via stack) in an object. The function behaves like geometry.viabltr, but takes into account the maximum width of the metal layers. This means that possibly not all vias are created with the full width of the given region. This means that the first point (pt1) must touch the actual shape that should connect to the via. Therefore, pt1 and pt2 don't have to be the lower-left and the top-right corner points. The maximum widths are specified by the technology constraint file (entries \"Maximum Mn Width\", where 'n' is an integer). If no values are specified, the full width of the via region is used, in which case the function behaves exactly like geometry.viabltr (except for the order of the points).",
        "examples": "layouthelpers.place_maximum_width_via(cell, 1, 8, point.create(-100, 200), point.create(-800, 1500))",
    },
    {
        "module": "layouthelpers",
        "funcname": "place_coplanar_waveguide",
        "syntax": "place_coplanar_waveguide(cell, layer, pts, swidth, gwidth, separation)",
        "description": "place a coplanar waveguide defined by the center path points. This function is almost the same as geometry.path but draws three paths in total (ground-signal-ground).",
        "examples": "local pts = {     point.create(0, 0),     point.create(100000, 0),     point.create(100000, 100000) } layouthelpers.place_coplanar_waveguide(cell, generics.metal(-1), pts, 5000, 10000, 10000)",
    },
    {
        "module": "layouthelpers",
        "funcname": "place_stripline",
        "syntax": "place_stripline(cell, metalindex, pts, swidth, gwidth)",
        "description": "place a stripline defined by the center path points. This function is almost the same as geometry.path but draws three paths in total (ground-signal-ground). The layer argument is NOT a generic layer but a metal index (as striplines are assumed to be drawn in a metal). The metals below and above the signal layer are used for ground. Therefore, 'metalindex' must be 2 and the highest metal (-1).",
        "examples": "local pts = {     point.create(0, 0),     point.create(100000, 0),     point.create(100000, 100000) } layouthelpers.place_stripline(cell, 4, pts, 5000, 10000)",
    },
    {
        "module": "layouthelpers",
        "funcname": "collect_gridlines",
        "syntax": "collect_gridlines(t, cells, anchorname)",
        "description": "combine overlapping/touching rectangular anchors into larger rectangles. This function expects a list of cells that all have at least the given area anchor. Then all overlaps are computed an inserted into the table. This function is useful when placing vias from a powergrid down to power bars. If only the individual anchors are used it can happen (depending on the type of the grid cell) that only partial vias can be placed. Merging the lines beforehand solves this.",
        "examples": "local lines = {} layouthelpers.collect_gridlines(lines, gridcells, \"vddline\")",
    },
    {
        "module": "layouthelpers",
        "funcname": "place_powergrid",
        "syntax": "place_powergrid(cell, bl, tr, vlayer, hlayer, vwidth, vspace, hwidth, hspace, plusshapes, minusshapes)",
        "description": "Create a power grid with vertical and horizontal lines that connect to given target shapes. The power grid lays out alternating lines for the 'plus' net and the 'minus' net (e.g., VDD and VSS). Target shapes for both these nets are given in the form of tables containing { bl = ..., tr = ... } pairs.",
        "examples": "local vddshapes = { { bl = point(2000, 0), tr = point.create(8000, 200) } } local vssshapes = { { bl = point.create(2000, 800), tr = point.create(8000, 1000) } } layouthelpers.place_powergrid(cell,     point.create(0, 0), point.create(10000, 4000) -- target area,     5, 6, -- metal layers     400, 800,-- vertical width/space      400, 800,-- horizontal width/space     vddshapes, vssshapes)",
    },
    {
        "module": "layouthelpers",
        "funcname": "place_powervlines",
        "syntax": "place_powervlines(cell, bl, tr, layer, width, space, powershapes)",
        "description": "Create power lines with vertical lines that connect to given target shapes. Target shapes for the power net are given in the form of tables containing { bl = ..., tr = ... } pairs.",
        "examples": "local powershapes = { { bl = point(2000, 0), tr = point.create(8000, 200) } } layouthelpers.place_powervlines(cell,     point.create(0, 0), point.create(10000, 4000) -- target area,     5, -- metal layer     400, 800,-- width/space     powershapes)",
    },
    {
        "module": "layouthelpers",
        "funcname": "place_powerhlines",
        "syntax": "place_powerhlines(cell, bl, tr, layer, width, space, powershapes)",
        "description": "Create power lines with horizontal lines that connect to given target shapes. Target shapes for the power net are given in the form of tables containing { bl = ..., tr = ... } pairs.",
        "examples": "local powershapes = { { bl = point(2000, 0), tr = point.create(8000, 200) } } layouthelpers.place_powerhlines(cell,     point.create(0, 0), point.create(10000, 4000) -- target area,     5, -- metal layer     400, 800,-- height/space     powershapes)",
    },
    {
        "module": "layouthelpers",
        "funcname": "place_vlines_numsets",
        "syntax": "place_vlines_numsets(cell, bl, tr, layer, width, netnames, numsets)",
        "description": "Create vertical lines in a cell on a given layer. The target area is given as well as the width of the placed lines. The number of placed lines is calculated from the number of given nets and the number of net sets (numnets * numsets). This function returns a table with a net target entry for every line, where one entry looks like this: { net = <netname>, bl = <bl>, tr = <tr>, layer = <layer> }",
        "examples": "local netshapes = layouthelpers.place_vlines_numsets(cell,     point.create(0, 0), point.create(10000, 4000) -- target area,     generics.metal(5), -- layer     400, -- width     { \"VDD\", \"VSS\", \"BIAS\", }, -- net names      4 -- number of sets)",
    },
    {
        "module": "layouthelpers",
        "funcname": "place_vlines",
        "syntax": "place_vlines(cell, bl, tr, layer, width, space, minheight, netnames, excludes)",
        "description": "Create vertical lines in a cell on a given layer. The target area is given as well as the width of the placed lines. The number of placed lines is calculated from the available area and the width and space. Additionally a table with exclude polygons can be given. No lines will be drawn in these excludes. Note that the minimum fitting rectangle around the polygon is used, not the polygon itself. This might result in too pessimistic line placement. However, as most geometries are rectangles, in general this will work quite well. As excludes can cause short lines to be created, the 'minheight' parameter restricts the creation of too small lines. This can be 0 (zero), then all possible lines will be created. This function returns a table with a net target entry for every line, where one entry looks like this: { net = <netname>, bl = <bl>, tr = <tr>, layer = <layer> }",
        "examples": "local netshapes = layouthelpers.place_vlines(cell,     point.create(0, 0), point.create(10000, 4000) -- target area,     generics.metal(5), -- layer     400, 400, -- width/space     { \"VDD\", \"VSS\", \"BIAS\", }, -- net names)",
    },
    {
        "module": "layouthelpers",
        "funcname": "place_hlines_numsets",
        "syntax": "place_hlines_numsets(cell, bl, tr, layer, height, netnames, numsets)",
        "description": "Create horizontal lines in a cell on a given layer. The target area is given as well as the width of the placed lines. The number of placed lines is calculated from the number of given nets and the number of net sets (numnets * numsets). This function returns a table with a net target entry for every line, where one entry looks like this: { net = <netname>, bl = <bl>, tr = <tr>, layer = <layer> }",
        "examples": "local netshapes = layouthelpers.place_hlines_numsets(cell,     point.create(0, 0), point.create(4000, 10000) -- target area,     generics.metal(5), -- layer     400, -- height     { \"VDD\", \"VSS\", \"BIAS\", }, -- net names      4 -- number of sets)",
    },
    {
        "module": "layouthelpers",
        "funcname": "place_hlines",
        "syntax": "place_hlines(cell, bl, tr, layer, width, space, minwidth, netnames, excludes)",
        "description": "Create horizontal lines in a cell on a given layer. The target area is given as well as the width of the placed lines. The number of placed lines is calculated from the available area and the height and space. Additionally a table with exclude polygons can be given. No lines will be drawn in these excludes. Note that the minimum fitting rectangle around the polygon is used, not the polygon itself. This might result in too pessimistic line placement. However, as most geometries are rectangles, in general this will work quite well. As excludes can cause short lines to be created, the 'minwidth' parameter restricts the creation of too small lines. This can be 0 (zero), then all possible lines will be created. This function returns a table with a net target entry for every line, where one entry looks like this: { net = <netname>, bl = <bl>, tr = <tr>, layer = <layer> }",
        "examples": "local netshapes = layouthelpers.place_hlines(cell,     point.create(0, 0), point.create(4000, 10000) -- target area,     generics.metal(5), -- layer     400, 400, -- width/space     { \"VDD\", \"VSS\", \"BIAS\", }, -- net names)",
    },
    {
        "module": "layouthelpers",
        "funcname": "place_vias",
        "syntax": "place_vias(cell, metal1, metal2, netshapes1, netshapes2, excludes, netfilter, onlyfull, nocheck)",
        "description": "Create vias in a cell connecting net shapes on different metal layers. This function creates vias between the given layers. If not net filter is given, all netshapes with matching nets are connected. A table with exclusion polygons can be given, which is useful when vias across several layers are created. If a table array with string items is given, only shapes on nets in that array are connected. 'nocheck' might cause the function to raise an error: when there are small overlaps without a legal via arrayzation, the function raises an error (as internally geometry.viabltr is used). With 'nocheck' == false (the default) the legality of the overlap for via generation is checked first and skipped if it would fail.",
        "examples": "layouthelpers.place_vias(cell,     1, 4, -- metal layers     netshapes1, netshapes2, -- netshapes     { \"VSS\" \"BIAS\" }, -- net filter)",
    },
    {
        "module": "layouthelpers",
        "funcname": "place_unequal_net_vias",
        "syntax": "place_unequal_net_vias(cell, metal1, metal2, netshapes1, netshapes2, netfilter, onlyfull, nocheck)",
        "description": "Create vias in a cell connecting net shapes on different metal layers and different nets. This function creates vias between the given layers. As this function creates vias between all shapes, only the net shapes should be given that need to be connected. (This function shorts different nets). This behaviour is different than layouthelpers.place_vias, where only shapes on equal nets are connected. 'nocheck' might cause the function to raise an error: when there are small overlaps without a legal via arrayzation, the function raises an error (as internally geometry.viabltr is used). With 'nocheck' == false (the default) the legality of the overlap for via generation is checked first and skipped if it would fail.",
        "examples": "layouthelpers.place_unequal_vias(cell,     1, 4, -- metal layers     netshapes1, netshapes2)",
    },
    {
        "module": "layouthelpers",
        "funcname": "annotate_netshapes",
        "syntax": "annotate_netshapes(cell, netshapes, sizehint)",
        "description": "Create labels on every given net shape in the table, on all four corners. Useful for e.g. creating bigger interconnect grids",
        "examples": "layouthelpers.annotate_netshapes(cell, netshapes, 200)",
    },
    {
        "module": "layouthelpers",
        "funcname": "connect_area_anchor",
        "syntax": "connect_area_anchor(cell, layer, width, anchor1, anchor2)",
        "description": "Create a connection between two given area anchors. This function is currently very basic and only exists for testing purposes. Its interface is likely to change as well as its function. It will create a working (and often also DRC-clean) connection, so it should be somewhat usable.",
        "examples": "layouthelpers.connect_area_anchor(cell, generics.metal(3), 500, cell:get_area_anchor(\"anchor1\"), cell:get_area_anchor(\"anchor2\"))",
    },
    {
        "module": "object",
        "funcname": "abut_area_anchor_bottom",
        "syntax": "abut_area_anchor_bottom(cell, anchorname, targetcell, targetanchorname)",
        "description": "translate the cell so that the specified area anchor is abutted to the bottom of the target area anchor of the specified target cell. This only changes the y coordinate",
        "examples": "cell:abut_area_anchor_bottom(\"topgatestrap\", othercell, \"botgatestrap\")",
    },
    {
        "module": "object",
        "funcname": "abut_area_anchor_left",
        "syntax": "abut_area_anchor_left(cell, anchorname, targetcell, targetanchorname)",
        "description": "translate the cell so that the specified area anchor is abutted to the left of the target area anchor of the specified target cell. This only changes the x coordinate",
        "examples": "cell:abut_area_anchor_left(\"leftsourcedrain\", othercell, \"rightsourcedrain\")",
    },
    {
        "module": "object",
        "funcname": "abut_area_anchor_right",
        "syntax": "abut_area_anchor_right(cell, anchorname, targetcell, targetanchorname)",
        "description": "translate the cell so that the specified area anchor is abutted to the right of the target area anchor of the specified target cell. This only changes the x coordinate",
        "examples": "cell:abut_area_anchor_right(\"rightsourcedrain\", othercell, \"leftsourcedrain\")",
    },
    {
        "module": "object",
        "funcname": "abut_area_anchor_top",
        "syntax": "abut_area_anchor_top(cell, anchorname, targetcell, targetanchorname)",
        "description": "translate the cell so that the specified area anchor is abutted to the top of the target area anchor of the specified target cell. This only changes the y coordinate",
        "examples": "cell:abut_area_anchor_top(\"botgatestrap\", othercell, \"topgatestrap\")",
    },
    {
        "module": "object",
        "funcname": "abut_bottom_origin",
        "syntax": "abut_bottom_origin(cell)",
        "description": "translate the cell so that its alignment box (outer boundary) is abutted-bottom to the origin. This only changes the y coordinate",
        "examples": "cell:abut_bottom_origin()",
    },
    {
        "module": "object",
        "funcname": "abut_bottom",
        "syntax": "abut_bottom(cell, targetcell)",
        "description": "translate the cell so that its alignment box is abutted to the bottom of the alignment box of the specified target cell. This only changes the y coordinate",
        "examples": "cell:abut_bottom(othercell)",
    },
    {
        "module": "object",
        "funcname": "abut_left_origin",
        "syntax": "abut_left_origin(cell)",
        "description": "translate the cell so that its alignment box (outer boundary) is abutted-left to the origin. This only changes the x coordinate",
        "examples": "cell:abut_left_origin()",
    },
    {
        "module": "object",
        "funcname": "abut_left",
        "syntax": "abut_left(cell, targetcell)",
        "description": "translate the cell so that its alignment box is abutted to the left of the alignment box of the specified target cell. This only changes the y coordinate",
        "examples": "cell:abut_left(othercell)",
    },
    {
        "module": "object",
        "funcname": "abut_right_origin",
        "syntax": "abut_right_origin(cell)",
        "description": "translate the cell so that its alignment box (outer boundary) is abutted-right to the origin. This only changes the x coordinate",
        "examples": "cell:abut_right_origin()",
    },
    {
        "module": "object",
        "funcname": "abut_right",
        "syntax": "abut_right(cell, targetcell)",
        "description": "translate the cell so that its alignment box is abutted to the right of the alignment box of the specified target cell. This only changes the y coordinate",
        "examples": "cell:abut_right(othercell)",
    },
    {
        "module": "object",
        "funcname": "abut_top_origin",
        "syntax": "abut_top_origin(cell)",
        "description": "translate the cell so that its alignment box (outer boundary) is abutted-top to the origin. This only changes the x coordinate",
        "examples": "cell:abut_top_origin()",
    },
    {
        "module": "object",
        "funcname": "abut_top",
        "syntax": "abut_top(cell, targetcell)",
        "description": "translate the cell so that its alignment box is abutted to the top of the alignment box of the specified target cell. This only changes the y coordinate",
        "examples": "cell:abut_top(othercell)",
    },
    {
        "module": "object",
        "funcname": "place_bottom_origin",
        "syntax": "place_bottom_origin(cell)",
        "description": "translate the cell so that its alignment box (outer boundary) is placed-bottom to the origin. This only changes the y coordinate. This is similar to the corresponding abut function, but uses the bounding boxes of the cells.",
        "examples": "cell:place_bottom_origin()",
    },
    {
        "module": "object",
        "funcname": "place_bottom",
        "syntax": "place_bottom(cell, targetcell)",
        "description": "translate the cell so that its alignment box is placed to the bottom of the alignment box of the specified target cell. This only changes the y coordinate. This is similar to the corresponding abut function, but uses the bounding boxes of the cells.",
        "examples": "cell:place_bottom(othercell)",
    },
    {
        "module": "object",
        "funcname": "place_left_origin",
        "syntax": "place_left_origin(cell)",
        "description": "translate the cell so that its alignment box (outer boundary) is placed-left to the origin. This only changes the x coordinate. This is similar to the corresponding abut function, but uses the bounding boxes of the cells.",
        "examples": "cell:place_left_origin()",
    },
    {
        "module": "object",
        "funcname": "place_left",
        "syntax": "place_left(cell, targetcell)",
        "description": "translate the cell so that its alignment box is placed to the left of the alignment box of the specified target cell. This only changes the y coordinate. This is similar to the corresponding abut function, but uses the bounding boxes of the cells.",
        "examples": "cell:place_left(othercell)",
    },
    {
        "module": "object",
        "funcname": "place_right_origin",
        "syntax": "place_right_origin(cell)",
        "description": "translate the cell so that its alignment box (outer boundary) is placed-right to the origin. This only changes the x coordinate. This is similar to the corresponding abut function, but uses the bounding boxes of the cells.",
        "examples": "cell:place_right_origin()",
    },
    {
        "module": "object",
        "funcname": "place_right",
        "syntax": "place_right(cell, targetcell)",
        "description": "translate the cell so that its alignment box is placed to the right of the alignment box of the specified target cell. This only changes the y coordinate. This is similar to the corresponding abut function, but uses the bounding boxes of the cells.",
        "examples": "cell:place_right(othercell)",
    },
    {
        "module": "object",
        "funcname": "place_top_origin",
        "syntax": "place_top_origin(cell)",
        "description": "translate the cell so that its alignment box (outer boundary) is placed-top to the origin. This only changes the x coordinate. This is similar to the corresponding abut function, but uses the bounding boxes of the cells.",
        "examples": "cell:place_top_origin()",
    },
    {
        "module": "object",
        "funcname": "place_top",
        "syntax": "place_top(cell, targetcell)",
        "description": "translate the cell so that its alignment box is placed to the top of the alignment box of the specified target cell. This only changes the y coordinate. This is similar to the corresponding abut function, but uses the bounding boxes of the cells.",
        "examples": "cell:place_top(othercell)",
    },
    {
        "module": "object",
        "funcname": "add_anchor",
        "syntax": "add_anchor(cell, name, where)",
        "description": "add an anchor to an object",
        "examples": "cell:add_anchor(\"output\", point.create(200, -20))",
    },
    {
        "module": "object",
        "funcname": "add_area_anchor_bltr",
        "syntax": "add_area_anchor_bltr(cell, name, bl, tr)",
        "description": "Add an area anchor to a cell, defined by the lower-left and upper-right corner points of the rectangular area",
        "examples": "cell:add_area_anchor_bltr(\"source\", point.create(-100, -20), point.create(100, 20))",
    },
    {
        "module": "object",
        "funcname": "add_area_anchor_points",
        "syntax": "add_area_anchor_points(cell, name, pt1, pt2)",
        "description": "Add an area anchor to a cell, defined by the two corner points of the rectangular area (order does not matter)",
        "examples": "cell:add_area_anchor_points(\"source\", point.create(100, 20), point.create(-100, -20))",
    },
    {
        "module": "object",
        "funcname": "add_area_anchor_blwh",
        "syntax": "add_area_anchor_blwh(cell, name, pt1, width, height)",
        "description": "Add an area anchor to a cell, defined by the the lower-left corner point and the width and height of the rectangular area",
        "examples": "cell:add_area_anchor_blwh(\"source\", point.create(-100, -20), 200, 40)",
    },
    {
        "module": "object",
        "funcname": "add_anchor_line_x",
        "syntax": "add_anchor_line_x(cell, name, x)",
        "description": "Add an anchor line to a cell (given its x-coordinate)",
        "examples": "cell:add_anchor_line_x(\"xbase\", 40)",
    },
    {
        "module": "object",
        "funcname": "add_anchor_line_y",
        "syntax": "add_anchor_line_y(cell, name, y)",
        "description": "Add an anchor line to a cell (given its y-coordinate)",
        "examples": "cell:add_anchor_line_y(\"ybase\", 40)",
    },
    {
        "module": "object",
        "funcname": "add_bus_port",
        "syntax": "add_bus_port(cell, name, layer, where, startindex, endindex, xpitch, ypitch)",
        "description": "add a bus port (multiple ports like vout[0:4]) to a cell. The port expression is portname[startindex:endindex] and portname[i] is placed at 'where' with an offset of ((i - 1) * xpitch, (i - 1) * ypitch)",
        "examples": "cell:add_bus_port(\"vout\", generics.metalport(4), point.create(200, 0), 0, 4, 200, 0)",
    },
    {
        "module": "object",
        "funcname": "add_child_array",
        "syntax": "add_child_array(cell, child, instname, xrep, yrep, xpitch, ypitch)",
        "description": "Add a child as an arrayed object to the given cell. The child array has xrep * yrep elements, with a pitch of xpitch and ypitch, respectively. The array grows to the upper-left, with the first placed untranslated. The pitch does not have to be explicitly given: If the child has an alignment box, the xpitch and ypitch are deferred from this box, if they are not given in the call. In this case, it is an error if no alignment box is present in child. As with object.add_child: don't use the original child object after this call unless it is object.add_child or object.add_child_array",
        "examples": "-- with explicit xpitch and ypitch: local ref = pcell.create_layout(\"basic/mosfet\", \"mosfet\") cell:add_child_array(ref, \"mosinst0\", 8, 1, 200, 0) -- with alignment box: local ref = pcell.create_layout(\"basic/mosfet\", \"mosfet\") cell:add_child_array(ref, \"mosinst0\", 8, 1)",
    },
    {
        "module": "object",
        "funcname": "add_layer_boundary",
        "syntax": "add_layer_boundary(cell, layer, boundary)",
        "description": "Add a layer boundary to an object. A layer boundary is useful for automatic filling",
        "examples": "cell:add_layer_boundary(generics.metal(1), { point.create(0, 0), point.create(1000, 0), point.create(500, 500) })",
    },
    {
        "module": "object",
        "funcname": "add_layer_boundary_rectangular",
        "syntax": "add_layer_boundary_rectangular(cell, layer, bl, tr)",
        "description": "Add a rectangular layer boundary to an object. A layer boundary is useful for automatic filling",
        "examples": "cell:add_layer_boundary_rectangular(generics.metal(1), point.create(-100, -100), point.create(100, 100))",
    },
    {
        "module": "object",
        "funcname": "add_label",
        "syntax": "add_label(cell, name, layer, where, sizehint)",
        "description": "add a label to a cell. Works like add_anchor, but additionally a layer is expected. This is different from add_port in that it expresses intent for labels that are not connectivity-related (as opposed to ports). A size hint can be given, which might be processed by the export.",
        "examples": "cell:add_label(\"0.8\", generics.other(\"M1voltagelabelhigh\"), point.create(100, 0))",
    },
    {
        "module": "object",
        "funcname": "add_port",
        "syntax": "add_port(cell, name, layer, where, sizehint)",
        "description": "add a port to a cell. Works like add_anchor, but additionally a layer is expected. A size hint can be given, which might be processed by the export.",
        "examples": "cell:add_port(\"vdd\", generics.metalport(2), point.create(100, 0))",
    },
    {
        "module": "object",
        "funcname": "add_port_with_anchor",
        "syntax": "add_port_with_anchor(cell, name, layer, where, sizehint)",
        "description": "add a port to a cell. Works like add_anchor, but additionally a layer is expected. This function also adds an anchor to the cell (named like the port). A size hint can be given, which might be processed by the export.",
        "examples": "cell:add_port_with_anchor(\"vdd\", generics.metalport(2), point.create(100, 0))",
    },
    {
        "module": "object",
        "funcname": "align_area_anchor_bottom",
        "syntax": "align_area_anchor_bottom(cell, anchorname, targetcell, targetanchorname)",
        "description": "translate the cell so that the specified area anchor is aligned to the bottom of the target area anchor of the specified target cell. This only changes the y coordinate",
        "examples": "cell:align_area_anchor_bottom(\"topgatestrap\", othercell, \"botgatestrap\")",
    },
    {
        "module": "object",
        "funcname": "align_area_anchor_left",
        "syntax": "align_area_anchor_left(cell, anchorname, targetcell, targetanchorname)",
        "description": "translate the cell so that the specified area anchor is aligned to the left of the target area anchor of the specified target cell. This only changes the x coordinate",
        "examples": "cell:align_area_anchor_left(\"leftsourcedrain\", othercell, \"rightsourcedrain\")",
    },
    {
        "module": "object",
        "funcname": "align_area_anchor_right",
        "syntax": "align_area_anchor_right(cell, anchorname, targetcell, targetanchorname)",
        "description": "translate the cell so that the specified area anchor is aligned to the right of the target area anchor of the specified target cell. This only changes the x coordinate",
        "examples": "cell:align_area_anchor_right(\"rightsourcedrain\", othercell, \"leftsourcedrain\")",
    },
    {
        "module": "object",
        "funcname": "align_area_anchor_top",
        "syntax": "align_area_anchor_top(cell, anchorname, targetcell, targetanchorname)",
        "description": "translate the cell so that the specified area anchor is aligned to the top of the target area anchor of the specified target cell. This only changes the y-coordinate",
        "examples": "cell:align_area_anchor_top(\"botgatestrap\", othercell, \"topgatestrap\")",
    },
    {
        "module": "object",
        "funcname": "align_area_anchor",
        "syntax": "align_area_anchor(cell, anchorname, targetcell, targetanchorname)",
        "description": "translate the cell so that the specified area anchor is aligned to the target area anchor of the specified target cell. This changes both the x- and the y-coordinate",
        "examples": "cell:align_area_anchor(\"leftsourcedrain\", othercell, \"rightsourcedrain\")",
    },
    {
        "module": "object",
        "funcname": "align_area_anchor_x",
        "syntax": "align_area_anchor_x(cell, anchorname, targetcell, targetanchorname)",
        "description": "translate the cell so that the specified area anchor is aligned to the target area anchor of the specified target cell. This changes only the x-coordinate",
        "examples": "cell:align_area_anchor_x(\"leftsourcedrain\", othercell, \"rightsourcedrain\")",
    },
    {
        "module": "object",
        "funcname": "align_area_anchor_y",
        "syntax": "align_area_anchor_y(cell, anchorname, targetcell, targetanchorname)",
        "description": "translate the cell so that the specified area anchor is aligned to the target area anchor of the specified target cell. This changes only the y-coordinate",
        "examples": "cell:align_area_anchor_y(\"leftsourcedrain\", othercell, \"rightsourcedrain\")",
    },
    {
        "module": "object",
        "funcname": "align_bottom",
        "syntax": "align_bottom(cell, targetcell)",
        "description": "translate the cell so that its alignment box is aligned to the bottom of the alignment box of the specified target cell. This only changes the y coordinate",
        "examples": "cell:align_bottom(othercell)",
    },
    {
        "module": "object",
        "funcname": "align_bottom_origin",
        "syntax": "align_bottom_origin(cell)",
        "description": "translate the cell so that its alignment box (outer boundary) is aligned-bottom to the origin. This only changes the y coordinate",
        "examples": "cell:align_bottom_origin(othercell)",
    },
    {
        "module": "object",
        "funcname": "align_left_origin",
        "syntax": "align_left_origin(cell)",
        "description": "translate the cell so that its alignment box (outer boundary) is aligned-left to the origin. This only changes the x coordinate",
        "examples": "cell:align_left_origin(othercell)",
    },
    {
        "module": "object",
        "funcname": "align_left",
        "syntax": "align_left(cell, targetcell)",
        "description": "translate the cell so that its alignment box is aligned to the left of the alignment box of the specified target cell. This only changes the x coordinate",
        "examples": "cell:align_left(othercell)",
    },
    {
        "module": "object",
        "funcname": "alignment_box_include_point",
        "syntax": "alignment_box_include_point(cell, pt)",
        "description": "extend the alignment box of a cell in a way that the given point is included in it. The alignment box is never shrunken, only enlarged.",
        "examples": "cell:alignment_box_include_point(point.create(200, 200))",
    },
    {
        "module": "object",
        "funcname": "alignment_box_include_x",
        "syntax": "alignment_box_include_x(cell, pt)",
        "description": "like alignment_box_include_point, but only change the x-coordinates of the alignment box. The y-coordinate is ignored, the second argument is a point only for convenience.",
        "examples": "cell:alignment_box_include_x(point.create(200, 200))",
    },
    {
        "module": "object",
        "funcname": "alignment_box_include_y",
        "syntax": "alignment_box_include_y(cell, pt)",
        "description": "like alignment_box_include_point, but only change the y-coordinates of the alignment box. The x-coordinate is ignored, the second argument is a point only for convenience.",
        "examples": "cell:alignment_box_include_y(point.create(200, 200))",
    },
    {
        "module": "object",
        "funcname": "align_right_origin",
        "syntax": "align_right_origin(cell)",
        "description": "translate the cell so that its alignment box (outer boundary) is aligned-right to the origin. This only changes the x coordinate",
        "examples": "cell:align_right_origin(othercell)",
    },
    {
        "module": "object",
        "funcname": "align_right",
        "syntax": "align_right(cell, targetcell)",
        "description": "translate the cell so that its alignment box is aligned to the right of the alignment box of the specified target cell. This only changes the x coordinate",
        "examples": "cell:align_right(othercell)",
    },
    {
        "module": "object",
        "funcname": "align_top_origin",
        "syntax": "align_top_origin(cell)",
        "description": "translate the cell so that its alignment box (outer boundary) is aligned-top to the origin. This only changes the y coordinate",
        "examples": "cell:align_top_origin(othercell)",
    },
    {
        "module": "object",
        "funcname": "align_top",
        "syntax": "align_top(cell, targetcell)",
        "description": "translate the cell so that its alignment box is aligned to the top of the alignment box of the specified target cell. This only changes the y coordinate",
        "examples": "cell:align_top(othercell)",
    },
    {
        "module": "object",
        "funcname": "align_center_x",
        "syntax": "align_center_x(cell, targetcell)",
        "description": "translate the cell so that its alignment box is centered (in x) to the alignment box of the specified target cell. This only changes the x coordinate",
        "examples": "cell:align_center_x(othercell)",
    },
    {
        "module": "object",
        "funcname": "align_center_y",
        "syntax": "align_center_y(cell, targetcell)",
        "description": "translate the cell so that its alignment boy is centered (in y) to the alignment boy of the specified target cell. This only changes the y coordinate",
        "examples": "cell:align_center_y(othercell)",
    },
    {
        "module": "object",
        "funcname": "clear_alignment_box",
        "syntax": "clear_alignment_box(cell)",
        "description": "clear (remove) the alignment box of a cell. Useful to set a new alignment box with object.set_alignment_box(...)",
        "examples": "cell:clear_alignment_box()",
    },
    {
        "module": "object",
        "funcname": "copy",
        "syntax": "copy(cell)",
        "description": "copy an object",
        "examples": "local new = cell:copy()",
    },
    {
        "module": "object",
        "funcname": "create_object_handle",
        "syntax": "create_object_handle(cell, reference)",
        "description": "create an object handle of a reference cell and store it in a parent cell. This is used internally when a cell is added for the first time as child. This function is exposed to the user in order to explicitly create these handles. They are useful when multiple cells in a hierarchy add the same object as a child, which would not be possible otherwise (this would require either a complete copy of the object with a new name or the cell hierarchy would contain the same object twice)",
        "examples": "local handle = object.create_object_handle(parent, reference) subcell1:add_child(handle, \"child\") subcell2:add_child(handle, \"child\") parent:add_child(subcell1, \"sub1\") parent:add_child(subcell2, \"sub2\")",
    },
    {
        "module": "object",
        "funcname": "create",
        "syntax": "create(cellname)",
        "description": "create a new object. A name must be given. Hierarchical exports use this name to identify layout cells and no checks for duplication are done. Therefore the user must make sure that every name is unique. Note that this will probably change in the future",
        "examples": "local cell = object.create(\"toplevel\")",
    },
    {
        "module": "object",
        "funcname": "create_pseudo",
        "syntax": "create_pseudo()",
        "description": "create a new object without a name. This kind of object behaves exactly like a regular object, but it can't be added as a child to a parent object. It is intended to be used as a flat container for shapes that are merged into another cell. This function is there to express this intent, but other than this there are no advantages of using this function over object.create() (except that one does not have to come up with a name)",
        "examples": "local container = object.create_pseudo()",
    },
    {
        "module": "object",
        "funcname": "exchange",
        "syntax": "exchange(cell, othercell)",
        "description": "Take over internal state of the other object, effectively making this the main cell. The object handle to 'othercell' must not be used afterwards as this object is destroyed. This function is only really useful in cells that act as a parameter wrapper for other cells (e.g. dffpq -> dff)",
        "examples": "cell:exchange(othercell)",
    },
    {
        "module": "object",
        "funcname": "extend_alignment_box",
        "syntax": "extend_alignment_box(cell, extouterblx, extouterbly, extoutertrx, extoutertry, extinnerblx, extinnerbly, extinnertrx, extinnertry)",
        "description": "extend an existing object alignment box. Takes eight values for the extension of the four corner points making up the alignment box",
        "examples": "cell:extend_alignment_box(-100, -100, 100, 100, 0, 0, 0, 0)",
    },
    {
        "module": "object",
        "funcname": "extend_alignment_box_x_symmetrical",
        "syntax": "extend_alignment_box_x_symmetrical(cell, extx)",
        "description": "extend an existing object alignment box. Takes only one value for the extension of the four corner points and extends all x-coordinates of the box symmetrically in the left/right direction",
        "examples": "cell:extend_alignment_box_x_symmetrical(200)",
    },
    {
        "module": "object",
        "funcname": "extend_alignment_box_xy_symmetrical",
        "syntax": "extend_alignment_box_xy_symmetrical(cell, extx, exty)",
        "description": "extend an existing object alignment box. Takes two values for the extension of the four corner points and extends all x- and y-coordinates of the box symmetrically in the left/right direction. This function is the same as calling the individual alignment box extension functions for x- and y-directions individually",
        "examples": "cell:extend_alignment_box_xy_symmetrical(200, 300)",
    },
    {
        "module": "object",
        "funcname": "extend_alignment_box_y_symmetrical",
        "syntax": "extend_alignment_box_y_symmetrical(cell, exty)",
        "description": "extend an existing object alignment box. Takes only one value for the extension of the four corner points and extends all y-coordinates of the box symmetrically in the left/right direction",
        "examples": "cell:extend_alignment_box_y_symmetrical(200)",
    },
    {
        "module": "object",
        "funcname": "flatten_inline",
        "syntax": "flatten_inline(cell, flattenports)",
        "description": "resolve the cell by placing all shapes from all children in the parent cell. This operates in-place and modifies the object. Copy the cell or use object:flatten() if this is unwanted. The second argument specifies if ports from lower levels are copied into the flattened object. The default for this is false.",
        "examples": "cell:flatten_inline() cell:copy():flatten_inline() cell:flatten_inline(true) -- flatten ports",
    },
    {
        "module": "object",
        "funcname": "flatten",
        "syntax": "flatten(cell, flattenports)",
        "description": "resolve the cell by placing all shapes from all children in the parent cell. This does not operate in-place, the object is copied. The second argument specifies if ports from lower levels are copied into the flattened object. The default for this is false.",
        "examples": "cell:flatten() cell:flatten(true) -- flatten ports",
    },
    {
        "module": "object",
        "funcname": "flipx",
        "syntax": "flipx(cell)",
        "description": "flip the entire object in x direction. This is similar to mirror_at_yaxis (note the x vs. y), but is done in-place. The object is translated so that it is still in its original location. Works best on objects with an alignment box, since this is used to calculate the required translation. On other objects, this operation can be time-consuming as an accurate bounding box has to be computed. It is recommended not to use this function on objects without an alignment box because the result is not always ideal",
        "examples": "cell:flipx()",
    },
    {
        "module": "object",
        "funcname": "flipy",
        "syntax": "flipy(cell)",
        "description": "flip the entire object in y direction. This is similar to mirror_at_xaxis (note the y vs. x), but is done in-place. The object is translated so that it is still in its original location. Works best on objects with an alignment box, since this is used to calculate the required translation. On other objects, this operation can be time-consuming as an accurate bounding box has to be computed. It is recommended not to use this function on objects without an alignment box because the result is not always ideal",
        "examples": "cell:flipy()",
    },
    {
        "module": "object",
        "funcname": "get_alignment_anchor",
        "syntax": "get_alignment_anchor(cell, anchorname)",
        "description": "Retrieve an alignment anchor from a cell. These anchors are the defining points of the alignment box. Valid anchor names are 'outerbl', 'outerbr', 'outertl', 'outertr', 'innerbl', 'innerbr', 'innertl' and 'innertr'. This function returns a point that contains the position of the specified anchor, corrected by the cell transformation. A non-existing anchor is an error",
        "examples": "cell:get_alignment_anchor(\"outerbl\")",
    },
    {
        "module": "object",
        "funcname": "get_all_regular_anchors",
        "syntax": "get_all_regular_anchors(cell, anchorname)",
        "description": "Create a table containing all regular (non-alignment) anchors of a cell. The table can be iterated with standard lua methods (pairs). Area anchors are reported with four anchors (bl, br, tl and tr)",
        "examples": "cell:get_all_regular_anchors()",
    },
    {
        "module": "object",
        "funcname": "get_anchor_line_x",
        "syntax": "get_anchor_line_x(cell, anchorname)",
        "description": "Retrieve an anchor line from a cell. This function returns a coordinate that contains the x-position of the specified anchor line, corrected by the cell transformation. Retrieving non-existing anchor lines raises an error. There is (and can't) be any checks that an x-coordinate is not used as a y-coordinate and vice versa.",
        "examples": "cell:get_anchor_line_x(\"activeleft\")",
    },
    {
        "module": "object",
        "funcname": "get_anchor_line_y",
        "syntax": "get_anchor_line_y(cell, anchorname)",
        "description": "Retrieve an anchor line from a cell. This function returns a coordinate that contains the y-position of the specified anchor line, corrected by the cell transformation. Retrieving non-existing anchor lines raises an error. There is (and can't) be any checks that an x-coordinate is not used as a y-coordinate and vice versa.",
        "examples": "cell:get_anchor_line_y(\"activetop\")",
    },
    {
        "module": "object",
        "funcname": "get_anchor",
        "syntax": "get_anchor(cell, anchorname)",
        "description": "Retrieve an anchor from a cell. This function returns a point that contains the position of the specified anchor, corrected by the cell transformation. Retrieving non-existing anchor raises an error.",
        "examples": "cell:get_anchor(\"sourcedrain1bl\")",
    },
    {
        "module": "object",
        "funcname": "get_area_anchor",
        "syntax": "get_area_anchor(cell, anchorname)",
        "description": "Retrieve an area anchor from a cell. This function returns a table with four points (bl (bottom-left), tr (top-right), br (bottom-right) and tl (top-left)) that contain the position of the specified area anchor, corrected by the cell transformation. Furthermore, the individual coordinates are also available as skalar values with the keys 'b', 't', 'l' and 'r'. Retrieving a non-existing anchor raises an error.",
        "examples": "cell:get_area_anchor(\"sourcedrain1\").bl point.create(cell1:get_area_anchor(\"sourcedrain1\").l, cell2:get_area_anchor(\"topgatestrap\").t)",
    },
    {
        "module": "object",
        "funcname": "get_area_anchor_fmt",
        "syntax": "get_area_anchor_fmt(cell, anchorname)",
        "description": "Like object.get_array_anchor, but call string.format on the input arguments",
        "examples": "cell:get_area_anchor_fmt(\"sourcedrain%d\", 1)",
    },
    {
        "module": "object",
        "funcname": "get_area_anchor_height",
        "syntax": "get_area_anchor_height(cell, anchorname)",
        "description": "Retrieve the height (an integer) of an area anchor from a cell. A non-existing anchor is an error",
        "examples": "local height = cell:get_area_anchor_height(\"sourcedrain1\")",
    },
    {
        "module": "object",
        "funcname": "get_area_anchor_width",
        "syntax": "get_area_anchor_width(cell, anchorname)",
        "description": "Retrieve the width (an integer) of an area anchor from a cell. A non-existing anchor is an error",
        "examples": "local width = cell:get_area_anchor_width(\"sourcedrain1\")",
    },
    {
        "module": "object",
        "funcname": "get_array_anchor",
        "syntax": "get_array_anchor(cell, xindex, yindex, anchorname)",
        "description": "Like object.get_anchor, but works on child arrays. The first two argument are the x- and the y-index (starting at 1, 1). Accessing an array anchor of a non-array object is an error",
        "examples": "local ref = object.create(\"ref\") local array = cell:add_child_array(ref, \"refarray\", 20, 2, 100, 1000) local anchor = array:get_array_anchor(4, 1, \"sourcedrain1bl\")",
    },
    {
        "module": "object",
        "funcname": "get_array_area_anchor",
        "syntax": "get_array_area_anchor(cell, xindex, yindex, anchorname)",
        "description": "Like object.get_area_anchor, but works on child arrays. The first two argument are the x- and the y-index (starting at 1, 1). Accessing an array anchor of a non-array object is an error",
        "examples": "local ref = object.create(\"ref\") local array = cell:add_child_array(ref, \"refarray\", 20, 2, 100, 1000) local anchor = array:get_array_area_anchor(4, 1, \"sourcedrain1bl\")",
    },
    {
        "module": "object",
        "funcname": "get_boundary",
        "syntax": "get_boundary(cell)",
        "description": "Retrieve the boundary of an object. If no explicit boundary exists, it is calculated from the extrem coordinates of all shapes (bounding box). The boundary is returned as a table containing the points. A boundary is not necessarily rectangular, but automatically-calculated boundaries are. In any case, the boundary is returned as a polygon, even if it is rectangular. This can be converted into a rectangular representation by util.polygon_rectangular_boundary(boundary).",
        "examples": "local boundary = cell:get_boundary() -- get min/max points: local bl, tr = util.polygon_rectangular_boundary(boundary)",
    },
    {
        "module": "object",
        "funcname": "get_bounding_box",
        "syntax": "get_bounding_box(cell)",
        "description": "Retrieve the rectangular bounding box of an object. This is different from object.get_boundary as it is always the true computed bounding box (the possibly present object boundary is not used) and the result is returned as a table describing a rectangle (with 'bl' and 'tr' entries).",
        "examples": "local boundary = cell:get_bounding_box()",
    },
    {
        "module": "object",
        "funcname": "get_layer_boundary",
        "syntax": "get_layer_boundary(cell, layer)",
        "description": "Retrieve the layer boundary of an object. If the cell has no layer boundaries at all, an empty table is returned. Otherwise, if the layer boundary for the specified layer does not exist, the bounding box of the cell is returned. If the layer boundary exists, it is returned. For this case, object.set_empty_layer_boundary() is useful.",
        "examples": "local layerboundary = cell:get_layer_boundary(generics.metal(1))",
    },
    {
        "module": "object",
        "funcname": "get_layer_occupation",
        "syntax": "get_layer_occupation(cell, layer)",
        "description": "Retrieve the extreme points of the overall layer occupation (including the sub-cells) of the given cell. This function returns a table with a bottom-left ('bl') and a top-right ('tr') point. This function does not depend on any existing layer boundaries, it always computes to real occupation. This might or might not be desirable, if precise control over the layer occupation is required it is recommended to use layer boundaries. This function is potentially slow, as it traverses the entire cell hierarchy and compares every shape layer to the given layer. If no layer is given, this function returns the bounding box.",
        "examples": "local occupation = cell:get_layer_occupation(generics.metal(1)) layouthelpers.place_guardring(cell, occupation.bl, occupation.tr (...))",
    },
    {
        "module": "object",
        "funcname": "get_shape_outlines",
        "syntax": "get_shape_outlines(cell, layers)",
        "description": "return a table which contains polygon outlines of all shapes on a given layer or layers. Useful for instance for automatic filling. The given layer can be a singular generics layer or a table with several layers.",
        "examples": "local outlines = cell:get_shape_outlines() local m1outlines = cell:get_shape_outlines(generics.metal(1)) local all_metal_outlines = cell:get_shape_outlines(util.foreach(util.range(1, technology.resolve_metal(-1)), generics.metal))",
    },
    {
        "module": "object",
        "funcname": "add_net_shape",
        "syntax": "add_net_shape(cell, netname, bl, tr, layer)",
        "description": "mark a rectangular area in a cell with a certain net. This can be used for automatic via placement from power grids, for instance.",
        "examples": "cell:add_net_shape(\"vdd\", cell:get_area_anchor(\"sourcestrap\").bl, cell:get_area_anchor(\"sourcestrap\").tr, generics.metal(2))",
    },
    {
        "module": "object",
        "funcname": "mark_area_anchor_as_net",
        "syntax": "mark_area_anchor_as_net(cell, anchor, netname, layer)",
        "description": "mark an area anchor in a cell with a certain net. This can be used for automatic via placement from power grids, for instance. This function is similar to add_net_shape, but simpler (and less flexible) to use.",
        "examples": "cell:mark_area_anchor_as_net(\"sourcestrap\", \"vdd\", generics.metal(2))",
    },
    {
        "module": "object",
        "funcname": "get_net_shapes",
        "syntax": "get_net_shapes(cell, netname, layer)",
        "description": "return a table which contains rectangular netshape entries of all shapes on a given net. Useful for instance for automatic placement of via from a power grid. The structure of the table entries in the results table are: { net = <netname>, bl = <bl>, tr = <tr> }. If the 'layer' parameter is non-nil, only shapes on the given layer are returned.",
        "examples": "cell:get_net_shapes(\"vdd\") cell:get_net_shapes(\"vss\", generics.metal(4))",
    },
    {
        "module": "object",
        "funcname": "get_array_net_shapes",
        "syntax": "get_array_net_shapes(cell, xindex, yindex, netname, layer)",
        "description": "return a table which contains rectangular netshape entries of all shapes on a given net. Useful for instance for automatic placement of via from a power grid. The structure of the table entries in the results table are: { net = <netname>, bl = <bl>, tr = <tr> }. If the 'layer' parameter is non-nil, only shapes on the given layer are returned. This function retrieves the netshape of a specific instance of a child array.",
        "examples": "cell:get_net_shapes(\"vdd\") cell:get_net_shapes(\"vss\", generics.metal(4))",
    },
    {
        "module": "object",
        "funcname": "get_ports",
        "syntax": "get_ports(cell)",
        "description": "return a table which contains key-value pairs with all ports of a cell. The key is the portname, the value the corresponding point.",
        "examples": "local ports = cell:get_ports()",
    },
    {
        "module": "object",
        "funcname": "has_boundary",
        "syntax": "has_boundary(cell)",
        "description": "check if the object has a boundary",
        "examples": "cell:has_boundary()",
    },
    {
        "module": "object",
        "funcname": "has_layer_boundary",
        "syntax": "has_layer_boundary(cell, layer)",
        "description": "check if the object has a layer boundary for the specified layer",
        "examples": "cell:has_layer_boundary(generics.metal(1))",
    },
    {
        "module": "object",
        "funcname": "inherit_alignment_box",
        "syntax": "inherit_alignment_box(cell, othercell)",
        "description": "inherit the alignment box from another cell. This EXPANDS the current alignment box, if any is present. This means that this function can be called multiple times with different objects to establish an overall alignment box",
        "examples": "cell:inherit_alignment_box(someothercell) cell:inherit_alignment_box(anothercell)",
    },
    {
        "module": "object",
        "funcname": "inherit_all_anchors_with_prefix",
        "syntax": "inherit_all_anchors_with_prefix(cell, othercell, prefix)",
        "description": "inherit all anchors from another cell with an attached prefix.",
        "examples": "cell:inherit_all_anchors_with_prefix(someothercell, \"othercell_\")",
    },
    {
        "module": "object",
        "funcname": "inherit_anchor_as",
        "syntax": "inherit_anchor_as(cell, othercell, anchorname, newname)",
        "description": "inherit an anchor from another cell under a different name.",
        "examples": "cell:inherit_anchor(someothercell, \"anchor\", \"newname\")",
    },
    {
        "module": "object",
        "funcname": "inherit_anchor",
        "syntax": "inherit_anchor(cell, othercell, anchorname)",
        "description": "inherit an anchor from another cell.",
        "examples": "cell:inherit_anchor(someothercell, \"anchor\")",
    },
    {
        "module": "object",
        "funcname": "inherit_area_anchor_as",
        "syntax": "inherit_area_anchor_as(cell, othercell, anchorname, newname)",
        "description": "inherit an area anchor from another cell under a different name.",
        "examples": "cell:inherit_area_anchor(someothercell, \"anchor\", \"newname\")",
    },
    {
        "module": "object",
        "funcname": "inherit_area_anchor",
        "syntax": "inherit_area_anchor(cell, othercell, anchorname)",
        "description": "inherit an area anchor from another cell.",
        "examples": "cell:inherit_area_anchor(someothercell, \"anchor\")",
    },
    {
        "module": "object",
        "funcname": "inherit_all_anchors",
        "syntax": "inherit_all_anchors(cell, othercell, anchorname)",
        "description": "inherit all anchors (regular and area) from another cell.",
        "examples": "cell:inherit_all_anchors(someothercell)",
    },
    {
        "module": "object",
        "funcname": "inherit_boundary",
        "syntax": "inherit_boundary(cell, othercell)",
        "description": "inherit the boundary from another cell.",
        "examples": "cell:inherit_boundary(someothercell)",
    },
    {
        "module": "object",
        "funcname": "inherit_layer_boundary",
        "syntax": "inherit_layer_boundary(cell, othercell, layer)",
        "description": "inherit all layer boundaries from another cell for the given layer.",
        "examples": "cell:inherit_layer_boundary(someothercell, generics.metal(1))",
    },
    {
        "module": "object",
        "funcname": "merge_into",
        "syntax": "merge_into(cell, othercell)",
        "description": "add all shapes and children from othercell to the cell -> 'dissolve' othercell in cell",
        "examples": "cell:merge_into(othercell) cell:merge_into(othercell:flatten())",
    },
    {
        "module": "object",
        "funcname": "merge_into_with_ports",
        "syntax": "merge_into_with_ports(cell, othercell)",
        "description": "add all shapes, children and ports from othercell to the cell -> 'dissolve' othercell in cell",
        "examples": "cell:merge_into_with_ports(othercell)",
    },
    {
        "module": "object",
        "funcname": "mirror_at_origin",
        "syntax": "mirror_at_origin(cell)",
        "description": "mirror the entire object at the origin",
        "examples": "cell:mirror_at_origin()",
    },
    {
        "module": "object",
        "funcname": "mirror_at_xaxis",
        "syntax": "mirror_at_xaxis(cell)",
        "description": "mirror the entire object at the x axis",
        "examples": "cell:mirror_at_xaxis()",
    },
    {
        "module": "object",
        "funcname": "mirror_at_yaxis",
        "syntax": "mirror_at_yaxis(cell)",
        "description": "mirror the entire object at the y axis",
        "examples": "cell:mirror_at_yaxis()",
    },
    {
        "module": "object",
        "funcname": "move_point",
        "syntax": "move_point(cell, source, target)",
        "description": "translate (move) the object so that the source point lies on the target. Usually the source point is an anchor of the object, but that is not a necessity. The points are just references for the delta vector and can be any points.",
        "examples": "cell:move_point(cell:get_area_anchor(\"gate\").bl, point.create(0, 0)) -- move to origin mosfet:move_point(mosfet:get_area_anchor(\"leftsourcedrain\").bl, othermosfet:get_area_anchor(\"rightsourcedrain\").bl) -- align two mosfets",
    },
    {
        "module": "object",
        "funcname": "move_point_x",
        "syntax": "move_point_x(cell, source, target)",
        "description": "translate (move) the object so that the x-coorindate of the source point lies on the x-coordinate target. Usually the source point is an anchor of the object, but that is not a necessity. The points are just references for the delta vector and can be any points.",
        "examples": "cell:move_point_x(cell:get_area_anchor(\"gate\").bl, point.create(0, 0)) -- move the x-coordinate of the origin mosfet:move_point_x(mosfet:get_area_anchor(\"leftsourcedrain\").bl, othermosfet:get_area_anchor(\"rightsourcedrain\").bl) -- align the x-coordinate of two mosfets",
    },
    {
        "module": "object",
        "funcname": "move_point_y",
        "syntax": "move_point_y(cell, source, target)",
        "description": "translate (move) the object so that the y-coorindate of the source point lies on the y-coordinate target. Usually the source point is an anchor of the object)",
        "examples": "cell:move_point_y(cell:get_area_anchor(\"gate\").bl, point.create(0, 0)) -- move the y-coordinate of the origin mosfet:move_point_y(mosfet:get_area_anchor(\"leftsourcedrain\").bl, othermosfet:get_area_anchor(\"rightsourcedrain\").bl) -- align the y-coordinate of two mosfets",
    },
    {
        "module": "object",
        "funcname": "center",
        "syntax": "center(cell, source)",
        "description": "translate (move) the object so that the cell center lies on the target (default: (0, 0)). The alignment box is used for calculating the center of the cell, if not available the bounding box is used.",
        "examples": "cell:move_point(cell:get_area_anchor(\"gate\").bl, point.create(0, 0)) -- move to origin mosfet:move_point(mosfet:get_area_anchor(\"leftsourcedrain\").bl, othermosfet:get_area_anchor(\"rightsourcedrain\").bl) -- align two mosfets",
    },
    {
        "module": "object",
        "funcname": "center_x",
        "syntax": "center_x(cell, source)",
        "description": "translate (move) the object so that the cell center lies on the target (default: (0, 0)), but only move in x-direction. The alignment box is used for calculating the center of the cell, if not available the bounding box is used.",
        "examples": "cell:move_point(cell:get_area_anchor(\"gate\").bl, point.create(0, 0)) -- move to origin mosfet:move_point(mosfet:get_area_anchor(\"leftsourcedrain\").bl, othermosfet:get_area_anchor(\"rightsourcedrain\").bl) -- align two mosfets",
    },
    {
        "module": "object",
        "funcname": "center_y",
        "syntax": "center_y(cell, source)",
        "description": "translate (move) the object so that the cell center lies on the target (default: (0, 0)), but only move in y-direction. The alignment box is used for calculating the center of the cell, if not available the bounding box is used.",
        "examples": "cell:move_point(cell:get_area_anchor(\"gate\").bl, point.create(0, 0)) -- move to origin mosfet:move_point(mosfet:get_area_anchor(\"leftsourcedrain\").bl, othermosfet:get_area_anchor(\"rightsourcedrain\").bl) -- align two mosfets",
    },
    {
        "module": "object",
        "funcname": "add_child",
        "syntax": "add_child(cell, child, instname)",
        "description": "Add a child object (instance) to the given cell. This make 'cell' the parent of the child (it manages its memory). This means that you should not use the original child object any more after this call (unless it is object.add_child or object.add_child_array)",
        "examples": "local ref = pcell.create_layout(\"basic/mosfet\", \"mosfet\") cell:add_child(ref, \"mosinst0\")",
    },
    {
        "module": "object",
        "funcname": "move_to",
        "syntax": "move_to(cell, x, y)",
        "description": "move the cell to the specified coordinates (absolute movement). If x is a point, x and y are taken from this point",
        "examples": "cell:move_to(100, 200)",
    },
    {
        "module": "object",
        "funcname": "set_origin",
        "syntax": "set_origin(cell, x, y)",
        "description": "Sets the origin of the cell to the given position. This is an absolute movement.",
        "examples": "cell:set_origin(100, 200)",
    },
    {
        "module": "object",
        "funcname": "move_x",
        "syntax": "move_x(cell, xsource, xtarget)",
        "description": "move the cell so that the given x-coordinates are equal (move the difference between these coordinates)",
        "examples": "cell:move_x(cell:get_area_anchor(\"someanchor\").l, 0)",
    },
    {
        "module": "object",
        "funcname": "move_y",
        "syntax": "move_y(cell, ysource, ytarget)",
        "description": "move the cell so that the given y-coordinates are equal (move the difference between these coordinates)",
        "examples": "cell:move_y(cell:get_area_anchor(\"someanchor\").l, 0)",
    },
    {
        "module": "object",
        "funcname": "rasterize_curves",
        "syntax": "rasterize_curves(cell)",
        "description": "rasterize all curves in the object. This is usually not needed, as this happens during the cell export, if required. This function is useful if this should be done regardless of the export capabilities, but then there also is the geometry function geomtry.curve_rasterized",
        "examples": "cell:rasterize_curves()",
    },
    {
        "module": "object",
        "funcname": "reset_translation",
        "syntax": "reset_translation(cell)",
        "description": "reset all previous translations (transformations are kept)",
        "examples": "cell:reset_translation()",
    },
    {
        "module": "object",
        "funcname": "rotate_90_left",
        "syntax": "rotate_90_left(cell)",
        "description": "rotate the entire object 90 degrees counter-clockwise with respect to the origin",
        "examples": "cell:rotate_90_left()",
    },
    {
        "module": "object",
        "funcname": "rotate_90_right",
        "syntax": "rotate_90_right(cell)",
        "description": "rotate the entire object 90 degrees clockwise with respect to the origin",
        "examples": "cell:rotate_90_right()",
    },
    {
        "module": "object",
        "funcname": "array_rotate_90_left",
        "syntax": "array_rotate_90_left(cell)",
        "description": "rotate the entire object array 90 degrees counter-clockwise with respect to the origin",
        "examples": "cell:array_rotate_90_left()",
    },
    {
        "module": "object",
        "funcname": "array_rotate_90_right",
        "syntax": "array_rotate_90_right(cell)",
        "description": "rotate the entire object array 90 degrees clockwise with respect to the origin",
        "examples": "cell:array_rotate_90_right()",
    },
    {
        "module": "object",
        "funcname": "set_alignment_box",
        "syntax": "set_alignment_box(cell, outerbl, outertr, innerbl, innertr)",
        "description": "set the alignment box of an object. Overwrites any previous existing alignment boxes. This function can either be called with three or five arguments. In the first case the alignment box is determined by only two corner points. With four corner points, a more sophisticated alignment box is established, which allows the alignment of cells with odd dimensions. Often this is not needed. The more advanced library cells use this mode, but 2 points suffice in many cases.",
        "examples": "cell:set_alignment_box(point.create(-100, -100), point.create(100, 100))",
    },
    {
        "module": "object",
        "funcname": "set_boundary_rectangular",
        "syntax": "set_boundary_rectangular(cell, pts)",
        "description": "set the cell boundary (rectangular)",
        "examples": "cell:set_boundary_rectangular(point.create(-100, -100), point.create(100, 100))",
    },
    {
        "module": "object",
        "funcname": "set_boundary",
        "syntax": "set_boundary(cell, pts)",
        "description": "set the cell boundary (polygon)",
        "examples": "cell:set_boundary({ point.create(-100, -100), point.create(100, -100), point.create(100, 100), point.create(-100, 100) })",
    },
    {
        "module": "object",
        "funcname": "set_empty_layer_boundary",
        "syntax": "set_empty_layer_boundary(cell, layer)",
        "description": "Set the layer boundary of this object for the specified layer to empty. A layer boundary is useful for automatic filling, an empty layer boundary indicates that filling can take place everywhere. This function is required if fill is to be placed within the regular boundary of the object, because the regular boundary is used as layer boundary if the latter is not present.",
        "examples": "cell:set_empty_layer_boundary(generics.metal(1))",
    },
    {
        "module": "object",
        "funcname": "translate",
        "syntax": "translate(cell, x, y)",
        "description": "translate the cell by the specified offsets (relative movement). If x is a point, x and y are taken from this point",
        "examples": "cell:translate(100, 200)",
    },
    {
        "module": "object",
        "funcname": "translate_x",
        "syntax": "translate_x(cell, x)",
        "description": "translate the cell by the specified x offset (relative movement).",
        "examples": "cell:translate_x(100)",
    },
    {
        "module": "object",
        "funcname": "translate_y",
        "syntax": "translate_y(cell, y)",
        "description": "translate the cell by the specified y offset (relative movement).",
        "examples": "cell:translate_y(100)",
    },
    {
        "module": "object",
        "funcname": "width_height_alignmentbox",
        "syntax": "width_height_alignmentbox(cell)",
        "description": "get the width and the height of the alignment box. A non-existing alignment box triggers an error",
        "examples": "local width, height = cell:width_height_alignmentbox()",
    },
    {
        "module": "object",
        "funcname": "get_name",
        "syntax": "get_name(cell)",
        "description": "return the name of the given object",
        "examples": "local name = cell:get_name()",
    },
    {
        "module": "object",
        "funcname": "set_name",
        "syntax": "set_name(cell, name)",
        "description": "set the name of the given object",
        "examples": "cell:set_name(\"newname\")",
    },
    {
        "module": "object",
        "funcname": "is_object",
        "syntax": "is_object(cell)",
        "description": "check that a given parameter is an object (with the metatable forn objects). Useful for overloaded functions",
        "examples": "if object.is_object(cell) then     -- actions for object else    -- actions for other types end",
    },
    {
        "module": "object",
        "funcname": "has_layer",
        "syntax": "has_layer(cell, layer)",
        "description": "check whether an object contains a given layer. This function is recursive and checks all hierarchy levels of the cell",
        "examples": "if cell:has_layer(generics.metal(1)) then ...",
    },
    {
        "module": "pcell",
        "funcname": "set_property",
        "syntax": "set_property(property, value)",
        "description": "set a property of a pcell. Not many properties are supported currently, so this function is very rarely used. The base cell of the standard cell library uses it to be hidden, but that's the only current use",
        "examples": "function config()     pcell.set_property(\"hidden\", true) end",
    },
    {
        "module": "pcell",
        "funcname": "add_parameter",
        "syntax": "add_parameter(name, defaultvalue, opt)",
        "description": "add a parameter to a pcell definition. Must be called in parameters(). The parameter options table can contain the following fields: 'argtype': (type of the parameter, usually deduced from the default value), 'posvals': possible parameter values, see functions 'even', 'odd', 'interval', 'positive', 'negative' and 'set'; 'follow': copy the values from the followed parameter to this one if not explicitly specified and if the followed parameter was given explicitly; 'readonly': make parameter readonly",
        "examples": "function parameters()     pcell.add_parameter(\"fingers\", 2, { posvals = even() }) end",
    },
    {
        "module": "pcell",
        "funcname": "add_parameters",
        "syntax": "add_parameters(args)",
        "description": "add multiple parameters to a cell. Internally, this calls pcell.add_parameter, so this function is merely a shorthand for multiple calls to pcell.parameter. Hint for the usage: in lua tables, a trailing comma after the last entry is explicitely allowed. However, this is a variable number of arguments for a function call, where the list has to be well-defined. A common error is a trailing comma after the last entry",
        "examples": "function parameters()     pcell.add_parameters(         { \"fingers\",     2,      posvals = even()              },         { \"fingerwidth\", 100,    posvals = positive()          },         { \"channeltype\", \"nmos\", posvals = set(\"nmos\", \"pmos\") } -- <--- no comma!     ) end",
    },
    {
        "module": "pcell",
        "funcname": "check_expression",
        "syntax": "check_expression(expression, message)",
        "description": "check valid parameter values with expressions. If parameter values depend on some other parameter or the posval function of parameter definitions do not offer enough flexibility, parameters can be checked with arbitrary lua expressions. This function must be called in parameters()",
        "examples": "function parameters()     pcell.add_parameters({         { \"width\", 100 },         { \"height\", 200 },     })     pcell.check_expression(\"(height / width) % 2 == 0\", \"quotionent of height and width must be even\") end",
    },
    {
        "module": "pcell",
        "funcname": "add_area_anchor_documentation",
        "syntax": "add_area_anchor_documentation(name, description, condition)",
        "description": "add documentation of an area anchor of a pcell. This function is called in the 'anchor' function of a pcell definition. The anchors defined here are available via 'opc --anchors'.",
        "examples": "pcell.add_area_anchor_documentation(     \"someanchor\",     \"anchor of some region\",     \"someflag == true\" )",
    },
    {
        "module": "pcell",
        "funcname": "create_layout",
        "syntax": "create_layout(cellname, objectname, parameters)",
        "description": "Create a layout based on a parametric cell",
        "examples": "pcell.create_layout(\"stdcells/not_gate\", \"not_gate\", { pwidth = 600 })",
    },
    {
        "module": "pcell",
        "funcname": "create_layout_env",
        "syntax": "create_layout_env(cellname, objectname, parameters, environment)",
        "description": "Create a layout based on a parametric cell with a given cell environment",
        "examples": "pcell.create_layout_env(\"libname/cellname\", \"toplevel\", args, env)",
    },
    {
        "module": "pcell",
        "funcname": "create_layout_in_object",
        "syntax": "create_layout_in_object(cell, cellname, parameters)",
        "description": "Create a layout based on a parametric cell in an existing cell. This function does NOT return a new object but places everything from the pcell in the given object (first argument)",
        "examples": "pcell.create_layout_in_object(cell, \"libname/cellname\", args)",
    },
    {
        "module": "pcell",
        "funcname": "create_layout_env_in_object",
        "syntax": "create_layout_env_in_object(cell, cellname, parameters, environment)",
        "description": "Create a layout based on a parametric cell with a given cell environment in an existing cell. This function does NOT return a new object but places everything from the pcell in the given object (first argument)",
        "examples": "pcell.create_layout_env_in_object(cell, \"libname/cellname\", args, env)",
    },
    {
        "module": "placement",
        "funcname": "create_floorplan_aspectratio",
        "syntax": "create_floorplan_aspectratio(instances, utilization, aspectration)",
        "description": "create a floorplan configuration based on utilization and an aspectratio. The 'instances' table is the result of parsing and processing verilog netlists. This function is intended to be called in a place-and-route-script for --import-verilog",
        "examples": "local floorplan = placement.create_floorplan_aspectratio(instances, 0.8, 2 / 1)",
    },
    {
        "module": "placement",
        "funcname": "create_floorplan_fixed_rows",
        "syntax": "create_floorplan_fixed_rows(instances, utilization, rows)",
        "description": "create a floorplan configuration based on utilization and a fixed number of rows. The 'instances' table is the result of parsing and processing verilog netlists. This function is intended to be called in a place-and-route-script for --import-verilog",
        "examples": "local floorplan = placement.create_floorplan_fixed_rows(instances, 0.8, 20)",
    },
    {
        "module": "placement",
        "funcname": "optimize",
        "syntax": "optimize(instances, nets, floorplan)",
        "description": "minimize wire length by optimizing the placement of the instances by a simulated annealing algorithm. This function returns a table with the rows and columns of the placement of the instances. It is intended to be called in a place-and-route-script for --import-verilog",
        "examples": "local rows = placement.optimize(instances, nets, floorplan)",
    },
    {
        "module": "placement",
        "funcname": "manual",
        "syntax": "manual(instances, plan)",
        "description": "create a placement of instances manually. This function expects a row-column table with all instance names. Thus the instance names must match the ones found in the instances table (from the verilog netlist). This function then updates all required references in the row-column table, that are needed for further processing (e.g. routing). This function is useful for small designs, especially in a hierarchical flow",
        "examples": "local plan = {     { \"inv\", \"nand1\", \"dff_out\" },     { \"nand2\", \"dff_buf\" },     { \"nand3\", \"dff_in\" }, } local rows = placement.manual(instances, plan) ",
    },
    {
        "module": "placement",
        "funcname": "insert_filler_names",
        "syntax": "insert_filler_names(rows, width)",
        "description": "equalize placement rows by inserting fillers in every row.The method tries to equalize spacing between cells.This function is intended to be called in a place-and-route-script for --import-verilog",
        "examples": "placement.insert_filler_names(rows, 200)",
    },
    {
        "module": "placement",
        "funcname": "create_reference_rows",
        "syntax": "create_reference_rows(cellnames, xpitch)",
        "description": "prepare a row placement table for further placement functions by parsing a definition given in 'cellnames'.This table contains the individual rows of the placment, which every row consiting of individual cells.Cell entries can either be given by just the name of the standard cell (the 'reference') or the instance name ('instance') and the reference name ('reference')This function is meant to be used in pcell definitions",
        "examples": "-- un-named mode: local rows = placement.create_reference_rows({     { \"inv\", \"nand1\", \"dff_out\" },     { \"nand2\", \"dff_buf\" },     { \"nand3\", \"dff_in\" }, })  -- named mode: local rows = placement.create_reference_rows({     { { name = \"inv0\", reference = \"not_gate\" }, { name = \"nand1\", reference = \"nand_gate\" }, { name = \"dff_out\", reference = \"dffpq\" } },     { { name = \"nand2\", reference = \"nand_gate\" }, { name = \"dff_buf\", reference = \"dffpq\" } },     { { name = \"nand3\", reference = \"nand_gate\" }, { name = \"dff_in\", reference = \"dffpq\" } }, })",
    },
    {
        "module": "placement",
        "funcname": "digital",
        "syntax": "digital()",
        "description": "",
        "examples": "",
    },
    {
        "module": "placement",
        "funcname": "rowwise",
        "syntax": "rowwise(parent, cellsdef, flip, flipfirst)",
        "description": "place cells in a row-wise manner in a parent cell. The cells definition contains definitions for every row, which in turn contain entries with two keys: 'reference' (an object) and 'instance' (an instance name). The placed cells are aligned by their alignment boxes and grow into the upper-right direction. This means that the first entry in the first row is the bottom-left-most cell. This function is useful for digital standard cell layouts (and in fact called by placement.digital, which offers a more high-level interface), but it can also be useful for regular analog structures. Flipping fine control can be obtained by passing 'flip = true/false' to entire rows or individually per cell entry with 'flipx' and 'flipy' (boolean switches).",
        "examples": "local celldef = {     { -- first row (bottom)         { reference = someobject, instance = \"instance_1_1\" },         { reference = someobject, instance = \"instance_1_2\" },     },     { -- second row         { reference = someotherobject, instance = \"instance_2_1\" },         { reference = someotherobject, instance = \"instance_2_2\" },     } } placement.rowwise(parent, cellsdef)",
    },
    {
        "module": "placement",
        "funcname": "rowwise_flat",
        "syntax": "rowwise_flat(parent, cellsdef, flip, flipfirst)",
        "description": "like placement.rowwise, but merges cells into parents (flat)",
        "examples": "local celldef = {     { -- first row (bottom)         { reference = someobject, instance = \"instance_1_1\" },         { reference = someobject, instance = \"instance_1_2\" },     },     { -- second row         { reference = someotherobject, instance = \"instance_2_1\" },         { reference = someotherobject, instance = \"instance_2_2\" },     } } placement.rowwise_flat(parent, cellsdef)",
    },
    {
        "module": "placement",
        "funcname": "columnwise",
        "syntax": "columnwise(parent, cellsdef, flip, flipfirst)",
        "description": "place cells in a column-wise manner in a parent cell. The cells definition contains definitions for every column, which in turn contain entries with two keys: 'reference' (an object) and 'instance' (an instance name). The placed cells are aligned by their alignment boxes and grow into the upper-right direction. This means that the first entry in the first column is the bottom-left-most cell. This function is useful for digital standard cell layouts (and in fact called by placement.digital, which offers a more high-level interface), but it can also be useful for regular analog structures. Flipping fine control can be obtained by passing 'flip = true/false' to entire columns or individually per cell entry with 'flipx' and 'flipy' (boolean switches).",
        "examples": "local celldef = {     { -- first column (bottom)         { reference = someobject, instance = \"instance_1_1\" },         { reference = someobject, instance = \"instance_1_2\" },     },     { -- second column         { reference = someotherobject, instance = \"instance_2_1\" },         { reference = someotherobject, instance = \"instance_2_2\" },     } } placement.columnwise(parent, cellsdef)",
    },
    {
        "module": "placement",
        "funcname": "columnwise_flat",
        "syntax": "columnwise_flat(parent, cellsdef, flip, flipfirst)",
        "description": "like placement.columnwise, but merges cells into parents (flat)",
        "examples": "local celldef = {     { -- first column (bottom)         { reference = someobject, instance = \"instance_1_1\" },         { reference = someobject, instance = \"instance_1_2\" },     },     { -- second column         { reference = someotherobject, instance = \"instance_2_1\" },         { reference = someotherobject, instance = \"instance_2_2\" },     } } placement.columnwise_flat(parent, cellsdef)",
    },
    {
        "module": "placement",
        "funcname": "place_at_origins",
        "syntax": "place_at_origins(toplevel, cell, basename, origins)",
        "description": "place cells in a toplevel cells at the specified origins. The instances are named accordingly to the basename (with _1, _2, etc. appended). This is a more low-level placement function (compared to placement.place_within_boundary), which is called by the higher-level functions. In some cases, using this function directly can be useful. The function returns all placed children in a table.",
        "examples": "local origins = {     point.create(0, -10000),     point.create(0, 10000),     point.create(0, 20000),     point.create(0, 30000) } placement.place_at_origins(toplevel, filler, \"fill\", origins)",
    },
    {
        "module": "placement",
        "funcname": "place_on_grid",
        "syntax": "place_on_grid(toplevel, cell, basename, basept, xpitch, ypitch, grid)",
        "description": "place cells in a toplevel cells corresponding to the given grid. The instances are named accordingly to the basename (with _1, _2, etc. appended). This function is a convenient low-level wrapper for placement.place_at_origins, where the individual points don't have to be typed out. The function returns all placed children in a table.",
        "examples": "local grid = {     { 0, 1, 1 }     { 1, 1, 1 },     { 0, 0, 1 }, } placement.place_on_grid(toplevel, cell, \"cell\", point.create(0, 0), 100, 100, grid)",
    },
    {
        "module": "placement",
        "funcname": "place_within_boundary",
        "syntax": "place_within_boundary(toplevel, cell, basename, targetarea, excludes)",
        "description": "automatically place a cell multiple times in a toplevel cell. The cell instances will be placed in the given target area and given names based on the given basename. An optional table can hold list of points (polygons), which describe areas that should not be filled. The x- and y-pitch of the cell are inferred from the alignment box. The function returns all placed children in a table.",
        "examples": "local targetarea = {     point.create(-10000, -10000),     point.create(10000, -10000),     point.create(10000, 10000),     point.create(-10000, 10000) } local excludes = { {     point.create(-2000, -2000),     point.create(2000, -2000),     point.create(2000, 2000),     point.create(-2000, 2000) }, -- possibly more exludes after this } placement.place_within_boundary(toplevel, filler, \"fill\", targetarea, excludes)",
    },
    {
        "module": "placement",
        "funcname": "place_within_boundary_merge",
        "syntax": "place_within_boundary_merge(toplevel, cell, targetarea, excludes)",
        "description": "same as placement.place_within_boundary, but merges the cells (instead of adding them as children). Since only children need instance names, the 'basename' parameter is not present for this function",
        "examples": "local targetarea = {     point.create(-10000, -10000),     point.create(10000, -10000),     point.create(10000, 10000),     point.create(-10000, 10000) } local excludes = { {     point.create(-2000, -2000),     point.create(2000, -2000),     point.create(2000, 2000),     point.create(-2000, 2000) }, -- possibly more exludes after this } placement.place_within_boundary_merge(toplevel, filler, targetarea, excludes)",
    },
    {
        "module": "placement",
        "funcname": "place_within_rectangular_boundary",
        "syntax": "place_within_rectangular_boundary(toplevel, cell, basename, targetbl, targettr)",
        "description": "place fill in a rectangular boundary. This function behaves like placement.place_within_boundary, but it takes the corner points (bottom-left and top-right) as inputs. Furthermore, no excludes are accepted. This means that the entire rectangular boundary is filled. This function is magnitudes faster than placement.place_within_boundary (as no point-in-polygon checks are required and a more efficient data representation for the resulting array can be used), so consider using this function if no excludes are required.",
        "examples": "local targetbl = point.create(-10000, -10000) local targettr = point.create(10000, 10000) placement.place_within_rectangular_boundary(toplevel, filler, \"fill\", targetbl, targettr)",
    },
    {
        "module": "placement",
        "funcname": "place_within_layer_boundaries",
        "syntax": "place_within_layer_boundaries(toplevel, celllookup, basename, targetarea, xpitch, ypitch, layerexcludes, ignorelayer)",
        "description": "place cells in a boundary based on their layer content. This function is similar to placement.place_within_boundary, but uses non-binary excludes. A look-up table with cells is given, that defines the occupied layers of these cells and places only cells that don't have content in the excluded layers. The layerexcludes table contains the excludes in the respective layers. This function tries to maximize the number of placed cells, starting for every point with the first cell. After a cell is placed, its layers are used to block that region. That means that if cells exist with non-overlapping layer content, it is possible that multiple cells are placed per grid point. Therefore the order of the cells matters (first come, first serve). The sixth (optional) argument of this function is a singular generic layer that will be ignored when building the new excludes for subsequent cells. The reasoning behind is that if a certain layer is used as a marking layer as a full block, then all the cells in the cell lookup also need to contain this layer, which then in turn blocks the subsequent placing of further cells.",
        "examples": "local celllut = {     {         cell = object1,         layers = {             generics.metal(1),             generics.metal(2),             generics.metal(3),             generics.metal(4),         },     },     {         cell = object2,         layers = {             generics.metal(1),             generics.metal(2),         },     },     {         cell = object2,         layers = {             generics.other(\"active\"),         },     }, } local target = {     point.create(-10000, -10000),     point.create( 10000, -10000),     point.create( 10000,  10000),     point.create(-10000,  10000), } local excludes = {     {         excludes = { -- multiple polygons are possible             {                 point.create(-5000, -5000),                 point.create( 5000, -5000),                 point.create( 5000,  5000),                 point.create(-5000,  5000),             },             layers = {                 generics.metal(1),                 generics.metal(2),             },         },     }     {         excludes = { -- multiple polygons are possible             {                 point.create( 2000,  1000),                 point.create( 4000,  1000),                 point.create( 4000,  8000),                 point.create( 2000,  8000),             },             layers = {                 generics.other(\"active\"),             },         },     } } placement.place_within_layer_boundaries(toplevel, celllookup, \"fill\", targetarea, 1000, 1000, excludes)",
    },
    {
        "module": "placement",
        "funcname": "calculate_grid",
        "syntax": "calculate_grid(bl, tr, pitch, excludes)",
        "description": "calculate a grid of cell origins in a rectangular target area with the given binary excludes (in or out). This function returns a table which can be used as input for placement.place_boundary_grid",
        "examples": "local excludes = { {     point.create(2000, 2000),     point.create(8000, 2000),     point.create(8000, 20000),     point.create(2000, 20000) }, } placement.calculate_grid(point.create(0, 0), point.create(100000, 100000), 10000, excludes)",
    },
    {
        "module": "placement",
        "funcname": "place_boundary_grid",
        "syntax": "place_boundary_grid(toplevel, boundarycells, basept, grid, pitch, basename)",
        "description": "place cells on a regular grid with the given pitch. The grid contains numeric entries of either 1 or 0, meaning 'place' or 'don't place'. This grid can be obtained by using placement.calculate_grid. The cells are placed on this grid, so that the proper cells are used at each of the grid points. This means that special cells are placed at the boundary of the grid (e.g., where there is no neighbouring cell to the left). The boundarycells table should contain sixteen (2^4) key-value pairs: cells for 'center', 'top', 'bottom', 'left', 'right', 'topleft', 'topright', 'topbottom', 'bottomleft', 'bottomright', 'leftright', 'topleftright', 'topbottomleft', 'topbottomright', 'bottomleftright' and 'topbottomleftright'",
        "examples": "local grid = { --[[ some grid definition --]] } local boundarycells = { center = centercell, top = topcell, --[[ and so on --]] }  placement.place_boundary_grid(toplevel, boundarycells, point.create(0, 0), grid, 10000, \"gridcell\")",
    },
    {
        "module": "point",
        "funcname": "create",
        "syntax": "create(x, y)",
        "description": "create a point from an x- and y-coordinate",
        "examples": "local pt = point.create(0, 0)",
    },
    {
        "module": "point",
        "funcname": "combine_12",
        "syntax": "combine_12(pt1, pt2)",
        "description": "create a new point by combining the coordinates of two other points. The new point is made up by x1 and y2",
        "examples": "local new = point.combine_12(pt1, pt2) -- equivalent to point.create(pt1:getx(), pt2:gety())",
    },
    {
        "module": "point",
        "funcname": "combine_21",
        "syntax": "combine_21(pt1, pt2)",
        "description": "create a new point by combining the coordinates of two other points. The new point is made up by x2 and y1. This function is equivalent to combine_12 with swapped arguments",
        "examples": "local new = point.combine_21(pt1, pt2) -- equivalent to point.create(pt2:getx(), pt1:gety())",
    },
    {
        "module": "point",
        "funcname": "combine",
        "syntax": "combine(pt1, pt2)",
        "description": "combine two points into a new one by taking the arithmetic average of their coordinates, that is x = 0.5 * (x1 + x2), y = 0.5 * (y1 + y2)",
        "examples": "local newpt = point.combine(pt1, pt2)",
    },
    {
        "module": "point",
        "funcname": "copy",
        "syntax": "copy(point)",
        "description": "copy a point. Can be used as module function or as a point method",
        "examples": "local newpt = point.copy(pt) local newpt = pt:copy()",
    },
    {
        "module": "point",
        "funcname": "getx",
        "syntax": "getx(point)",
        "description": "get the x-coordinate from a point. Can be used as module function or as a point method",
        "examples": "local x = point.getx(pt) local x = pt:getx()",
    },
    {
        "module": "point",
        "funcname": "gety",
        "syntax": "gety(point)",
        "description": "get the y-coordinate from a point. Can be used as module function or as a point method",
        "examples": "local y = point.gety(pt) local y = pt:gety()",
    },
    {
        "module": "point",
        "funcname": "translate",
        "syntax": "translate(point, x, y)",
        "description": "translate a point in x and y. Can be used as module function or as a point method",
        "examples": "point.translate(pt, 100, -20) pt:translate(100, -20)",
    },
    {
        "module": "point",
        "funcname": "translate_x",
        "syntax": "translate_x(point, x)",
        "description": "translate a point in x. Can be used as module function or as a point method",
        "examples": "point.translate(pt, 100) pt:translate(100)",
    },
    {
        "module": "point",
        "funcname": "translate_y",
        "syntax": "translate_y(point, y)",
        "description": "translate a point in y. Can be used as module function or as a point method",
        "examples": "point.translate(pt, 100) pt:translate(100)",
    },
    {
        "module": "point",
        "funcname": "xdistance",
        "syntax": "xdistance(pt1, pt2)",
        "description": "calculate the y-distance between two points, (the ordering of input parameters matters, it is pt1.x - pt2.x)",
        "examples": "local distance = point.xdistance(pt1, pt2)",
    },
    {
        "module": "point",
        "funcname": "xdistance_abs",
        "syntax": "xdistance_abs(pt1, pt2)",
        "description": "calculate the x-distance between two points, but return the absolute (regardless of the ordering of input parameters)",
        "examples": "local distance = point.xdistance_abs(pt1, pt2)",
    },
    {
        "module": "point",
        "funcname": "ydistance",
        "syntax": "ydistance(pt1, pt2)",
        "description": "calculate the y-distance between two points, (the ordering of input parameters matters, it is pt1.y - pt2.y)",
        "examples": "local distance = point.ydistance(pt1, pt2)",
    },
    {
        "module": "point",
        "funcname": "ydistance_abs",
        "syntax": "ydistance_abs(pt1, pt2)",
        "description": "calculate the y-distance between two points, but return the absolute (regardless of the ordering of input parameters)",
        "examples": "local distance = point.ydistance_abs(pt1, pt2)",
    },
    {
        "module": "point",
        "funcname": "xaverage",
        "syntax": "xaverage(point)",
        "description": "calculate the arithmetic average of the x-coordinates of two points",
        "examples": "local xmid = point.xaverage(pt1, pt2)",
    },
    {
        "module": "point",
        "funcname": "yaverage",
        "syntax": "yaverage(point)",
        "description": "calculate the arithmetic average of the y-coordinates of two points",
        "examples": "local ymid = point.yaverage(pt1, pt2)",
    },
    {
        "module": "point",
        "funcname": "fix",
        "syntax": "fix(pt, grid)",
        "description": "fix the x- and y-coordinate from a point on a certain grid, that is 120 would become 100 on a grid of 100. This function behaves like floor(), no rounding is done",
        "examples": "point.create(120, 80):fix(100) -- yields (100, 0)",
    },
    {
        "module": "point",
        "funcname": "operator+",
        "syntax": "operator+(pt1, pt2)",
        "description": "sum two points. This is the same as point.combine",
        "examples": "point.create(0, 0) + point.create(100, 0) -- yields (50, 0)",
    },
    {
        "module": "point",
        "funcname": "operator-",
        "syntax": "operator-(pt1, pt2)",
        "description": "create a new point representing the difference of two points",
        "examples": "point.create(0, 100) - point.create(50, 20) -- (-50, 80)",
    },
    {
        "module": "point",
        "funcname": "operator..",
        "syntax": "operator..(pt1, pt2)",
        "description": "combine two points into a new one. Takes the x-coordinate from the first point and the y-coordinate from the second one. Equivalent to point.combine_12(pt1, pt2)",
        "examples": "point.create(0, 100) .. point.create(100, 0) -- (0, 0)",
    },
    {
        "module": "point",
        "funcname": "xmirror",
        "syntax": "xmirror(point, reference)",
        "description": "return a copy of the given point with the x-coordinate mirrored. A reference coordinate can be given, to which the x-coordinate is mirrored. If this is not present, 0 is used.",
        "examples": "local newpt = pt:xmirror() local newpt2 = pt:xmirror(200)",
    },
    {
        "module": "point",
        "funcname": "ymirror",
        "syntax": "ymirror(point, reference)",
        "description": "return a copy of the given point with the y-coordinate mirrored. A reference coordinate can be given, to which the y-coordinate is mirrored. If this is not present, 0 is used.",
        "examples": "local newpt = pt:ymirror() local newpt2 = pt:ymirror(200)",
    },
    {
        "module": "point",
        "funcname": "unwrap",
        "syntax": "unwrap(point)",
        "description": "unwrap: get the x- and y-coordinate from a point. Can be used as module function or as a point method",
        "examples": "local x, y = point.unwrap(pt) local x, y = pt:unwrap()",
    },
    {
        "module": "point",
        "funcname": "is_point",
        "syntax": "is_point(pt)",
        "description": "check that a given parameter is a point (with the metatable for points). Useful for overloaded functions",
        "examples": "if point.is_point(pt) then     -- actions for points else    -- actions for (e.g.) numbers end",
    },
    {
        "module": "postprocess",
        "funcname": "remove_layer_shapes",
        "syntax": "remove_layer_shapes(cell, layer)",
        "description": "remove shapes on a given layer in a cell hierarchy. This function traverses through the cell hierarchy and removes shapes in every referenced cell.",
        "examples": "postprocess.remove_layer_shapes(cell, generics.metal(1))",
    },
    {
        "module": "postprocess",
        "funcname": "remove_layer_shapes_flat",
        "syntax": "remove_layer_shapes_flat(cell, layer)",
        "description": "remove shapes on a given layer in a cell. This function only and shapes in the given cell, without traversing through the cell hierarchy.",
        "examples": "postprocess.remove_layer_shapes_flat(cell, generics.metal(1))",
    },
    {
        "module": "routing",
        "funcname": "legalize",
        "syntax": "legalize()",
        "description": "",
        "examples": "",
    },
    {
        "module": "routing",
        "funcname": "route",
        "syntax": "route()",
        "description": "",
        "examples": "",
    },
    {
        "module": "technology",
        "funcname": "get_grid",
        "syntax": "get_grid()",
        "description": "Get the manufacturing grid of the process node (in nanometer)",
        "examples": "local grid = technology.get_grid()",
    },
    {
        "module": "technology",
        "funcname": "get_even_grid",
        "syntax": "get_even_grid()",
        "description": "Get the manufacturing grid of the process node (in nanometer). If the grid is not an even number, return the next even multiple of the grid (grid * 2). This function is useful when geometries that need to be on grid are calculated from given parameters and divided later on.",
        "examples": "local grid = technology.get_even_grid()",
    },
    {
        "module": "technology",
        "funcname": "get_dimension",
        "syntax": "get_dimension(properties...)",
        "description": "Get critical technology dimensions such as minimum metal width. Predominantly used in pcell parameter definitions, but not necessarily restricted to that. There is a small set of technology properties that are used in the standard opc cells, but there is currently no proper definitions of the supported fields. See basic/mosfet and basic/cmos for examples. This function can be given multiple look-up strings, the first one that is found will be returned. If the maximum of several properties is required, use 'technology.get_dimension_max()'. For convenience, this function can also process 'nil' parameters, which will simply be ignored.",
        "examples": "function parameters()     pcell.add_parameters({ {\"width\", technology.get_dimension(\"Minimum M1 Width\") } }) end",
    },
    {
        "module": "technology",
        "funcname": "get_dimension_max",
        "syntax": "get_dimension_max(properties...)",
        "description": "Get critical technology dimensions such as minimum metal width. This is similar to technology.get_dimension, but returns the maximum value of all given properties.",
        "examples": "function parameters()     pcell.add_parameters({ {\"width\", technology.get_dimension_ma(\"Minimum Gate Width\", \"Analog Gate Width\") } }) end",
    },
    {
        "module": "technology",
        "funcname": "get_dimension_min",
        "syntax": "get_dimension_min(properties...)",
        "description": "Get critical technology dimensions such as minimum metal width. This is similar to technology.get_dimension, but returns the minimum value of all given properties.",
        "examples": "function parameters()     pcell.add_parameters({ {\"space\", technology.get_dimension_ma(\"Minimum Gate Space\", \"Minimum Gate XSpace\") } }) end",
    },
    {
        "module": "technology",
        "funcname": "get_optional_dimension",
        "syntax": "get_optional_dimension(properties...)",
        "description": "Like get_dimension, but this function does not raise an error if the dimension was not found but simply returns 0.",
        "examples": "function parameters()     pcell.add_parameters({ {\"width\", technology.get_optional_dimension(\"Minimum M1 Width\") } }) end",
    },
    {
        "module": "technology",
        "funcname": "has_feature",
        "syntax": "has_feature(feature)",
        "description": "Check if the chosen technology supports a certain feature. Currently available features: 'has_gatecut', 'allow_poly_routing', 'is_soi'",
        "examples": "if technology.has_feature(\"has_gatecut\") then     -- do something with gatecuts end",
    },
    {
        "module": "technology",
        "funcname": "has_layer",
        "syntax": "has_layer(layerfunction, ...)",
        "description": "Check if the chosen technology supports a certain layer",
        "examples": "if technology.has_layer(generics.other, \"gatecut\") then     -- do something with gatecuts end",
    },
    {
        "module": "technology",
        "funcname": "has_multiple_patterning",
        "syntax": "has_multiple_patterning(metalnumber)",
        "description": "Check if the chosen metal layer (represented by the metal index) supports multiple patterning",
        "examples": "local metallayer if technology.has_multiple_patterning(1) then     metallayer = generics.mptmetal(1, 1) else     metallayer = generics.metal(1) end",
    },
    {
        "module": "technology",
        "funcname": "has_metal",
        "syntax": "has_metal(metalnumber)",
        "description": "Check if the given metal layer is within the range of available metal layers. Negative numbers are resolved as in generics.metal.",
        "examples": "if technology.has_metal(1) then ...",
    },
    {
        "module": "technology",
        "funcname": "multiple_patterning_number",
        "syntax": "multiple_patterning_number(metalnumber)",
        "description": "Get the number of available mask for a metal layer that supports multiple patterning (otherwise the result is 0)",
        "examples": "local nummasks = technology.multiple_patterning_number(1) for i = 1, nummasks do     -- do something for every mask of this metal layer end",
    },
    {
        "module": "technology",
        "funcname": "resolve_metal",
        "syntax": "resolve_metal(index)",
        "description": "resolve negative metal indices to their 'real' value (e.g. in a metal stack with five metals -1 becomes 5, -3 becomes 3). This function does not do anything if the index is positive",
        "examples": "local metalindex = technology.resolve_metal(-2)",
    },
    {
        "module": "technology",
        "funcname": "metal_layer_to_index",
        "syntax": "metal_layer_to_index(layer)",
        "description": "retrieve the numeric index of a metal layer. The function always returns positive indices. If a non-metal layer is given, the function returns 0.",
        "examples": "local metalindex = technology.metal_layer_to_index(generics.metal(2)) -- 2",
    },
    {
        "module": "technology",
        "funcname": "get_number_of_metals",
        "syntax": "get_number_of_metals()",
        "description": "get the number of metals in the layer stack. This value is given in the configuration file of a technology node",
        "examples": "local nummetals = technology.get_number_of_metals()",
    },
    {
        "module": "technology",
        "funcname": "list_techpaths",
        "syntax": "list_techpaths()",
        "description": "list the current technology paths",
        "examples": "technology.list_techpaths()",
    },
    {
        "module": "util",
        "funcname": "is_on_grid",
        "syntax": "is_on_grid(value, grid)",
        "description": "check if a value is on a given grid. This function returns a boolean, and does not assert internally. This is for detecting off-grid situations in order to remedy them, not as a sanity check. Use util.check_grid if that is required.",
        "examples": "util.check_grid(80, 10) -- true util.check_grid(85, 10) -- false",
    },
    {
        "module": "util",
        "funcname": "check_grid",
        "syntax": "check_grid(grid, ...)",
        "description": "check that all given numbers are on integer multiples of the given grid. This function calls assert, so aborts the entire program if the assertation fails. This is intended as a sanity check, not detection in order to solve this. Use util.is_on_grid if that is required.",
        "examples": "util.check_grid(100, 100, 800, 42, 10000) -- will fail",
    },
    {
        "module": "util",
        "funcname": "min",
        "syntax": "min(t)",
        "description": "retrieve the minimum value of a numeric array. Returns the corresponding index as second return value",
        "examples": "local min, idx = util.min({ 1, 4, 2, 3 }) -- 1, 1",
    },
    {
        "module": "util",
        "funcname": "max",
        "syntax": "max(t)",
        "description": "retrieve the maximum value of a numeric array. Returns the corresponding index as second return value",
        "examples": "local max, idx = util.max({ 1, 4, 2, 3 }) -- 4, 2",
    },
    {
        "module": "util",
        "funcname": "make_counter",
        "syntax": "make_counter(start)",
        "description": "create a counter function that increments and returns its current value everytime it is called. If a value is given, the counter starts at that value. The default is 1.",
        "examples": "local counter = util.make_counter() print(counter()) -- 1 print(counter()) -- 2 print(counter()) -- 3",
    },
    {
        "module": "util",
        "funcname": "polygon_xmin",
        "syntax": "polygon_xmin(polygon)",
        "description": "retrieve the minimum x-value of all points of a polygon",
        "examples": "local value = util.polygon_xmin({ point.create(0, 0), point.create(100, 0), point.create(200, 100), point.create(-100, 200) }) -- -100",
    },
    {
        "module": "util",
        "funcname": "polygon_xmax",
        "syntax": "polygon_xmax(polygon)",
        "description": "retrieve the maximum x-value of all points of a polygon",
        "examples": "local value = util.polygon_xmax({ point.create(0, 0), point.create(100, 0), point.create(200, 100), point.create(-100, 200) }) -- 200",
    },
    {
        "module": "util",
        "funcname": "polygon_ymin",
        "syntax": "polygon_ymin(polygon)",
        "description": "retrieve the minimum y-value of all points of a polygon",
        "examples": "local value = util.polygon_ymin({ point.create(0, 0), point.create(100, 0), point.create(200, 100), point.create(-100, 200) }) -- 0",
    },
    {
        "module": "util",
        "funcname": "polygon_ymax",
        "syntax": "polygon_ymax(polygon)",
        "description": "retrieve the maximum y-value of all points of a polygon",
        "examples": "local value = util.polygon_ymax({ point.create(0, 0), point.create(100, 0), point.create(200, 100), point.create(-100, 200) }) -- 200",
    },
    {
        "module": "util",
        "funcname": "xmirror",
        "syntax": "xmirror(pts, xcenter)",
        "description": "create a copy of the points in pts (a table) with all x-coordinates mirrored with respect to xcenter",
        "examples": "local pts = { point.create(10, 0), point.create(20, 0) } util.xmirror(pts, 0) -- { (-10, 0), (-20, 0) }",
    },
    {
        "module": "util",
        "funcname": "ymirror",
        "syntax": "ymirror(pts, ycenter)",
        "description": "create a copy of the points in pts (a table) with all y-coordinates mirrored with respect to ycenter",
        "examples": "local pts = { point.create(0, 10), point.create(0, 20) } util.ymirror(pts, 0) -- { (0, -10), (0, -20) }",
    },
    {
        "module": "util",
        "funcname": "xymirror",
        "syntax": "xymirror(pts, xcenter, ycenter)",
        "description": "create a copy of the points in pts (a table) with all x- and y-coordinates mirrored with respect to xcenter and ycenter, respectively",
        "examples": "local pts = { point.create(10, 10), point.create(20, 20) } util.ymirror(pts, 0, 0) -- { (-10, -10), (-20, -20) }",
    },
    {
        "module": "util",
        "funcname": "filter_forward",
        "syntax": "filter_forward(pts, fun)",
        "description": "iterate forward through the list of points and create a new list with copied points that match the predicate. The predicate function is called with every point.",
        "examples": "local pts = { ... } local predicate = function(pt) return pt:getx() > 0 end local newpts = util.filter_forward(pts, predicate)",
    },
    {
        "module": "util",
        "funcname": "filter_backward",
        "syntax": "filter_backward(pts, fun)",
        "description": "iterate backward through the list of points and create a new list with copied points that match the predicate. The predicate function is called with every point.",
        "examples": "local pts = { ... } local predicate = function(pt) return pt:getx() > 0 end local newpts = util.filter_backward(pts, predicate)",
    },
    {
        "module": "util",
        "funcname": "merge_forwards",
        "syntax": "merge_forwards(pts, pts2)",
        "description": "append all points from pts2 to pts1. Iterate pts2 forward. Operates in-place, thus pts is modified",
        "examples": "util.merge_forward(pts, pts2)",
    },
    {
        "module": "util",
        "funcname": "merge_backwards",
        "syntax": "merge_backwards(pts, pts2)",
        "description": "append all points from pts2 to pts1. Iterate pts2 backwards. Operates in-place, thus pts is modified",
        "examples": "util.merge_backward(pts, pts2)",
    },
    {
        "module": "util",
        "funcname": "merge_tables",
        "syntax": "merge_tables(t1, t2)",
        "description": "create a new table with t1 and t2 concatenated. The elements of t2 are append after thos of t1. Only the array entries of t1 and t2 are processed.",
        "examples": "util.merge_tables({ 1, 2, 3 }, { 4, 5, 6 }) -- { 1, 2, 3, 4, 5, 6 }",
    },
    {
        "module": "util",
        "funcname": "insert_table",
        "syntax": "insert_table(main, t)",
        "description": "create a copy of the point array with the order of points reversed",
        "examples": "local t = { 1, 2, 3 } util.insert_table(t, { 4, 5, 6 }) -- t is now { 1, 2, 3, 4, 5, 6 }",
    },
    {
        "module": "util",
        "funcname": "reverse",
        "syntax": "reverse(pts)",
        "description": "create a copy of the point array with the order of points reversed",
        "examples": "local reversed = util.reverse(pts)",
    },
    {
        "module": "util",
        "funcname": "make_insert_xy",
        "syntax": "make_insert_xy(pts, index)",
        "description": "create a function that inserts points into a point array. XY mode, thus points are given as two coordinates. If an index is given, insert at that position. Mostly useful with 1 as an index or not index at all (append)",
        "examples": "local pts = {} local _append = util.make_insert_xy(pts) _append(0, 0) _append(100, 0) _append(100, 100) _append(0, 100)",
    },
    {
        "module": "util",
        "funcname": "make_insert_pts",
        "syntax": "make_insert_pts(pts, index)",
        "description": "create a function that inserts points into a point array. Point mode, thus points are given as single points. If an index is given, insert at that position. Mostly useful with 1 as an index or not index at all (append)",
        "examples": "local pts = {} local _append = util.make_insert_pts(pts) _append(point.create(0, 0)) _append(point.create(100, 0)) _append(point.create(100, 100)) _append(point.create(0, 100))",
    },
    {
        "module": "util",
        "funcname": "rep",
        "syntax": "rep(num, value)",
        "description": "create an array-like table with one entry repeated N times. This is useful, for example, for specifying gate contacts for basic/cmos.",
        "examples": "local gatecontactpos = util.rep(4, 0) -- { 0, 0, 0, 0 }",
    },
    {
        "module": "util",
        "funcname": "range",
        "syntax": "range(lower, upper, incr)",
        "description": "create a table with numeric entries between lower and upper (both inclusive). The entries spacing is specified by the increment (default 1)",
        "examples": "util.range(1, 5) -- { 1, 2, 3, 4, 5 } util.range(2, 8, 3) -- { 2, 5, 8 }",
    },
    {
        "module": "util",
        "funcname": "remove",
        "syntax": "remove(t, comp)",
        "description": "create a shallow copy of a table with certain elements matching the given criteria removed. The 'comp' parameter can either be a value, which will be compared directly to the entries or a comparison function. If the result of the function call is 'true', the entry is NOT included in the results table.",
        "examples": "util.remove({1, 2, 3, 4, 5}, 3) -- { 1, 2, 4, 5 } util.remove({1, 2, 3, 4, 5}, function(e) return e % 2 == 0 end) -- { 1, 3, 5 }",
    },
    {
        "module": "util",
        "funcname": "remove_index",
        "syntax": "remove_index(t, index)",
        "description": "create a shallow copy of a table with the element(s) at the 'index(es)' removed. Index can be either a scalar integer or a table containing multiple indices which shall be removed",
        "examples": "util.remove_index({10, 20, 30, 40, 50}, 3) -- { 10, 20, 40, 50 }",
    },
    {
        "module": "util",
        "funcname": "remove_inplace",
        "syntax": "remove_inplace(t, comp)",
        "description": "remove certain elements matching the given criteria. The 'comp' parameter can either be a value, which will be compared directly to the entries or a comparison function. If the result of the function call is 'true', the entry is NOT included in the results table.",
        "examples": "util.remove({1, 2, 3, 4, 5}, 3) -- { 1, 2, 4, 5 } util.remove({1, 2, 3, 4, 5}, function(e) return e % 2 == 0 end) -- { 1, 3, 5 }",
    },
    {
        "module": "util",
        "funcname": "remove_index_inplace",
        "syntax": "remove_index_inplace(t, index)",
        "description": "remove the element of the given table at the given index (actually just a wrapper for table.remove)",
        "examples": "util.remove_index({10, 20, 30, 40, 50}, 3) -- { 10, 20, 40, 50 }",
    },
    {
        "module": "util",
        "funcname": "fill_all_with",
        "syntax": "fill_all_with(num, filler)",
        "description": "create an array-like table with one entry repeated N times. This is useful, for example, for specifying gate contacts for basic/cmos",
        "examples": "local gatecontactpos = util.fill_all_with(4, \"center\") -- { \"center\", \"center\", \"center\", \"center\" }",
    },
    {
        "module": "util",
        "funcname": "fill_predicate_with",
        "syntax": "fill_predicate_with(num, filler, predicate, other)",
        "description": "create an array-like table with two entries (total number of entries is N). This function (compared to fill_all_with, fill_odd_with and fill_even_with) allows for more complex patterns. To do this, a predicate (a function) is called on every index. If the predicate is true, the first entry is inserted, otherwise the second one. This function is useful, for example, for specifying gate contacts for basic/cmos. Counting starts at 1, so the first entry will be 'other'",
        "examples": "local contactpos = util.fill_predicate_with(8, \"power\", function(i) return i % 4 == 0 end, \"outer\")",
    },
    {
        "module": "util",
        "funcname": "fill_even_with",
        "syntax": "fill_even_with(num, filler, other)",
        "description": "create an array-like table with two entries repeated N / 2 times, alternating. Counting starts at 1. This is useful, for example, for specifying gate contacts for basic/cmos. Counting starts at 1, so the first entry will be 'other'",
        "examples": "local gatecontactpos = util.fill_even_with(4, \"center\", \"upper\") -- { \"upper\", \"center\", \"upper\", \"center\" }",
    },
    {
        "module": "util",
        "funcname": "fill_odd_with",
        "syntax": "fill_odd_with(num, filler, other)",
        "description": "create an array-like table with two entries repeated N / 2 times, alternating. Counting starts at 1. This is useful, for example, for specifying gate contacts for basic/cmos. Counting starts at 1, so the first entry will be 'filler'",
        "examples": "local gatecontactpos = util.fill_odd_with(4, \"center\", \"upper\") -- { \"center\", \"upper\", \"center\", \"upper\" }",
    },
    {
        "module": "util",
        "funcname": "clone_shallow",
        "syntax": "clone_shallow(table)",
        "description": "create a shallow copy of a table. This function creates a copy of the given table, where all first-level values are copied. If those values are tables, they reference the same table as the original object.",
        "examples": "local new = util.clone_shallow(t)",
    },
    {
        "module": "util",
        "funcname": "clone_shallow_predicate",
        "syntax": "clone_shallow_predicate(table, predicate)",
        "description": "create a shallow copy of a table. This function creates a copy of the given table, where all first-level values are copied. If those values are tables, they reference the same table as the original object. This function only copies items where the given predicate function (called with the key and the value of the item) returns true.",
        "examples": "local new = util.clone_shallow_predicate(t, function(k, v) if string.match(v, \"vdd.+\") end)",
    },
    {
        "module": "util",
        "funcname": "clone_array_predicate",
        "syntax": "clone_array_predicate(table, predicate)",
        "description": "create a shallow copy of an array-like table. This function creates a copy of the given table, where all first-level array values are copied. If those values are tables, they reference the same table as the original object. This function only copies items where the given predicate function (called with value of the item) returns true. The array indices might change as not all elements might be copied.",
        "examples": "local new = util.clone_shallow_predicate(t, function(e) if string.match(e, \"vdd.+\") end)",
    },
    {
        "module": "util",
        "funcname": "add_options",
        "syntax": "add_options(baseoptions, additionaloptions)",
        "description": "create a copy of the baseoptions table and add all key-value pairs found in additionaloptions. This function clones baseoptions so the original is not altered. This copy is flat, so only the first-level elements are copied (e.g. tables will reference the same object). This function is useful to modify a set of base options for several devices such as mosfets, which only differ in a few options",
        "examples": "local baseoptions = ... local fet = pcell.create_layout(\"basic/mosfet\", \"fet\", util.add_options(baseoptions, { gatelength = 100 }))",
    },
    {
        "module": "util",
        "funcname": "ratio_split_even",
        "syntax": "ratio_split_even(value, ratio)",
        "description": "create two values that sum up to the input value and have the specified ratio. The values are adjusted so that both of them are even, possibly changing the ratio slightly. The input value must be even",
        "examples": "local pitch = 1000 local width, space = util.ratio_split_even(pitch, 2) -- results in 668 and 332, the actual ratio then is 2.012",
    },
    {
        "module": "util",
        "funcname": "ratio_split_multiple_of",
        "syntax": "ratio_split_multiple_of(value, ratio, multiple)",
        "description": "create two values that sum up to the input value and have the specified ratio. The values are adjusted so that both of them are multiples of the given value ('multiple'), possibly changing the ratio slightly. The input value must be divisable by 'multiple'. This function called with multiple == 2 behaves exactly like ratio_split_even",
        "examples": "local pitch = 1000 local width, space = util.ratio_split_even(pitch, 2, 20) -- results in 680 and 320, the actual ratio then is 2.125",
    },
    {
        "module": "util",
        "funcname": "make_rectangle",
        "syntax": "make_rectangle(center, width, height)",
        "description": "create a rectangle from a center point and the width and height. This function returns two points (bottom-left and top-right)",
        "examples": "local bl, tr = util.make_rectangle(point.create(0, 0), 100, 100)",
    },
    {
        "module": "util",
        "funcname": "polygon_rectangular_boundary",
        "syntax": "polygon_rectangular_boundary(polygon)",
        "description": "calculate the encompassing rectangle of the given polygon. This function two points: 'bl' (bottom-left) and 'tr' (top-right).",
        "examples": "local bl, tr = util.polygon_rectangular_boundary(polygon)",
    },
    {
        "module": "util",
        "funcname": "rectangle_to_polygon",
        "syntax": "rectangle_to_polygon(bl, tr, leftext, rightext, bottomext, topext)",
        "description": "convert a two-point rectangle to a polygon describing this rectangle. Optionally, the polygon can be extended in the four directions (left/right/bottom/top). This function is useful for creating fill layer boundaries or fill target regions",
        "examples": "local region = util.rectangle_to_polygon(point.create(-100, -100), point.create(100, 100), -100, 0, 0, 200)",
    },
    {
        "module": "util",
        "funcname": "is_rectilinear_polygon",
        "syntax": "is_rectilinear_polygon(polygon)",
        "description": "Check whether a given polygon is rectilinear (has only angles of 90 degrees)",
        "examples": "util.is_rectilinear_polygon(polygon)",
    },
    {
        "module": "util",
        "funcname": "split_rectilinear_polygon",
        "syntax": "split_rectilinear_polygon(polygon)",
        "description": "Split a rectilinear polygon into non-overlapping rectangles. This function returns a table with one entry per rectangle. The rectangles are represented by something like '{ pt1 = point.create(...), pt2 = point.create(...) }'. The function checks whether the polygon is actually rectilinear and does not do anything in case it is not.",
        "examples": "local rectangles = util.split_rectilinear_polygon(polygon)",
    },
    {
        "module": "util",
        "funcname": "fit_rectangular_polygon",
        "syntax": "fit_rectangular_polygon(bl, tr, xgrid, ygrid, minxext, minyext, xmultiple, ymultiple)",
        "description": "convert a two-point rectangle to a polygon describing this rectangle. The polygon is extended so that its width and height are a integer multiple of the specified x- and y-grid. The polygon's width and height are always at least the width and height of the rectangle. Additionally, a minimum extension can be given in x- and y-direction, which can further increase the polygon's size. The resulting rectangle can be tuned so that it has an even or odd multiplicity in either of the directions. The keys \"even\" or \"odd\" can be used for the last two parameters 'xmultiple' and 'ymultiple'. If they are nil, the resulting rectangle is not modified from the original fitting.",
        "examples": "local region = util.fit_rectangular_polygon(point.create(-127, -110), point.create(118, 109), 20, 20, 50, 50)",
    },
    {
        "module": "util",
        "funcname": "offset_polygon",
        "syntax": "offset_polygon(polygon, offset)",
        "description": "Calculate a new polygon from a given one with all lines shifted by a given offset. This function has potentially many uses, but as of version 0.10.0 it is mostly used for expanding layer boundaries to include mandatory spacing to automatically generated fill structures. Hence, it is only tested for positive offsets. Additionally, for extreme cases (acute angles with large offsets) self-intersecting polygons can occur. This function should fix these, but it currently does not. This is a bug. Submission of proper algorithms to solve this are very welcome.",
        "examples": "local new_polygon = util.offset_polygon(polygon, 100)",
    },
    {
        "module": "util",
        "funcname": "rectangle_intersection",
        "syntax": "rectangle_intersection(bl1, tr1, bl2, tr2)",
        "description": "Compute the intersection of two rectangles and return it as a table with 'bl' (bottom-left) and 'tr' (top-right) entries. If no itersection exists, this function returns nil.",
        "examples": "local region = util.rectangle_intersection(point.create(0, 0), point.create(100, 100), point.create(20, 20), point.create(200, 20))",
    },
    {
        "module": "util",
        "funcname": "any_of",
        "syntax": "any_of(comp, table, ...)",
        "description": "return true if any of the values in the array part of the table compare true (either directly to the given value or the function call is true). If a comparison function is given it is called with every element of the array and (if present) any additional parameters to util.any_of are passed to the function, following the array element",
        "examples": "util.any_of(42, { 1, 2, 3 }) -- false util.any_of(function(e) return e == 42 end, { 1, 2, 3 }) -- also false",
    },
    {
        "module": "util",
        "funcname": "all_of",
        "syntax": "all_of(comp, table, ...)",
        "description": "return true if all of the values in the array part of the table compare true (either directly to the given value or the function call is true). If a comparison function is given it is called with every element of the array and (if present) any additional parameters to util.all_of are passed to the function, following the array element",
        "examples": "util.all_of(42, { 42, 42, 42 }) -- true util.all_of(function(e) return e == 42 end, { 42, 2, 3 }) -- false",
    },
    {
        "module": "util",
        "funcname": "transform_points",
        "syntax": "transform_points(pts, func)",
        "description": "transform all points in a list of points. This function creates a copy of the point list (the points are copied too). Every point is transformed by the transformation function. Any return values of the function are ignored, the function should transform the given point in-place.",
        "examples": "util.transform_points({     point.create(0, 0),     point.create(100, 100)     point.create(50, 200) }, function(pt) pt:translate(100, 100) end)",
    },
    {
        "module": "util",
        "funcname": "round_to_grid",
        "syntax": "round_to_grid(coordinate, grid)",
        "description": "round a coordinate to a multiple of the given grid",
        "examples": "util.round_to_grid(120, 100) -- 100 util.round_to_grid(160, 100) -- 200",
    },
    {
        "module": "util",
        "funcname": "fix_to_grid_higher",
        "syntax": "fix_to_grid_higher(coordinate, grid)",
        "description": "fix a coordinate to a multiple of the given grid. This function works like a 'ceil(ing)' function, so the resulting number is either higher or equal. This means that this function does not behave symmetrically for negative and positive input. If this is required, use util.fix_to_grid_abs_higher.",
        "examples": "util.fix_to_grid_higher(120, 100) -- 200 util.fix_to_grid_higher(-120, 100) -- 100",
    },
    {
        "module": "util",
        "funcname": "fix_to_grid_lower",
        "syntax": "fix_to_grid_lower(coordinate, grid)",
        "description": "fix a coordinate to a multiple of the given grid. This function works like a 'floor(ing)' function, so the resulting number is either lower or equal. This means that this function does not behave symmetrically for negative and positive input. If this is required, use util.fix_to_grid_abs_lower.",
        "examples": "util.fix_to_grid_lower(120, 100) -- 100 util.fix_to_grid_lower(-120, 100) -- 200",
    },
    {
        "module": "util",
        "funcname": "fix_to_grid_abs_higher",
        "syntax": "fix_to_grid_abs_higher(coordinate, grid)",
        "description": "fix a coordinate to a multiple of the given grid. This function works like a 'ceil(ing)' function, but it is computed on the absolute value, so the absolute of the resulting number is either higher or equal. This means that this function does behave symmetrically for negative and positive input. If this is unwanted, use util.fix_to_grid_higher.",
        "examples": "util.fix_to_grid_abs_higher(120, 100) -- 200 util.fix_to_grid_abs_higher(-120, 100) -- 200",
    },
    {
        "module": "util",
        "funcname": "fix_to_grid_abs_lower",
        "syntax": "fix_to_grid_abs_lower(coordinate, grid)",
        "description": "fix a coordinate to a multiple of the given grid. This function works like a 'floor(ing)' function, but it is computed on the absolute value, so the absolute of the resulting number is either lower or equal. This means that this function does behave symmetrically for negative and positive input. If this is unwanted, use util.fix_to_grid_lower.",
        "examples": "util.fix_to_grid_abs_lower(120, 100) -- 100 util.fix_to_grid_abs_lower(-120, 100) -- 100",
    },
    {
        "module": "util",
        "funcname": "foreach",
        "syntax": "foreach(table, function, ...)",
        "description": "apply a function to every element of a given table. Return a new table containing the results of these calls in the order of the original elements. Additional arguments can be passed to the function.",
        "examples": "util.foreach({ 1, 2, 3 }, generics.metal)",
    },
    {
        "module": "util",
        "funcname": "reduce",
        "syntax": "reduce(table, function, initial, ...)",
        "description": "apply a function to every element of a given table. Return a scalar result of these calls. An initial value must be given (e.g. '0' for numeric operations). This sets the type of the result. Additional arguments can be passed to the function.",
        "examples": "util.reduce({ 1, 2, 3 }, function(lhs, rhs) return lhs + rhs end, 0) -- 6",
    },
    {
        "module": "util",
        "funcname": "find",
        "syntax": "find(table, value)",
        "description": "find a value in an array. This function returns the index of that value and the value itself. If multiple values match, only the first one is returned.",
        "examples": "util.find({ 3, 4, 5 }, 4) -- 2, 4",
    },
    {
        "module": "util",
        "funcname": "find_predicate",
        "syntax": "find_predicate(table, comp, ...)",
        "description": "Like util.find, but call a function to do the comparison. The function is called with every one of the values, but not the index. If multiple values match, only the first one is returned.",
        "examples": "util.find({ 3, 4, 5 }, function(value) return value == 4 end) -- 2, 4 local target = 4 util.find({ 3, 4, 5 }, function(value, t) return value == t end, target) -- 2, 4 ",
    },
    {
        "module": "util",
        "funcname": "fit_lines_upper",
        "syntax": "fit_lines_upper(total, size, space)",
        "description": "Calculate the number of lines with the given size and space that fit into the given total width/height. This function rounds up.",
        "examples": "util.fit_lines_upper(10000, 500, 500) -- 11",
    },
    {
        "module": "util",
        "funcname": "fit_lines_lower",
        "syntax": "fit_lines_lower(total, size, space)",
        "description": "Calculate the number of lines with the given size and space that fit into the given total width/height. This function rounds down.",
        "examples": "util.fit_lines_lower(10000, 500, 500) -- 10",
    },
    {
        "module": "util",
        "funcname": "fit_lines_width_grid",
        "syntax": "fit_lines_width_grid(total, width, numlines, grid)",
        "description": "Calculate the spacing of a given number of lines of a certain width that should fit in a region. This function can take a grid and will decrement the space until it fits on the grid",
        "examples": "util.fit_lines_width_grid(10000, 1000, 8) -- 285 util.fit_lines_width_grid(10000, 1000, 8, 10) -- 280",
    },
    {
        "module": "util",
        "funcname": "fit_lines_fullwidth_grid",
        "syntax": "fit_lines_fullwidth_grid(total, fullwidth, numlines, grid)",
        "description": "Calculate the spacing of a given number of lines of a certain width that should fit in a region. This function can take a grid and will decrement the space until it fits on the grid. This function is different than util.fit_lines_width_grid in that it does not take the width of an individual line but the combined width of all lines. This is useful when spacing for lines with unequal widths should be calculated.",
        "examples": "util.fit_lines_fullwidth_grid(10000, 8000, 8) -- 285 util.fit_lines_lower(10000, 10000, 8, 10) -- 280",
    },
    {
        "module": "util",
        "funcname": "sum",
        "syntax": "sum(t)",
        "description": "calculate the sum of all items of an numeric array",
        "examples": "local sum = util.sum({ 1, 2, 3 }) -- 6",
    },
    {
        "module": "util",
        "funcname": "uniq",
        "syntax": "uniq(t)",
        "description": "create an array where only unique entries of the input array t are present. Equality is checked via the comparison operator '=='",
        "examples": "local u = util.uniq({ 1, 2, 3, 1, 4, 5, 2, 1, 7 }) -- { 1, 2, 3, 4, 5, 7 }",
    },
    {
        "module": "util",
        "funcname": "intersection",
        "syntax": "intersection(s1, s2, t1, t2)",
        "description": "calculate the intersection point of two lines. If the intersection is found, it is returned. If the lines are parallel, nil is returned. If the lines are not parallel but don't intersect (because they are not infinite), their virtual intersection point is returned after nil (as second return value)",
        "examples": "local ptreal, ptvirtual = util.intersection(spt1, spt2, tpt1, tpt2)",
    },
    {
        "module": "util",
        "funcname": "rectangle_union",
        "syntax": "rectangle_union(bl1, tr1, bl1, tr2)",
        "description": "calculate the rectangle union of two rectangles. This only return a non-nil result if the union of the two rectangles is still a true rectangle. The calculated union is return as a table with 'bl' and 'tr' entries",
        "examples": "local union = util.rectangle_union(bl1, tr1, bl2, tr2)",
    },
    {
        "module": "util",
        "funcname": "tconcatfmt",
        "syntax": "tconcatfmt(t, sep, fmt)",
        "description": "Create a string representation of the array elements of a table. Similar to table.concat, but this allows to specify a format for every element. util.tconcatfmt(t, sep, \"%s\") is equivalent to table.concat(t, sep).",
        "examples": "local str = util.tconcatfmt(t, \", \", \"<%s>\")",
    },
];

// get all the elements you'll need from your HTML
const input    = document.querySelector(".search-bar");
const results  = document.querySelector(".search-results");
const template = document.querySelector(".result");

// whenever the user types in the search input, look for a apiref by name
input.addEventListener("input", searchByAPIRefName);

function checkMatch(searchQuery, apiref)
{
    const matches_module = apiref.module.includes(searchQuery)
    const matches_funcname = apiref.funcname.includes(searchQuery)
    const matches_description = apiref.description.includes(searchQuery)
    return matches_module || matches_funcname || matches_description
}

function searchByAPIRefName(inputEvent)
{
    const searchQuery   = inputEvent.target.value;
    const isEmptySearch = searchQuery.trim() === "";

    // get array with matching entries
    const matching_api_refs = isEmptySearch ?
        []
        : apirefs.filter(checkMatch.bind(null, searchQuery));

    // show matching results
    renderSearchResults(matching_api_refs);
}

function renderSearchResults(productsToRender)
{
    // remove any existing results
    results.innerHTML = "";

    // loop through every apiref that matched our query
    for(const apiref of productsToRender){
        // clone our apiref template;
        const clone = template.content.cloneNode(true);

        // fill-out the cloned template with the apiref details
        clone.querySelector(".APIref-funcname").innerText = apiref.module + "." + apiref.funcname;
        clone.querySelector(".APIref-syntax").innerText = apiref.syntax;
        clone.querySelector(".APIref-description").innerText = apiref.description;
        clone.querySelector(".APIref-examples").innerText = apiref.examples;
        //clone.querySelector(".link").setAttribute("href", apiref.url);

        // add our clone to the results
        results.appendChild(clone);
    }
}
</script>
