\input{../preamble}

\title{OpenPCells}
\subtitle{PCell Design Guide and API}
\author{Patrick Kurth}

\begin{document}
\maketitle
\begin{abstract}
    \noindent This is the official documentation of the OpenPCells project.  It is split in several different files for clarity. This document provides an overview
    of the creation of PCells in the OpenPCells environment as well as a detailed API documentation.  If you are looking for a general overview of the project and
    how to use it, start with the user guide, which also contains a tutorial for getting started quickly. If you want to know more about the technical details and
    implementation notes, look into the technical documentation.
\end{abstract}

\tableofcontents

\section{PCell Creation -- Introductory Examples}
We will start this documentation by a series of examples to show the main features and API functions. The to-be-created cells will get increasingly complex to
demonstrate various features.

Every cell is defined by a function where all shapes making up the shape are described. This function gets called by the cell generation system, which passes the
main object and a table with all defined parameters. The name for this function is \luainline{layout()}. Additional functions such as \luainline{parameters()}
are also understood.

\subsection{First Example -- Simple Rectangle}
The first example is a simple rectangle of variable width and height. As mentioned, all the code for the rectangle resides in a function \luainline{layout()}.
The parameters of the cell are defined in a function \luainline{parameters()}, which is optional in theory, but since we're designing pcells, there is not much point
of leaving it out. In \luainline{layout()}, we receive the main object and the defined parameters. Here we can modify the object based on the parameters.

The simple rectangle looks like this:
\luafilelisting{code/simple_rectangle.lua}
Let's walk through this line-by-line (sort of). First, we declare the function for the parameter definition:
\luafilelisting[firstline = 2, lastline = 2]{code/simple_rectangle.lua}
In the function, we add the parameters, here we use the width and the height of the rectangle:
\luafilelisting[widthgobble=4, firstline = 3, lastline = 6]{code/simple_rectangle.lua}
We can add as many parameters as we like (\luainline{pcell.add_parameters()} accepts any number of arguments). For every argument, the first entry in the table is
the name of the parameter, the second entry is the default value. This is the simplest form, we can supply more information for finer control. We will see some
examples of this later on.

The default value for both parameters is 100, which is a \emph{size}, meaning it has a unit. Physical/geometrical parameters like width or height are specified
in nanometers.\footnote{Well, this is not entirely sure. Only integers are allowed and the base unit is assumed to be nanometer. This is also
currently reflected for example in the GDSII export, where the scaling is done approriately. However, it is planned that this will change in the
future, making the base unit in opc arbitrary.}

This is all for the \luainline{parameters()} function, so let's move on to \luainline{layout()}. This functions takes two arguments: the main object that will be
placed in the layout and the table with parameters for the cell (which already includes any parsed arguments given before the cell creation).

We can name them in any way that pleases us, the common name used in all standard cells distributed by this project is \luainline{_P} (as hommage to the global
environment \luainline{_G} in lua).
Of course it is possible to \enquote{unpack} the parameters, storing them in individual variables, but for cells with many parameters this rather is a bloat.
\luafilelisting[widthgobble = 0, firstline = 10, lastline = 10]{code/simple_rectangle.lua}

Now that we have all the layout parameters, we can already create the rectangle:
\luafilelisting[widthgobble = 4, firstline = 12, lastline = 17]{code/simple_rectangle.lua}
There is a lot going on here: We use the \luainline{geometry.rectanglebltr} function to create a rectangle with two corner points (bottom-left, bl and top-right, tr).
Since we are creating shapes of IC geometry, we have to specify a layer.
But we also want to create technology-independent pcells, so there is a generics system for layers.
Right now we are just using the \luainline{generics.metal} function, which takes a single number as argument.
\luainline{generics.metal(1)} specifies the first metal (counted from silicon), you can also say something like \luainline{generics.metal(-2)}, where \luainline{-1} is the index of the highest metal.
Lastly we pass the main object as first argument to the function, which places the rectangle within this object.

This cell can now be created by calling the main program with an appropriate export and technology.
Note that there's another manual about that, so we won't get into any details here.
The simplest call would be something like:
\begin{shellcode}
    opc --technology opc --export gds --cell simple_rectangle
\end{shellcode}

Now you already now how to create simple rectangles with generic layers.
As integrated circuits are mostly made up of rectangles, one can already built a surprising amount of pcells.
However, we have to discuss how we can create layers other than metals, vias and shapes with more complex outlines than rectangles.
Furthermore, to reduce complexity hierarchical layout design is also important.
We will talk about these topics in the remaining cell tutorials.

\subsection{Metal-Oxide-Metal Capacitors}
Many technologies don't have so-called metal-insulator-metal capacitors (mimcaps), so the standard way to implement capacitors is be using interdigitated metals.
Let's do that. As before, we set up the pcell. Useful parameters are the number of fingers, the width and height of the fingers and the spacing in between.
Furthermore, we shift one collection of fingers (one plate) up and the other down to separate them and connect them together.
Lastly, we also specify the width of the connecting rails and the used metals.
The shown cell is a simplified version of the actual momcap implementation in opc:
\luafilelisting[firstline = 1, lastline = 13]{code/momcap.lua}
The parameter definition also shows how you can use better names for displaying: Simply write them in parantheses.
When listing the defined parameters of a cell, the display names are used, but within the cell the regular names are significant.
The parameters are stored in a lua table and can be accessed in two ways:
\luainline{_P.fingers} and \luainline{_P["fingers"]}.
Usually, the first way is easier, but it requires the parameter name to be a valid lua identifier.
Names like \luainline{foo-bar} (with a hyphen) are not valid identifiers.
In this case, the second way would have to be used.

In \luainline{layout()} first the metals are resolved.
This makes sure that only positive integers are used (for instance, with a metal stack of five metals, the index -2 is resolved to 4).
This is done in order to have properly-defined values for the following for-loop iterating over all metals.
\luafilelisting[widthgobble = 4, firstline = 18, lastline = 19]{code/momcap.lua}
Then we can set up the loop:
\luafilelisting[widthgobble = 4, firstline = 20, lastline = 20]{code/momcap.lua}
At first, we create the rails (upper and lower):
\luafilelisting[widthgobble = 4, firstline = 22, lastline = 31]{code/momcap.lua}
Then we create the fingers separately.
A second loop represents the fingers.
Every finger has to be moved right, every second finger has to be moved up:
\luafilelisting[widthgobble = 4, firstline = 33, lastline = 41]{code/momcap.lua}

What remains is the drawing of the vias between the metals.
For this we introduce a new \luainline{geometry} function: \luainline{geometry.viabltr}.
It takes a rectangular area and creates individual cuts as well as surrounding metals.
There has to be some technology translation for this (proper layer generation as well as calculating the proper geometry of the cuts).
The details on this are not important for this discussion.
It is covered more in-depth in the technology translation manual.
For this case it is enough to know that an appropriate and manufacturable amount of via cuts is placed within this rectangular area.
Since the region is a rectangular, \luainline{geometry.viabltr} takes almost the same arguments as \luainline{geometry.rectanglebltr}.
Only the metal layer is changed into two indices for the first and the last metal of the stack.
This means that \luainline{geometry.viabltr} does \emph{not} expect a generic layer as input.
All layer creation is done by the function itself.
Furthermore, we don't have to specify the individual vias between each layer in the stack, this is resolved later by the technology translation.
For the capacitor, the vias are placed in the rails:
\luafilelisting[widthgobble = 4, firstline = 43, lastline = 54]{code/momcap.lua}

With this the pcell is almost finished, the remaining code defines so-called \emph{anchors}, which are used for relative positioning.
These will be discussed further down this document and therefore are skipped in this section.
A cell similar to this is bundled in this release of openPCells (\texttt{cells/passive/capacitor/mom.lua}).
A few optimizations and additional parameters are added, but the here shown implementation is the basic structure of this capacitor.

\subsection{Octagonal Inductor}
RF designs often require on-chip inductors, which usually are built in an octagonal shape due to angle restrictions in most technologies (no true circles or
better approximations available).
We will show how to built a differential (symmetric) octagonal inductor with a variable number of turns (integers).
We will skip some basic techniques that we already discussed a few times such as setting up the cell body, cell parameters and main object.
Look into \texttt{cells/passive/inductor/octagonal.lua} for the defined parameters.

An inductor is basically a wire (a \emph{path}) routed in a special manner, therefore we will describe the inductor as a \luainline{path}.
This is a series of points that describe a line with a certain width.
To create a path, we have to pass the points to \luainline{geometry.path}, which we will store in a \luainline{table}.
The cell for the octagonal inductor requries some calculations for the right point positions and uses some helper functions.
We won't discuss the entire cell here as some issues are not important for general advice on building cells.
The main purpose is to show how to handle points, point lists and how to draw paths.

First, some information on points:
Points are a structure with an x- and a y coordinate.
They represent absolute locations in the layout and many layout- and object-related take either a pair of x/y coordinates or a point.
Points are simply created by \luainline{point.create}, which takes two numbers for the coordinates (x comes first).
The coordinates can be queried:
\begin{lualisting}
    local pt = point.create(100, 100) -- create a point
    local x, y = pt:unwrap() -- get both x and y
    x = pt:getx() -- get only x
    y = pt:gety() -- get only y
\end{lualisting}
For some layouts, combinations of points are needed, where for instance the x-coordinate of one point should be combined with the y-coordinate of another point.
There are two ways to achieve this:
\begin{lualisting}
    -- newpt == point.create(pt1.x, pt2.y)
    local newpt = point.combine_12(pt1, pt2)
    -- newpt == point.create(pt2.x, pt1.y)
    local newpt = point.combine_21(pt1, pt2)
\end{lualisting}
Both functions do the same, they just differ on the order of their arguments.
Furthermore, some mathematical operators are defined for points:
\begin{lualisting}
    local pt1 = point.create(100, 100)
    local pt2 = point.create(20, -100)
    print(pt1 + pt2)  -- (60, 0)      -> arithmetic average
    print(pt1 - pt2)  -- (80, 200)    -> difference
    print(-pt1)       -- (-100, -100) -> unary minus
    print(pt1 .. pt2) -- (100, -100)  -> point.combine_12(pt1, pt2)
\end{lualisting}
Lastly, there is a shorthand for the scalar distance in either x or y:
\begin{lualisting}
    point.xdistance(pt1, pt2)
    point.ydistance(pt1, pt2)
\end{lualisting}

\bigskip

Let us get back to the inductor.
It has the number of turns as a parameter.
For every turn the points for one half of the turn are calculated, then the path is drawn twice, one time with a mirrored version of the points.
\luafilelisting[widthgobble = 8, firstline = 30, lastline = 32]{../../../cells/passive/inductor/octagonal.lua}
The points are stored in the \luainline{table pathpts}, \luainline{util.make_insert_xy} is a helper function, that returns a function that appends/prepends points to an array. It's purpose is to simplify code, one
might as well just use \luainline{table.insert}.

Then we add points:
\luafilelisting[widthgobble = 8, firstline = 34, lastline = 39]{../../../cells/passive/inductor/octagonal.lua}
Now the cell adds points for the underpass (for the crossing of both sides) as well as the extension for the connections.
This discussion will skip these parts as they don't add any value for learning about \luainline{geometry.path}.
The entire code generating the path points is a bit complex and involves some trigonometric calculations.

After the points are assembled, we can create the path. The cell only draws half of the inductor, so we draw the path twice, one time with mirrored points (notice
\luainline{util.xmirror(pathpts)} in the second line):
\luafilelisting[widthgobble = 8, firstline = 89, lastline = 90]{../../../cells/passive/inductor/octagonal.lua}
The \luainline{geometry.path} function takes five arguments: the cell, the layer, the points of the path, the width and whether to use a miter- or a bevel-join. Bevel-join is
default, so \luainline{true} is specified for a miter-join.
The layers where created earlier as
\luafilelisting[widthgobble = 4, firstline = 20, lastline = 21]{../../../cells/passive/inductor/octagonal.lua}

%\subsection{References and Inheritance}
%In order to be able to build larger layouts, it is very useful to re-use cells in hierarchies (for instance, a current mirror is made up of several transistors).
%It would be a good decision to build everything from scratch.
%Therefore, openPCells offers some basic support for such things.
%We will look at logic gates to illustrate the different options.
%All gates are built from transistors, so we will assume for now that there is a cell to place one.
%Furthermore, digital designs mostly (always?) use a few geometry parameters for all cells, such as the gate length.
%It makes sense to store this in one place so we can redefine it for all cells in a hierarchy, if we want to change that.
%In the supplied logic cell family (\texttt{cells/stdcells}), this is handled by the \texttt{stdcells/base} cell.
%It is a abstract cell, that is, it does not define a layout function, so it can't be called.
%But it does store the relevant parameters, which get referenced by the top cells (and temporarily changed).
%Other cells then access the parameters, for instance \texttt{stdcells/not\_gate.lua}:
%\luafilelisting[firstline = 1, lastline = 11]{../../../cells/stdcells/not_gate.lua}
%This cell has only has a small number of parameters but uses the supplied parameters of \texttt{stdcells/base.lua} for the layout function. The parameters are used
%implicitly by creating other cells that reference these parameters, and explicitly by accessing them with \luainline{pcell.get_parameters}. In order to do this,
%a cell has to reference that cell with \luainline{pcell.reference_cell}. The referenced parameters reflect the current values, that is if a top cell instantiates the
%inverter, it can overwrite the values of referenced parameters, affecting all sub cells. This is achieved by calling \luainline{pcell.push_overwrites}, which can
%be seen in \texttt{stdcells/1\_inv\_gate.lua} (basic cell for and/or):
%\luafilelisting[widthgobble = 4, firstline = 13, lastline = 13]{../../../cells/stdcells/1_inv_gate.lua}
%Cells that need to prevent parameters being changed from the toplevel have to include guards against that, which is exactly what can be seen in the previous
%listing. The overwrites are stack-based, so the last \luainline{push_overwrites} counts. In \texttt{stdcells/1\_inv\_gate.lua}, rightdummies can not be changed from
%outside anymore.
%\subsection{Translation, Object Placement and the Alignment Box}
%We already saw the \luainline{translate} object method to move objects. For more complex layouts, a better method exists. Cells can have anchors, that is, points
%at certain places in the layout which can be referenced. You can ask for the location of an anchor from an object (\luainline{get_anchor}) and you can move a
%cell so that the specified anchor lies at a certain point (\luainline{move_anchor}). Let's see an example:
%\luafilelisting[widthgobble = 8, firstline = 62, lastline = 64]{../../../cells/stdcells/harness.lua}
%The used anchors have to be present in the specific cell, and it is up to the designer of that cell to provide the needed anchors.
%
%Of course do anchors move if an object is moved, but they also move if the cell is flipped/mirror/rotated etc. This ensures that the anchors are always at the
%right place in the layout. However, in certain cases, the opposite behaviour is useful: If you want to, say, place two digital standard cells next to each other,
%you can use appropriate anchors for left and right (for instance at the leftmost and rightmost source/drain) and align them at these points. This works fine
%until a cell is mirrored at the y-axis. Then the anchor left becomes right and the other way around. This means that cells generating such layouts need to handle
%flipped/rotated/mirrored cells differently, which is a nuisance. There is a special set of anchors for exactly this problem: the alignment box. This box is also
%defined by the cell designer and in effect it provides the special anchors left, right, top, bottom and sensible combinations of those (e.g. topleft, NOT
%leftright). The alignment box undergoes translation, but not rotation/flipping/mirroring. This allows the following (from \texttt{stdcells/dff.lua}):
%\luafilelisting[widthgobble = 4, firstline = 75, lastline = 78]{../../../cells/stdcells/dff.lua}
%Notice the calls in the last two lines, where the cell gets flipped in x direction (mirrored at the y axis) but still the left anchor is used for alignment (the
%cell is placed right of the isogate).
%
%The above example shows another important fact about object transformation: Translation is always applied last (after rotation/flipping/mirroring). This is
%contrary to many other graphical programs, where for instance rotation is applied with the origin is center. In opc, the order of the transformation statements
%does not matter. This is intentional, as this is what is usually needed in layouts and simplifies the pcell code. The other behaviour can always be achieved by
%appropriate translation.

\subsection{Integrating Other Cell Layouts}
Layouts of integrated circuits can get very complex quite easily.
The typical way to deal with high complexity is by building individual cell layouts and placing them in the appropriate location.
Partitioning and hierarchy are good tools to tackle circuit complexity.
In essence: Divide and conquer.
Therefore, this section will discuss how to integrate existing cell layouts and how to find the correct location by relative placement.
But first an introduction to how openPCells represents layouts will be given, as this will be important to understand advanced topics.

\subsubsection{Representation of Hierarchical Layouts}
In integrated circuits, layouts are in general represented by a mixture of instantiations of other layouts as well as shapes (such as rectangles,
polygons, paths, etc.).
Typically, there is a root cell for the layout, which is called top-level.
The top-level layout then has some shapes as well as instantiations of other layouts, which in turn have shapes and Instantiations of other layouts and so on.
This is quite similar to a filesystem, where you have a root directory with sub-directories, where every directory can (but not necessarily) contain files that are not directories.
The following picture shows an example of this:
\begin{center}
    \begin{tikzpicture}
        [
            cell/.style = {draw, rectangle split, rectangle split parts = 3, very thick, align = center, rectangle split part fill = {white, black!20, black!20}},
            %on grid,
            node distance = 0.5cm and 0.5cm
        ]
        \node[cell] (toplevel) {Top-Level\nodepart{two}Shapes\nodepart{three}Children};
        \node[cell, below left = of toplevel] (sub1) {Sub 1\nodepart{two}Shapes\nodepart{three}Children};
        \node[cell, below right = of toplevel] (sub2) {Sub 2\nodepart{two}Shapes\nodepart{three}Children};
        \draw[very thick] (toplevel.three west) -| (sub1.north);
        \draw[very thick] (toplevel.three east) -| (sub2.north);
    \end{tikzpicture}
\end{center}
Every layout cell holds a list of shapes and a list of children (references to other layout cells).
Furthermore, layout cells can be transformed, that is translated in x and y or rotated, mirrored etc.
This affects all parts of a cell, so shapes and children are also transformed, which is just what you would expect.
Object transformation is a very cheap operation, much cheaper than operating on every single shape in a layout.
This is the reason why layout hierarchies are usually much more efficient to work on than so-called flat layouts.
How cell hierarchies are created is discussed in section~\ref{sec:hierarchies}.
In this section we will continue to look at flat layouts but still using other cells.

\subsubsection{Adding Cell Contents}
For this example, we assume that we have a cell containing some layout in a variable:
\luafilelisting[firstline = 1, lastline = 2]{code/merge_into_example.lua}
Now we want to place the contents of \luainline{cell} in \luainline{toplevel}.
The method for this is \luainline{merge_into}.
This method takes all shapes from a cell, copies them and places them in the cell that called \luainline{merge_into}.
In our example, in order to place the contents from \luainline{cell} in \luainline{toplevel}, we do the following:
\luafilelisting[widthgobble = 4, firstline = 3, lastline = 3]{code/merge_into_example.lua}
This dissolves the cell and places the content (the shapes and the children) into the toplevel cell.

\subsubsection{Moving Cells}
Now that we saw how to add cell content to other cells, the question arises how we can place this content at the correct position.
As an example, let's say we want to build a ring oscillator. Here, $N$ copies of the same inverter are placed.
The inverter has a certain width so we know how far we have to move it so that it does not overlap with the surrounding inverters.
For the example, we will place three inverters (of which we will assume that a layout is available):
\luafilelisting{code/ringoscillator.lua}
In this example, the original cell is copied three times, since every call to \luainline{translate} changes the internal state of the cell.
It is possible to do this without intermediate variables and copying:
\luafilelisting{code/ringoscillator_nocopy.lua}
Here, \luainline{translate} is called on the original cell, so the movements in x and y accumulate.
This is better in regards of processing performance, as copies of cells are expensive.

The approach of explicitly translating cells to move them to the right location works, but requires the knowledge of some parameters of the cell.
Usually these values are known, since the layout of a single inverter was also created in this cell.
However, for more abstraction it is desirable to describe these kind of layouts in a relative way.
For this, the cells should know their own width and height, so they could be placed aligned to each other in an automatic way.
There are two mechanisms in openPCells to help with these placements: anchors and alignment boxes.

\subsubsection{Cell Anchors}
In order to place cell at certain points without knowing their exact geometry, \emph{anchors} are introduced.
An anchor is a meaningful/important point of a cell and marks a location where other cells can be attached to or where wires can start/end etc.
Think of a jigsaw puzzle pieces with their tabs and blanks: Pieces are connected by placing a tab in a blank of another piece.
To come back to the example of the ring oscillator, we connect the inverters by placing the inputs on the outputs of the previous cells.
The modified example looks like this:
\luafilelisting{code/ringoscillator_anchor.lua}
The required displacement for each inverter is calculated and then applied to \luainline{translate}.
This is rather cumbersome.
OpenPCells offers a specialized function for this: \luainline{move_anchor}.
This takes a layout cell and moves it so that the specified anchor lies at the given location:
\luafilelisting{code/ringoscillator_move_anchor.lua}

\subsubsection{Alignment Boxes}

\subsection{Cell Hierarchies}\label{sec:hierarchies}
Layouts of integrated circuits usually make great use of repetition/reuse of cells.
For instance, a shift register uses the same flip flop over and over again.
Creating \emph{flat} layouts (that is, layouts without any hierarchies) for these cells can be quite resource-intense
More shapes have to be calculated by opc and the resulting layout is very likely to be larger in file size than a hierarchical one.
Therefore, opc supports hierachical layouts.
Instantiations in a cell of other cells/layouts are called \emph{children}.
They are light-weight handles to full cells and don't contain any flat shapes of their own.
As example a layout that uses a sub-cell 1000 times it only has to store 1000 handles, but not 1000 versions of the same layout.\footnote{More realistically, if the layout allows for that, an arrayed version of the sub-cell is stored.}
A layout that makes proper use of hierarchy can me multiple magnitudes faster in processing than a flat version.

Each child has a reference it points to, which is created automatically by adding a child to a cell.
As an example, let's create the following hierarchy:
\begin{center}
    \begin{tikzpicture}
        [
            cell/.style = {draw, rectangle, very thick, align = center},
            %on grid,
            node distance = 0.5cm and 0.5cm
        ]
        \node[cell] (toplevel) {Toplevel\\\emph{Toplevel}};
        \node[cell, below = of toplevel] (sub) {Sub\\\emph{Sub}};
        \node[cell, below left = of sub] (subsub1) {SubSub\\\emph{SubSub1}};
        \node[cell, below right = of sub] (subsub2) {SubSub\\\emph{SubSub2}};
        \draw[very thick] (toplevel) -- (sub);
        \draw[very thick] (sub) -- (subsub1);
        \draw[very thick] (sub) -- (subsub2);
    \end{tikzpicture}
\end{center}
The upright name shows the name of the cell (which can be re-used), the italic name is the instance name (this has to be unique).
In this example, the top-level cell instantiates another cell (sub), which in turn instantiates two other cells (subsub).
In order to create this hierarchy in code, we have to do the following steps:
First we create all cells (which are called \emph{references}):
\luafilelisting[firstline = 1, lastline = 3]{code/hierarchy_example.lua}
After that, we simply add the respective cells as children:
\luafilelisting[firstline = 4, lastline = 8]{code/hierarchy_example.lua}
It is important not to confuse the cell names here.
All functions that create proper cells (objects) such as \luainline{pcell.create_layout} or \luainline{object.create} must be supplied with a name for that cell.
Functions for adding children to objects (currently the object methods \luainline{add_child} and \luainline{add_child_array}) take an optional parameter for the instance name\footnote{This instance name is not supported by all exports. For example, GDSII has no notion of an instance name}.
If this name is not given, an automatically generated name will be used.

We can see a simple example of proper instance naming in \texttt{analog/ringoscillator.lua}.
Here, \luainline{string.format} is used to generate unique instance names for the individual inverters of a ring oscillator.
First, the inverter reference (the actual cell) is created.
This inverter is a CMOS structure with some additional wires, so the basic structure of the inverter is based on \luainline{basic/cmos}.
For brevity, the additional drawings etc. are not shown here.
\luafilelisting[widthgobble = 4, firstline = 93, lastline = 97]{../../../cells/analog/ringoscillator.lua}
Then the inverter reference (which is only generated once) can be \emph{instantiated} multiple times, which happens within a loop in this case:
\luafilelisting[widthgobble = 4, firstline = 110, lastline = 116]{../../../cells/analog/ringoscillator.lua}
The above example creates a number of inverters (depending on the parameter \luainline{numinv}).
To add a child, \luainline{add_child} is used, which expects a full object as reference and an instance name.
Here, the single reference is instantiated multiple times, therefore the instance name is modified in every call.
Additionally, the cells are left-right aligned to build a proper layout.

In the above ring oscillator example, the return value of \luainline{add_child} is stored in a table.
The return value of \luainline{add_child} is a so-called \emph{proxy object}.
This proxy object behaves like a regular object that it can be moved, rotated and its anchors can be queried (as can be seen in the example).
These operations only operate on small data structures and a very lightweight in general.
It is usually a good idea to put repeated layout structures in sub-cells for them to be re-used, as this very likely leads to a smaller and faster-processed layout.

\section{Cell Scripts}
The previous section discussed the use of pcell definitions based on the functions \luainline{parameters} and \luainline{layout}.
For re-used cells this is a good aproach, but some layouts are handled with more similarity to a stand-alone program.
For this, \emph{cell scripts} are also supported.
For the main part, they function like proper cell files, but cellscripts just describe the content of the layout function of cells.
This means that some parts are more manual, for instance the main object must be created and returned by the user.
An example cell scripts could look like this:
\begin{lualisting}
    local cell = object.create("toplevel")
    geometry.rectangle(cell, generics.metal(1), 100, 100)
    return cell
\end{lualisting}
Cell scripts have the advantage that they don't have to be placed in some path known to opc.
The layout-generation call to opc expects a (absolut or relativ to the calling path) path to the cell script, such as
\begin{shellcode}
    opc --technology opc --export gds --cellscript path/to/cell.lua
\end{shellcode}
\section{Available PCells}
In the following subsections, all available cells will be documented. The current status is rather a poor one, but work is ongoing.
\subsection{Transistor}
The transistor might be the most important cell and currently it's also definitely the most complex one. Therefore, this documentation starts with a description of
the goal. Figure \ref{fig:transistor} shows an example with all geometrical parameters, a summary of all parameters can be found in table \ref{tab:transistor}. The
cell draws a number of gates on top of an active area (with some implant/well/etc. markers).
\begin{figure}[htb]
    \centering
    \definecolor{activegreen}{RGB}{0,204,102}
    \begin{tikzpicture}
        [
            %marker/.style = {draw = yellow, pattern = dots, pattern color = yellow},
            %active/.style = {draw = activegreen, pattern = grid, pattern color = activegreen},
            %gate/.style = {draw = red, pattern = crosshatch, pattern color = red},
            %metal/.style = {draw = blue, pattern = crosshatch dots, pattern color = blue},
            marker/.style = {draw = none, fill = yellow, opacity = 0.5},
            active/.style = {draw = none, fill = activegreen},
            gate/.style = {draw = none, fill = red},
            metal/.style = {draw = none, fill = blue, opacity = 0.5},
            annotation/.style = {<->, >=stealth, very thick}
        ]
        \def\fingers{4}
        \def\flength{0.5}
        \def\fwidth{4}
        \def\fspace{2}
        \def\gtopext{1}
        \def\gbotext{1}
        \def\gatestrwidth{0.75}
        \def\sdwidth{0.8}
        \def\actext{1.0}
        % active marker
        \draw[marker] ({-0.5 * \fingers * (\flength + \fspace) - \actext}, {-0.5 * \fwidth - \actext}) rectangle
                      ({ 0.5 * \fingers * (\flength + \fspace) + \actext}, { 0.5 * \fwidth + \actext});
        % active
        \draw[active] ({-0.5 * \fingers * (\flength + \fspace)}, {-0.5 * \fwidth}) rectangle
                      ({ 0.5 * \fingers * (\flength + \fspace)}, { 0.5 * \fwidth});
        % active
        \draw[active] ({-0.5 * \fingers * (\flength + \fspace)}, {-0.5 * \fwidth}) rectangle ({0.5 * \fingers * (\flength + \fspace)}, {0.5 * \fwidth});
        % gates
        \foreach \x in {1, ..., \fingers}
        {
            \draw[gate] ({\fspace * (\x - 0.5 * (\fingers - 1) - 1) - 0.5 * \flength}, { -0.5 * \fwidth - \gbotext}) rectangle
                        ({\fspace * (\x - 0.5 * (\fingers - 1) - 1) + 0.5 * \flength}, {  0.5 * \fwidth + \gtopext});
        }
        % metal
        \draw[metal] ({-0.5 * \fingers * (\flength + \fspace)}, {-0.5 * \gatestrwidth + 0.5 * \fwidth + \gtopext}) rectangle
                     ({ 0.5 * \fingers * (\flength + \fspace)}, { 0.5 * \gatestrwidth + 0.5 * \fwidth + \gtopext});
        \draw[metal] ({-0.5 * \fingers * (\flength + \fspace)}, {-0.5 * \gatestrwidth - 0.5 * \fwidth - \gbotext}) rectangle
                     ({ 0.5 * \fingers * (\flength + \fspace)}, { 0.5 * \gatestrwidth - 0.5 * \fwidth - \gbotext});
        \foreach \x in {0, ..., \fingers}
        {
            \draw[metal] ({\fspace * (\x - 0.5 * \fingers) - 0.5 * \sdwidth}, { -0.5 * \fwidth}) rectangle
                         ({\fspace * (\x - 0.5 * \fingers) + 0.5 * \sdwidth}, {  0.5 * \fwidth});
        }
        % annotations
        \draw[annotation] ({-0.5 * \fingers * (\flength + \fspace)}, {-0.5 * \fwidth}) -- node[left] {fwidth} ({-0.5 * \fingers * (\flength + \fspace)}, {0.5 * \fwidth});
        \draw[annotation] ({\fspace * (1 - 0.5 * (\fingers - 1) - 1) - 0.5 * \flength}, {-0.25 * \fwidth}) -- node[below] {flength} ++(\flength, 0);
        \draw[annotation] ({\fspace * (1 - 0.5 * (\fingers - 1) - 1) + 0.5 * \flength}, { 0.25 * \fwidth}) -- node[below] {fspace}  ++({\fspace - \flength}, 0);
        \draw[annotation] ({\fspace * (\fingers - 0.5 * (\fingers - 1) - 1) + 0.5 * \flength}, { -0.5 * \fwidth - \gbotext}) -- node[right] {gbotext} ++(0,  \gbotext);
        \draw[annotation] ({\fspace * (\fingers - 0.5 * (\fingers - 1) - 1) + 0.5 * \flength}, {  0.5 * \fwidth + \gtopext}) -- node[right] {gtopext} ++(0, -\gbotext);
        \draw[annotation] ({\fspace * (3 - 0.5 * \fingers) - 0.5 * \sdwidth}, { 0.25 * \fwidth}) -- node[below] {sdwidth}  ++(\sdwidth, 0);
        \draw[annotation] ({ 0.5 * \fingers * (\flength + \fspace)}, 0) -- node[above] {actext} ++(\actext, 0);
    \end{tikzpicture}
    \caption{Overview of the transistor}
    \label{fig:transistor}
\end{figure}
Furthermore, it draws some metals and vias (not shown in figure \ref{fig:transistor}) in the source/drain regions and for gate contacts.

\begin{table}[htb]
    \centering
    \begin{tabular}{llc}
        \toprule
        Parameter & Meaning & Default \\
        \midrule
        channeltype     & Type of Transistor & "nmos" \\
        oxidetype       & Oxide Thickness Index & 1 \\
        vthtype         & Threshold Voltage Index & 1 \\
        fingers         & Number of Fingers& 4 \\
        fwidth          & Finger Width & 1.0 \\
        gatelength      & Finger Length & 0.15 \\
        fspace          & Space between Fingers & 0.27 \\
        actext          & Left/Right Extension of Active Area & 0.03 \\
        sdwidth         & Width of Source/Drain Metals & 0.2 \\
        sdconnwidth     & Width of Source/Drain Connection Rails Metal & 0.2 \\
        sdconnspace     & Space of Source/Drain Connection Rails Metal & 0.2 \\
        gtopext         & Gate Top Extension & 0.2 \\
        gbotext         & Gate Bottom Extension & 0.2 \\
        typext          & Implant/Well Extension around Active & 0.1 \\
        cliptop         & Clip Top Marking Layers (Implant, Well, etc.) & false \\
        clipbot         & Clip Bottom Marking Layers (Implant, Well, etc.) & false \\
        drawtopgate     & Draw Top Gate Strap & false \\
        drawbotgate     & Draw Bottom Gate Strap & false \\
        topgatestrwidth && 0.12 \\
        topgatestrext   && 1 \\
        botgatestrwidth && 0.12 \\
        botgatestrext   && 1 \\
        topgcut         & Draw Top Poly Cut & false \\
        botgcut         & Draw Bottom Poly Cut & false \\
        connectsource   & Connect all Sources together & false \\
        connectdrain    & Connect all Drains together & false\\
        \bottomrule
    \end{tabular}
    \caption{Summary of Transistor Parameters}
    \label{tab:transistor}
\end{table}

\cleardoublepage

\section{API Documentation}

\subsection{geometry Module}

\begin{APIfunc}{rectangle(cell, layer, width, height, xshift, yshift, xrep, yrep, xpitch, ypitch)}
    Create a rectangular shape with the given width and height.
    \begin{APIparameters}
        \parameter{cell}{object}
            Object in which the rectangle is created;
        \parameter{layer}{generic}
            Layer of the generated rectangle;
        \parameter{width}{integer}
            Width of the rectangle. Must be even.;
        \parameter{height}{integer}
            Height of the rectangle. Must be even.;
        \parameterdefault{xshift}{0}{integer}
            Optional shift in x direction.;
        \parameterdefault{yshift}{0}{integer}
            Optional shift in y direction.;
        \parameterdefault{xrep}{1}{integer}
            Optional number of repetitions in x direction.
            Rectangles are shifted so that an equal number is left and right.;
        \parameterdefault{yrep}{1}{integer}
            Optional number of repetitions in y direction.
            Rectangles are shifted so that an equal number is left and right.;
        \parameterdefault{xpitch}{0}{integer}
            Optional pitch in x direction, used for repetition in x.;
        \parameterdefault{ypitch}{0}{integer}
            Optional pitch in y direction, used for repetition in y.;
    \end{APIparameters}
\end{APIfunc}

\begin{APIfunc}{rectanglebltr(cell, layer, bl, tr, xrep, yrep, xpitch, ypitch)}
    Create a rectangular shape defined by the bottom-left and the top-right corner.
    \begin{APIparameters}
        \parameter{cell}{object}
            Object in which the rectangle is created;
        \parameter{layer}{generic}
            Layer of the generated rectangle;
        \parameter{bl}{point}
            Bottom-left (bl) point of the rectangle;
        \parameter{tr}{point}
            Top-right (tl) point of the rectangle;
        \parameterdefault{xrep}{1}{integer}
            Optional number of repetitions in x direction.
            Rectangles are shifted so that an equal number is left and right.;
        \parameterdefault{yrep}{1}{integer}
            Optional number of repetitions in y direction.
            Rectangles are shifted so that an equal number is left and right.;
        \parameterdefault{xpitch}{0}{integer}
            Optional pitch in x direction, used for repetition in x.;
        \parameterdefault{ypitch}{0}{integer}
            Optional pitch in y direction, used for repetition in y.;
    \end{APIparameters}
\end{APIfunc}

\subsection{Object Module}
\subsection{Shape Module}
\subsection{Pointarray Module}
\subsection{Point Module}
\end{document}

% vim: ft=tex
