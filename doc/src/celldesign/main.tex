\input{../preamble}

\title{OpenPCells}
\subtitle{PCell Design Guide and API}
\author{Patrick Kurth}

\begin{document}
\maketitle
\begin{abstract}
    \noindent This is the official documentation of the OpenPCells project.  It is split in several different files for clarity. This document provides an overview
    of the creation of PCells in the OpenPCells environment as well as a detailed API documentation.  If you are looking for a general overview of the project and
    how to use it, start with the user guide, which also contains a tutorial for getting started quickly. If you want to know more about the technical details and
    implementation notes, look into the technical documentation.
\end{abstract}

\tableofcontents

\section{PCell Creation -- Introductory Examples}
We will start this documentation by a series of examples to show the main features and API functions. The to-be-created cells will get increasingly complex to
demonstrate various features.

Every cell is defined by a function where all shapes making up the shape are described. This function gets called by the cell generation system, which passes the
main object and a table with all defined parameters. The name for this function is \luainline{layout()}. Additional functions such as \luainline{parameters()}
are also understood.

\subsection{First Example -- Simple Rectangle}
The first example is a simple rectangle of variable width and height. As mentioned, all the code for the rectangle resides in a function \luainline{layout()}.
The parameters of the cell are defined in a function \luainline{parameters()}, which is optional in theory, but since we're designing pcells, there is not much point
of leaving it out. In \luainline{layout()}, we receive the main object and the defined parameters. Here we can modify the object based on the parameters.

The simple rectangle looks like this:
\luafilelisting{code/simple_rectangle.lua}
Let's walk through this line-by-line (sort of). First, we declare the function for the parameter definition:
\luafilelisting[firstline = 2, lastline = 2]{code/simple_rectangle.lua}
In the function, we add the parameters, here we use the width and the height of the rectangle:
\luafilelisting[widthgobble=4, firstline = 3, lastline = 6]{code/simple_rectangle.lua}
We can add as many parameters as we like (\luainline{pcell.add_parameters()} accepts any number of arguments).
For every argument, the first entry in the table is the name of the parameter, the second entry is the default value.
This is the simplest form, we can supply more information for finer control.
We will see some examples of this later on.

The default value for both parameters is 100, which is a \emph{size}, meaning it has a unit. Physical/geometrical parameters like width or height are specified
in nanometers.\footnote{Well, this is not entirely sure. Only integers are allowed and the base unit is assumed to be nanometer. This is also
currently reflected for example in the GDSII export, where the scaling is done approriately. However, it is planned that this will change in the
future, making the base unit in opc arbitrary.}

This is all for the \luainline{parameters()} function, so let's move on to \luainline{layout()}.
This functions takes two arguments: the main object that will be placed in the layout and the table with parameters for the cell (which already includes any parsed arguments given before the cell creation).
\footnote{Note that the \luainline{layout()}-function actually supports three parameters, but one is not important for this discussion.}

We can name them in any way that pleases us, the common name used in all standard cells distributed by this project is \luainline{_P} (as hommage to the global
environment \luainline{_G} in lua).
Of course it is possible to \enquote{unpack} the parameters, storing them in individual variables, but for cells with many parameters this rather is a bloat.
\luafilelisting[widthgobble = 0, firstline = 10, lastline = 10]{code/simple_rectangle.lua}

Now that we have all the layout parameters, we can already create the rectangle:
\luafilelisting[widthgobble = 4, firstline = 12, lastline = 17]{code/simple_rectangle.lua}
There is a lot going on here: We use the \luainline{geometry.rectanglebltr} function to create a rectangle with two corner points (bottom-left, bl and top-right, tr).
Since we are creating shapes of IC geometry, we have to specify a layer.
But we also want to create technology-independent pcells, so there is a generics system for layers.
Right now we are just using the \luainline{generics.metal} function, which takes a single number as argument.
\luainline{generics.metal(1)} specifies the first metal (counted from silicon), you can also say something like \luainline{generics.metal(-2)}, where \luainline{-1} is the index of the highest metal.
Lastly we pass the main object as first argument to the function, which places the rectangle within this object.

This cell can now be created by calling the main program with an appropriate export and technology.
Note that there's another manual about that, so we won't get into any details here.
The simplest call would be something like (please omit the backslashed in case you type that on one line. The call did not fit one line in this document.)
\begin{shellcode}
    opc \
        --technology opc \
        --export gds \
        --cell library/simple_rectangle \
        --cellpath .
\end{shellcode}
where \shellinline{library} is a folder where the cell is placed in and is in the current working directoy.
The cell search path has to modified in this example (\shellinline{--cellpath .}), which adds the current working directory to the list of searched paths.
OpenPCells comes with pre-defined cells with known paths, but custom-made cells can be added by manipulating the search path.
This can be done in a more permanent and convenient way with the configuration file, but that is not covered here.

Now you already now how to create simple rectangles with generic layers.
As integrated circuits are mostly made up of rectangles, one can already built a surprising amount of pcells.
However, we have to discuss how we can create layers other than metals, vias and shapes with more complex outlines than rectangles.
Furthermore, to reduce complexity hierarchical layout design is also important.
We will talk about these topics in the remaining cell tutorials.

\subsection{Metal-Oxide-Metal Capacitors}
Many technologies don't have so-called metal-insulator-metal capacitors (mimcaps), so the standard way to implement capacitors is by using interdigitated metals.
Let's do that. As before, we set up the pcell. Useful parameters are the number of fingers, the width and height of the fingers and the spacing in between.
Furthermore, we shift one collection of fingers (one plate) up and the other down to separate them and connect them together.
Lastly, we also specify the width of the connecting rails and the used metals.
The shown cell is a simplified version of the actual momcap implementation in opc:
\luafilelisting[firstline = 1, lastline = 13]{code/momcap.lua}
The parameter definition also shows how you can use better names for displaying: Simply write them in parantheses.
When listing the defined parameters of a cell, the display names are used, but within the cell the regular names are significant.
The parameters are stored in a lua table and can be accessed in two ways:
\luainline{_P.fingers} and \luainline{_P["fingers"]}.
Usually, the first way is easier, but it requires the parameter name to be a valid lua identifier.
Names like \luainline{foo-bar} (with a hyphen) are not valid identifiers.
In this case, the second way would have to be used.

In \luainline{layout()} first the metals are resolved.
This makes sure that only positive integers are used (for instance, with a metal stack of five metals, the index -2 is resolved to 4).
This is done in order to have properly-defined values for the following for-loop iterating over all metals.
\luafilelisting[widthgobble = 4, firstline = 18, lastline = 19]{code/momcap.lua}
Then we can set up the loop:
\luafilelisting[widthgobble = 4, firstline = 20, lastline = 20]{code/momcap.lua}
At first, we create the rails (upper and lower):
\luafilelisting[widthgobble = 4, firstline = 22, lastline = 31]{code/momcap.lua}
Then we create the fingers separately.
A second loop represents the fingers.
Every finger has to be moved right, every second finger has to be moved up:
\luafilelisting[widthgobble = 4, firstline = 33, lastline = 41]{code/momcap.lua}

What remains is the drawing of the vias between the metals.
For this we introduce a new \luainline{geometry} function: \luainline{geometry.viabltr}.
It takes a rectangular area and creates individual cuts as well as surrounding metals.
There has to be some technology translation for this (proper layer generation as well as calculating the proper geometry of the cuts).
The details on this are not important for this discussion.
It is covered more in-depth in the technology translation manual.
For this case it is enough to know that an appropriate and manufacturable amount of via cuts is placed within this rectangular area.
Since the region is a rectangular, \luainline{geometry.viabltr} takes almost the same arguments as \luainline{geometry.rectanglebltr}.
Only the metal layer is changed into two indices for the first and the last metal of the stack.
This means that \luainline{geometry.viabltr} does \emph{not} expect a generic layer as input.
All layer creation is done by the function itself.
Furthermore, we don't have to specify the individual vias between each layer in the stack, this is resolved later by the technology translation.
For the capacitor, the vias are placed in the rails:
\luafilelisting[widthgobble = 4, firstline = 43, lastline = 54]{code/momcap.lua}

With this the pcell is almost finished, the remaining code defines so-called \emph{anchors}, which are used for relative positioning.
These will be discussed further down this document and therefore are skipped in this section.
A cell similar to this is bundled in this release of openPCells (\texttt{cells/passive/capacitor/mom.lua}).
A few optimizations and additional parameters are added, but the here shown implementation is the basic structure of this capacitor.

\subsection{Octagonal Inductor}
RF designs often require on-chip inductors, which usually are built in an octagonal shape due to angle restrictions in most technologies (no true circles or
better approximations available).
We will show how to built a differential (symmetric) octagonal inductor with a variable number of turns (integers).
We will skip some basic techniques that we already discussed a few times such as setting up the cell body, cell parameters and main object.
Look into \texttt{cells/passive/inductor/octagonal.lua} for the defined parameters.

An inductor is basically a wire (a \emph{path}) routed in a special manner, therefore we will describe the inductor as a \luainline{path}.
This is a series of points that describe a line with a certain width.
To create a path, we have to pass the points to \luainline{geometry.path}, which we will store in a \luainline{table}.
The cell for the octagonal inductor requries some calculations for the right point positions and uses some helper functions.
We won't discuss the entire cell here as some issues are not important for general advice on building cells.
The main purpose is to show how to handle points, point lists and how to draw paths.

First, some information on points:
Points are a structure with an x- and a y coordinate.
They represent absolute locations in the layout and many layout- and object-related take either a pair of x/y coordinates or a point.
Points are simply created by \luainline{point.create}, which takes two numbers for the coordinates (x comes first).
The coordinates can be queried:
\begin{lualisting}
    local pt = point.create(100, 100) -- create a point
    local x, y = pt:unwrap() -- get both x and y
    x = pt:getx() -- get only x
    y = pt:gety() -- get only y
\end{lualisting}
For some layouts, combinations of points are needed, where for instance the x-coordinate of one point should be combined with the y-coordinate of another point.
There are two ways to achieve this:
\begin{lualisting}
    -- newpt == point.create(pt1.x, pt2.y)
    local newpt = point.combine_12(pt1, pt2)
    -- newpt == point.create(pt2.x, pt1.y)
    local newpt = point.combine_21(pt1, pt2)
\end{lualisting}
Both functions do the same, they just differ on the order of their arguments.
The remaining funtions to manipulate points are given here:
\begin{lualisting}
    -- example points
    local pt1 = point.create(100, 100)
    local pt2 = point.create(20, -100)
    print(pt1 - pt2)  -- (80, 200)    -> difference
    print(-pt1)       -- (-100, -100) -> unary minus
    print(point.xaverage(pt1, pt2)) -- 60 -> average (x)
    print(point.yaverage(pt1, pt2)) -- 0 -> average (y)
    print(point.combine(pt1, pt2)) -- (60, 0) -> average (point)
    print(pt1 .. pt2) -- (100, -100)  -> point.combine_12(pt1, pt2)
\end{lualisting}
Note that there is no operator +.

Furthermore, there is a shorthand for the scalar distance in either x or y.
These also exist as version which calculate the absolute:
\begin{lualisting}
    point.xdistance(pt1, pt2)
    point.ydistance(pt1, pt2)
    point.xdistance_abs(pt1, pt2)
    point.ydistance_abs(pt1, pt2)
\end{lualisting}

Lastly, points can be compared by using \luainline{==} (as you would expect).
This compares the content of points, not the actual objects.
This means that points are considered equal when their coordinates are the same.

\bigskip

Let us get back to the inductor.
It has the number of turns as a parameter.
For every turn the points for one half of the turn are calculated, then the path is drawn twice, one time with a mirrored version of the points.
\luafilelisting[widthgobble = 8, firstline = 42, lastline = 43]{../../../cells/passive/inductor/octagonal.lua}
The points are stored in the \luainline{table pathpts}, \luainline{util.make_insert_xy} is a helper function, that returns a function that appends/prepends points to an array. It's purpose is to simplify code, one
might as well just use \luainline{table.insert}.

Then we add points:
\luafilelisting[widthgobble = 8, firstline = 34, lastline = 39]{../../../cells/passive/inductor/octagonal.lua}
Now the cell adds points for the underpass (for the crossing of both sides) as well as the extension for the connections.
This discussion will skip these parts as they don't add any value for learning about \luainline{geometry.path}.
The entire code generating the path points is a bit complex and involves some trigonometric calculations.

After the points are assembled, we can create the path. The cell only draws half of the inductor, so we draw the path twice, one time with mirrored points (notice
\luainline{util.xmirror(pathpts)} in the second line):
\luafilelisting[widthgobble = 8, firstline = 89, lastline = 90]{../../../cells/passive/inductor/octagonal.lua}
The \luainline{geometry.path} function takes five arguments: the cell, the layer, the points of the path, the width and whether to use a miter- or a bevel-join. Bevel-join is
default, so \luainline{true} is specified for a miter-join.
The layers where created earlier as
\luafilelisting[widthgobble = 4, firstline = 20, lastline = 21]{../../../cells/passive/inductor/octagonal.lua}

\subsection{Integrating Other Cell Layouts}
Layouts of integrated circuits can get very complex quite easily.
The typical way to deal with high complexity is by building individual cell layouts and placing them in the appropriate location.
Partitioning and hierarchy are good tools to tackle circuit complexity.
In essence: Divide and conquer.
Therefore, this section will discuss how to integrate existing cell layouts and how to find the correct location by relative placement.
But first an introduction to how openPCells represents layouts will be given, as this will be important to understand advanced topics.

\subsubsection{Representation of Hierarchical Layouts}
In integrated circuits, layouts are in general represented by a mixture of instantiations of other layouts as well as shapes (such as rectangles,
polygons, paths, etc.).
Typically, there is a root cell for the layout, which is called top-level.
The top-level layout then has some shapes as well as instantiations of other layouts, which in turn have shapes and Instantiations of other layouts and so on.
This is quite similar to a filesystem, where you have a root directory with sub-directories, where every directory can (but not necessarily) contain files that are not directories.
The following picture shows an example of this:
\begin{center}
    \begin{tikzpicture}
        [
            cell/.style = {draw, rectangle split, rectangle split parts = 3, very thick, align = center, rectangle split part fill = {white, black!20, black!20}},
            %on grid,
            node distance = 0.5cm and 0.5cm
        ]
        \node[cell] (toplevel) {Top-Level\nodepart{two}Shapes\nodepart{three}Children};
        \node[cell, below left = of toplevel] (sub1) {Sub 1\nodepart{two}Shapes\nodepart{three}Children};
        \node[cell, below right = of toplevel] (sub2) {Sub 2\nodepart{two}Shapes\nodepart{three}Children};
        \draw[very thick] (toplevel.three west) -| (sub1.north);
        \draw[very thick] (toplevel.three east) -| (sub2.north);
    \end{tikzpicture}
\end{center}
Every layout cell holds a list of shapes and a list of children (references to other layout cells).
Furthermore, layout cells can be transformed, that is translated in x and y or rotated, mirrored etc.
This affects all parts of a cell, so shapes and children are also transformed, which is just what you would expect.
Object transformation is a very cheap operation, much cheaper than operating on every single shape in a layout.
This is the reason why layout hierarchies are usually much more efficient to work on than so-called flat layouts.
How cell hierarchies are created is discussed in section~\ref{sec:hierarchies}.
In this section we will continue to look at flat layouts but still using other cells.

\subsubsection{Adding Cell Contents}
For this example, we assume that we have a cell containing some layout in a variable:
\luafilelisting[firstline = 1, lastline = 2]{code/merge_into_example.lua}
Now we want to place the contents of \luainline{cell} in \luainline{toplevel}.
The method for this is \luainline{merge_into}.
This method takes all shapes from a cell, copies them and places them in the cell that called \luainline{merge_into}.
In our example, in order to place the contents from \luainline{cell} in \luainline{toplevel}, we do the following:
\luafilelisting[widthgobble = 4, firstline = 3, lastline = 3]{code/merge_into_example.lua}
This dissolves the cell and places the content (the shapes and the children) into the toplevel cell.

\subsubsection{Moving Cells}
Now that we saw how to add cell content to other cells, the question arises how we can place this content at the correct position.
As an example, let's say we want to build a ring oscillator. Here, $N$ copies of the same inverter are placed.
The inverter has a certain width so we know how far we have to move it so that it does not overlap with the surrounding inverters.
For the example, we will place three inverters (of which we will assume that a layout is available):
\luafilelisting{code/ringoscillator.lua}
In this example, the original cell is copied three times, since every call to \luainline{translate} changes the internal state of the cell.
It is possible to do this without intermediate variables and copying:
\luafilelisting{code/ringoscillator_nocopy.lua}
Here, \luainline{translate} is called on the original cell, so the movements in x and y accumulate.
This is better in regards of processing performance, as copies of cells are expensive.

The approach of explicitly translating cells to move them to the right location works, but requires the knowledge of some parameters of the cell.
Usually these values are known, since the layout of a single inverter was also created in this cell.
However, for more abstraction it is desirable to describe these kind of layouts in a relative way.
For this, the cells should know their own width and height, so they could be placed aligned to each other in an automatic way.
There are two mechanisms in openPCells to help with these placements: anchors and alignment boxes.

\subsubsection{Cell Anchors}
In order to place cells at certain points without knowing their exact geometry, \emph{anchors} are introduced.
An anchor is a meaningful/important point of a cell and marks a location where other cells can be attached to or where wires can start/end etc.
Think of a jigsaw puzzle pieces with their tabs and blanks: Pieces are connected by placing a tab in a blank of another piece.
To come back to the example of the ring oscillator, we connect the inverters by placing the inputs on the outputs of the previous cells.
The modified example looks like this:
\luafilelisting{code/ringoscillator_anchor.lua}
The required displacement for each inverter is calculated and then applied to \luainline{translate}.
This is rather cumbersome.
OpenPCells offers a specialized function for this: \luainline{object.move_point}.
This takes a layout cell and moves it so that the specified point lies at the given location.
We can provide an anchor as source point and another anchor as target:
\luafilelisting{code/ringoscillator_move_point.lua}
The function \luainline{move_point} takes arbitrary points as arguments.
Essentially, it moves the specified cell by the difference of the two points.
The interface is a bit akward, because moving cells by their own anchors (a common use case) requires typing out the object name twice.
This is due to the generic nature of \luainline{move_point}.
A more specialized and powerful approach is provided by \emph{area anchors}, as demonstrated in the next section.

\subsubsection{Area Anchors}
As we have seen, object can store specific points as \emph{anchors}.
There is another anchor methodology: \emph{area anchors}.
An area anchor is similar to a regular anchor, but it makes up a rectangular area (defined by the bottom-left and the top-right).
These anchors can be queried just like regular anchors (but with \luainline{get_area_anchor} instead of \luainline{get_anchor}).
Their two main properties and advantages over regular anchors are that they never change their orientation and cells can be abutted/aligned in various ways with them.

To clarify on the point of orientation:
Imagine a rectangular area was made up of two regular anchors.
Once the object containing these anchors is rotated by, say, 90 degrees, the bottom-left anchor is no longer the bottom left.
Flipping an object for instance reverses the order of these anchors.
Area anchors on the other hand always describe, as the name implies, areas.
Therefore it does not matter which orientation the respective object has, the bottom-left anchor will always be bottom-left.
This enables much simpler approaches, as cell code does not need to keep track of which object is rotated and which one is not.

The second advantage of area anchors are the various abutment/alignment methods for objects.
For instance, the cell \shellinline{basic/mosfet} defines area anchors for every source/drain region.
Two devices can be simply abutted by calling
\begin{lualisting}
    mosfet1:align_area_anchor("sourcedrain1", mosfet2, "sourcedrain-1")
\end{lualisting}
This places \luainline{mosfet1} left of \luainline{mosfet2} (as source/drain regions are counted positive beginning from the left and negative beginning from the right).
Without area anchors (and hypothetical anchors for the corner points of the source/drain regions), the call would look like this:
\begin{lualisting}
    mosfet1:move_point(mosfet1:get_anchor("sourcedrain1bl"), mosfet2:get_anchor("sourcedrain-1bl"))
\end{lualisting}
But this code would break if one of the devices was flipped (for instance to place a gate contact on the top and one on the bottom).

Area anchors can be aligned or abutted with the top/bottom/left/right edge as reference.
These functions (e.g. \luainline{abut_area_anchor_left}) only change the corresponding coordinates, that is abutting/alignment for left/right only changes x, top/bottom only changes y.
For abutting the qualifier is for the to-be-abutted area anchor, which means that (for instance) \luainline{abut_area_anchor_left} moves the respective object so that the given area anchor lies left of the reference anchor.

\subsubsection{Alignment Boxes}
Alignment boxes are tighly connected to area anchors.
They provide the same concept but in a simpler and less flexible way.
Every cell has at most one alignment box.
With this, it can be aligned/abutted to other cells.
This makes the most sense for compatible cells (like mosfets and other mosfets).

The above example of abutting two mosfets with area anchors can be re-written as:
\begin{lualisting}
    mosfet1:abut_right(mosfet2)
    mosfet1:align_top(mosfet2)
\end{lualisting}
This requires two calls, as every abut/align function with alignment boxes only changes either the x- or the y-coordinate.
However, it is anchor-agnostic and therefore does not require any anchors names for the alignment.
This also allows writing code that just assembles blocks of layout cells without knowing any anchor names.
This code then works for any cells that has an alignment box.
This kind of code actually exists in the placement module, which is mainly intended for digital layout.

\subsection{Cell Hierarchies}\label{sec:hierarchies}
Layouts of integrated circuits usually make great use of repetition/reuse of cells.
For instance, a shift register uses the same flip flop over and over again.
Creating \emph{flat} layouts (that is, layouts without any hierarchies) for these cells can be quite resource-intense.
More shapes have to be calculated by opc and the resulting layout is very likely to be larger in file size than a hierarchical one.
Therefore, opc supports hierachical layouts.
Instantiations in a cell of other cells/layouts are called \emph{children}.
They are light-weight handles to full cells and don't contain any flat shapes of their own.
As example a layout that uses a sub-cell 1000 times it only has to store 1000 handles, but not 1000 versions of the same layout.\footnote{More realistically, if the layout allows for that, an arrayed version of the sub-cell is stored.}
A layout that makes proper use of hierarchy can me multiple magnitudes faster in processing than a flat version.

Each child has a reference it points to, which is created automatically by adding a child to a cell.
As an example, let's create the following hierarchy:
\begin{center}
    \begin{tikzpicture}
        [
            cell/.style = {draw, rectangle, very thick, align = center},
            %on grid,
            node distance = 0.5cm and 0.5cm
        ]
        \node[cell] (toplevel) {Toplevel\\\emph{Toplevel}};
        \node[cell, below = of toplevel] (sub) {Sub\\\emph{Sub}};
        \node[cell, below left = of sub] (subsub1) {SubSub\\\emph{SubSub1}};
        \node[cell, below right = of sub] (subsub2) {SubSub\\\emph{SubSub2}};
        \draw[very thick] (toplevel) -- (sub);
        \draw[very thick] (sub) -- (subsub1);
        \draw[very thick] (sub) -- (subsub2);
    \end{tikzpicture}
\end{center}
The upright name shows the name of the cell (which can be re-used), the italic name is the instance name (this has to be unique).
In this example, the top-level cell instantiates another cell (sub), which in turn instantiates two other cells (subsub).
In order to create this hierarchy in code, we have to do the following steps:
First we create all cells (which are called \emph{references}):
\luafilelisting[firstline = 1, lastline = 3]{code/hierarchy_example.lua}
After that, we simply add the respective cells as children:
\luafilelisting[firstline = 4, lastline = 8]{code/hierarchy_example.lua}
It is important not to confuse the cell names here.
All functions that create proper cells (objects) such as \luainline{pcell.create_layout} or \luainline{object.create} must be supplied with a name for that cell.
Functions for adding children to objects (currently the object methods \luainline{add_child} and \luainline{add_child_array}) take an optional parameter for the instance name\footnote{This instance name is not supported by all exports. For example, GDSII has no notion of an instance name}.
If this name is not given, an automatically generated name will be used.

We can see a simple example of proper instance naming in \texttt{analog/ringoscillator.lua}.
Here, \luainline{string.format} is used to generate unique instance names for the individual inverters of a ring oscillator.
First, the inverter reference (the actual cell) is created.
This inverter is a CMOS structure with some additional wires, so the basic structure of the inverter is based on \luainline{basic/cmos}.
For brevity, the additional drawings etc. are not shown here.
\luafilelisting[widthgobble = 4, firstline = 93, lastline = 97]{../../../cells/analog/ringoscillator.lua}
Then the inverter reference (which is only generated once) can be \emph{instantiated} multiple times, which happens within a loop in this case:
\luafilelisting[widthgobble = 4, firstline = 110, lastline = 116]{../../../cells/analog/ringoscillator.lua}
The above example creates a number of inverters (depending on the parameter \luainline{numinv}).
To add a child, \luainline{add_child} is used, which expects a full object as reference and an instance name.
Here, the single reference is instantiated multiple times, therefore the instance name is modified in every call.
Additionally, the cells are left-right aligned to build a proper layout.

In the above ring oscillator example, the return value of \luainline{add_child} is stored in a table.
The return value of \luainline{add_child} is a so-called \emph{proxy object}.
This proxy object behaves like a regular object that it can be moved, rotated and its anchors can be queried (as can be seen in the example).
These operations only operate on small data structures and a very lightweight in general.
It is usually a good idea to put repeated layout structures in sub-cells for them to be re-used, as this very likely leads to a smaller and faster-processed layout.

\section{Cell Scripts}
The previous section discussed the use of pcell definitions based on the functions \luainline{parameters} and \luainline{layout}.
For re-used cells this is a good aproach, but some layouts are handled with more similarity to a stand-alone program.
For this, \emph{cell scripts} are also supported.
For the main part, they function like proper cell files, but cellscripts just describe the content of the layout function of cells.
This means that some parts are more manual, for instance the main object must be created and returned by the user.
An example cell scripts could look like this:
\begin{lualisting}
    local cell = object.create("toplevel")
    geometry.rectangle(cell, generics.metal(1), 100, 100)
    return cell
\end{lualisting}
Cell scripts have the advantage that they don't have to be placed in some path known to opc.
The layout-generation call to opc expects a (absolut or relativ to the calling path) path to the cell script, such as
\begin{shellcode}
    opc --technology opc --export gds --cellscript path/to/cell.lua
\end{shellcode}

\section{Available PCells}
In the following subsections, all available cells will be documented. The current status is rather a poor one, but work is ongoing.

\subsection{basic/mosfet}
The mosfet device might be the most important cell and currently it's also definitely the most complex one.
Therefore, this documentation starts with a description of the goal.
Figure \ref{fig:transistor} shows an example with all geometrical parameters, a summary of all parameters can be found in table \ref{tab:transistor}.
The cell draws a number of gates on top of an active area (with some implant/well/etc. markers).
\begin{figure}[htb]
    \centering
    \definecolor{activegreen}{RGB}{0,204,102}
    \begin{tikzpicture}
        [
            %marker/.style = {draw = yellow, pattern = dots, pattern color = yellow},
            %active/.style = {draw = activegreen, pattern = grid, pattern color = activegreen},
            %gate/.style = {draw = red, pattern = crosshatch, pattern color = red},
            %metal/.style = {draw = blue, pattern = crosshatch dots, pattern color = blue},
            marker/.style = {draw = none, fill = yellow, opacity = 0.5},
            active/.style = {draw = none, fill = activegreen},
            gate/.style = {draw = none, fill = red},
            metal/.style = {draw = none, fill = blue, opacity = 0.5},
            annotation/.style = {<->, >=stealth, very thick}
        ]
        \def\fingers{4}
        \def\flength{0.5}
        \def\fwidth{4}
        \def\fspace{2}
        \def\gtopext{1}
        \def\gbotext{1}
        \def\gatestrwidth{0.75}
        \def\sdwidth{0.8}
        \def\actext{1.0}
        % active marker
        \draw[marker] ({-0.5 * \fingers * (\flength + \fspace) - \actext}, {-0.5 * \fwidth - \actext}) rectangle
                      ({ 0.5 * \fingers * (\flength + \fspace) + \actext}, { 0.5 * \fwidth + \actext});
        % active
        \draw[active] ({-0.5 * \fingers * (\flength + \fspace)}, {-0.5 * \fwidth}) rectangle
                      ({ 0.5 * \fingers * (\flength + \fspace)}, { 0.5 * \fwidth});
        % active
        \draw[active] ({-0.5 * \fingers * (\flength + \fspace)}, {-0.5 * \fwidth}) rectangle ({0.5 * \fingers * (\flength + \fspace)}, {0.5 * \fwidth});
        % gates
        \foreach \x in {1, ..., \fingers}
        {
            \draw[gate] ({\fspace * (\x - 0.5 * (\fingers - 1) - 1) - 0.5 * \flength}, { -0.5 * \fwidth - \gbotext}) rectangle
                        ({\fspace * (\x - 0.5 * (\fingers - 1) - 1) + 0.5 * \flength}, {  0.5 * \fwidth + \gtopext});
        }
        % metal
        \draw[metal] ({-0.5 * \fingers * (\flength + \fspace)}, {-0.5 * \gatestrwidth + 0.5 * \fwidth + \gtopext}) rectangle
                     ({ 0.5 * \fingers * (\flength + \fspace)}, { 0.5 * \gatestrwidth + 0.5 * \fwidth + \gtopext});
        \draw[metal] ({-0.5 * \fingers * (\flength + \fspace)}, {-0.5 * \gatestrwidth - 0.5 * \fwidth - \gbotext}) rectangle
                     ({ 0.5 * \fingers * (\flength + \fspace)}, { 0.5 * \gatestrwidth - 0.5 * \fwidth - \gbotext});
        \foreach \x in {0, ..., \fingers}
        {
            \draw[metal] ({\fspace * (\x - 0.5 * \fingers) - 0.5 * \sdwidth}, { -0.5 * \fwidth}) rectangle
                         ({\fspace * (\x - 0.5 * \fingers) + 0.5 * \sdwidth}, {  0.5 * \fwidth});
        }
        % annotations
        \draw[annotation] ({-0.5 * \fingers * (\flength + \fspace)}, {-0.5 * \fwidth}) -- node[left] {fwidth} ({-0.5 * \fingers * (\flength + \fspace)}, {0.5 * \fwidth});
        \draw[annotation] ({\fspace * (1 - 0.5 * (\fingers - 1) - 1) - 0.5 * \flength}, {-0.25 * \fwidth}) -- node[below] {flength} ++(\flength, 0);
        \draw[annotation] ({\fspace * (1 - 0.5 * (\fingers - 1) - 1) + 0.5 * \flength}, { 0.25 * \fwidth}) -- node[below] {fspace}  ++({\fspace - \flength}, 0);
        \draw[annotation] ({\fspace * (\fingers - 0.5 * (\fingers - 1) - 1) + 0.5 * \flength}, { -0.5 * \fwidth - \gbotext}) -- node[right] {gbotext} ++(0,  \gbotext);
        \draw[annotation] ({\fspace * (\fingers - 0.5 * (\fingers - 1) - 1) + 0.5 * \flength}, {  0.5 * \fwidth + \gtopext}) -- node[right] {gtopext} ++(0, -\gbotext);
        \draw[annotation] ({\fspace * (3 - 0.5 * \fingers) - 0.5 * \sdwidth}, { 0.25 * \fwidth}) -- node[below] {sdwidth}  ++(\sdwidth, 0);
        \draw[annotation] ({ 0.5 * \fingers * (\flength + \fspace)}, 0) -- node[above] {actext} ++(\actext, 0);
    \end{tikzpicture}
    \caption{Overview of the transistor}
    \label{fig:transistor}
\end{figure}
Furthermore, it draws some metals and vias (not shown in figure \ref{fig:transistor}) in the source/drain regions and for gate contacts.

\subsection{Gate Parameter}
The gates are controlled by the number of fingers, the gate length and space as well as the finger width.

\begin{table}[htb]
    \centering
    \begin{tabular}{llc}
        \toprule
        Parameter & Meaning & Default \\
        \midrule
        channeltype     & Type of Transistor & "nmos" \\
        oxidetype       & Oxide Thickness Index & 1 \\
        vthtype         & Threshold Voltage Index & 1 \\
        fingers         & Number of Fingers& 4 \\
        fwidth          & Finger Width & 1.0 \\
        gatelength      & Finger Length & 0.15 \\
        fspace          & Space between Fingers & 0.27 \\
        actext          & Left/Right Extension of Active Area & 0.03 \\
        sdwidth         & Width of Source/Drain Metals & 0.2 \\
        sdconnwidth     & Width of Source/Drain Connection Rails Metal & 0.2 \\
        sdconnspace     & Space of Source/Drain Connection Rails Metal & 0.2 \\
        gtopext         & Gate Top Extension & 0.2 \\
        gbotext         & Gate Bottom Extension & 0.2 \\
        typext          & Implant/Well Extension around Active & 0.1 \\
        cliptop         & Clip Top Marking Layers (Implant, Well, etc.) & false \\
        clipbot         & Clip Bottom Marking Layers (Implant, Well, etc.) & false \\
        drawtopgate     & Draw Top Gate Strap & false \\
        drawbotgate     & Draw Bottom Gate Strap & false \\
        topgatestrwidth && 0.12 \\
        topgatestrext   && 1 \\
        botgatestrwidth && 0.12 \\
        botgatestrext   && 1 \\
        topgcut         & Draw Top Poly Cut & false \\
        botgcut         & Draw Bottom Poly Cut & false \\
        connectsource   & Connect all Sources together & false \\
        connectdrain    & Connect all Drains together & false\\
        \bottomrule
    \end{tabular}
    \caption{Summary of Transistor Parameters}
    \label{tab:transistor}
\end{table}

\cleardoublepage

\section{API Documentation}

The following section documents all available API functions for layout creation and manipulation.
At the current time, it is far from complete.
More up-to-date API documentation can be found by using opc directly with the command-line options \shellinline{--api-search}, \shellinline{--api-list} and \shellinline{--api-help}.

\subsection{curve Module}
\begin{APIfunc}{curve.arcto(startangle, endangle, radius, clockwise)}
    create an arc segment for a curve
    \begin{APIparameters}
        \parameter{startangle}{number}
            start angle of the line segment;
        \parameter{endangle}{number}
            end angle of the line segment;
        \parameter{radius}{integer}
            radius of the line segment;
        \parameter{clockwise}{boolean}
            flag if arc is drawn clock-wise or counter-clock-wise;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{curve.cubicto(ctp1, ctp2, endpt)}
    create a cubic bezier segment for a curve
    \begin{APIparameters}
        \parameter{ctp1}{point}
            first control point;
        \parameter{ctp2}{point}
            second control point;
        \parameter{endpt}{point}
            destination point of the cubic bezier segment;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{curve.lineto(point)}
    create a line segment for a curve
    \begin{APIparameters}
        \parameter{point}{point}
            destination point of the line segment;
    \end{APIparameters}
\end{APIfunc}
\subsection{generics Module}
\begin{APIfunc}{generics.contact(region)}
    create a generic layer representing a contact. This does not calculate the right size for the contact cuts. This function is rarely used directly. Contact cuts are generated by geometry.contact[bltr]. If you are using this function as a user, it is likely you are doing something wrong
    \begin{APIparameters}
        \parameter{region}{string}
            region which should be contacted. Possible values: "sourcedrain", "gate" and "active";
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{generics.implant(polarity)}
    Create a generic layer representing MOSFET source/drain implant polarity
    \begin{APIparameters}
        \parameter{polarity}{string}
            identifier for the type (polarity) of the implant. Can be "n" or "p";
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{generics.metal(index)}
    create a generic layer representing a metal. Metals are identified by numeric indices, where 1 denotes the first metal, 2 the second one etc. Metals can also be identified by negative indicies, where -1 denotes the top-most metal, -2 the metal below that etc.
    \begin{APIparameters}
        \parameter{index}{integer}
            metal index;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{generics.metalexclude(index)}
    create a generic layer representing a metal exclude where automatic filling is blocked. Metals are identified by numeric indices, where 1 denotes the first metal, 2 the second one etc. Metals can also be identified by negative indicies, where -1 denotes the top-most metal, -2 the metal below that etc.
    \begin{APIparameters}
        \parameter{index}{integer}
            metal index;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{generics.metalfill(index)}
    create a generic layer representing a metal fill. Some technologies have special layer for metal fillings, but technology files can also map these to the same layers as generics.metal(). Metals are identified by numeric indices, where 1 denotes the first metal, 2 the second one etc. Metals can also be identified by negative indicies, where -1 denotes the top-most metal, -2 the metal below that etc.
    \begin{APIparameters}
        \parameter{index}{integer}
            metal index;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{generics.metalport(index)}
    create a generic layer representing a metal port. Metals are identified by numeric indices, where 1 denotes the first metal, 2 the second one etc. Metals can also be identified by negative indicies, where -1 denotes the top-most metal, -2 the metal below that etc.
    \begin{APIparameters}
        \parameter{index}{integer}
            metal index;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{generics.mptmetal(index, maskindex)}
    create a generic layer representing a metal with multiple-patterning information. Metals are identified by numeric indices, where 1 denotes the first metal, 2 the second one etc. Metals can also be identified by negative indicies, where -1 denotes the top-most metal, -2 the metal below that etc. The mask information is a numeric indix starting at 1. The number of available masks for the respective metal can be querid by technology.multiple\_patterning\_number(metalnumber). If a metal is a mpt metal can be queried by technology.has\_multiple\_patterning(metalnumber)
    \begin{APIparameters}
        \parameter{index}{integer}
            metal index;
        \parameter{maskindex}{integer}
            mask index;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{generics.mptmetalfill(index, maskindex)}
    create a generic layer representing a metal fill shape with multiple-patterning information. Some technologies have special layer for metal fillings, but technology files can also map these to the same layers as generics.metal(). Metals are identified by numeric indices, where 1 denotes the first metal, 2 the second one etc. Metals can also be identified by negative indicies, where -1 denotes the top-most metal, -2 the metal below that etc. The mask information is a numeric indix starting at 1. The number of available masks for the respective metal can be querid by technology.multiple\_patterning\_number(metalnumber). If a metal is a mpt metal can be queried by technology.has\_multiple\_patterning(metalnumber)
    \begin{APIparameters}
        \parameter{index}{integer}
            metal index;
        \parameter{maskindex}{integer}
            mask index;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{generics.other(identifier)}
    create a generic layer representing 'something else'. This is for layers that do not need special processing, such as "gate"
    \begin{APIparameters}
        \parameter{identifier}{string}
            layer identifier;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{generics.otherport(identifier)}
    create a generic layer representing a port for 'something else'. This is for layers that do not need special processing, such as "gate"
    \begin{APIparameters}
        \parameter{identifier}{string}
            layer identifier;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{generics.outline()}
    create a generic layer representing a block outline
    \begin{APIparameters}
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{generics.oxide(index)}
    create a generic layer representing a marking layer for MOSFET gate oxide thickness (e.g. for core or I/O devices)
    \begin{APIparameters}
        \parameter{index}{integer}
            oxide thickness index. Conventionally starts with 1, but depends on the technology mapping;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{generics.premapped(name, entries)}
    Create a non-generic layer from specific layer data for a certain technology. The entries table should contain one table per supported export. The supplied key-value pairs in this table must match the key-value pairs that are expected by the export
    \begin{APIparameters}
        \parameter{name}{string}
            layer name. Can be nil;
        \parameter{entries}{table}
            key-value pairs for the entries;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{generics.special()}
    Create a 'special' layer. This is used to mark certain things in layouts (usually for debugging, like anchors or alignment boxes). This is not intended to translate to any meaningful layer for fabrication
    \begin{APIparameters}
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{generics.viacut(m1index, m2index)}
    create a generic layer representing a via cut. This does not calculate the right size for the via cuts. This function is rarely used directly. Via cuts are generated by geometry.via[bltr]. If you are using this function as a user, it is likely you are doing something wrong
    \begin{APIparameters}
        \parameter{m1index}{integer}
            first metal index;
        \parameter{m2index}{integer}
            second metal index;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{generics.vthtype(index)}
    Create a generic layer representing MOSFET source/drain threshold voltage marking layers
    \begin{APIparameters}
        \parameter{index}{integer}
            threshold voltage marking layer index. Conventionally starts with 1, but depends on the technology mapping;
    \end{APIparameters}
\end{APIfunc}
\subsection{geometry Module}
\begin{APIfunc}{geometry.rectanglebltr(cell, layer, bl, tr)}
    Create a rectangular shape with the given corner points in cell
    \begin{APIparameters}
        \parameter{cell}{object}
            Object in which the rectangle is created;
        \parameter{layer}{generics}
            Layer of the generated rectangular shape;
        \parameter{bl}{point}
            Bottom-left point of the generated rectangular shape;
        \parameter{tr}{point}
            Top-right point of the generated rectangular shape;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{geometry.rectangleblwh(cell, layer, bl, width, height)}
    Create a rectangular shape with the given bottom-left corner point and the width and height in cell
    \begin{APIparameters}
        \parameter{cell}{object}
            Object in which the rectangle is created;
        \parameter{layer}{generics}
            Layer of the generated rectangular shape;
        \parameter{bl}{point}
            Bottom-left point of the generated rectangular shape;
        \parameter{width}{integer}
            Width of the rectangular shape;
        \parameter{height}{integer}
            Height of the rectangular shape;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{geometry.rectanglepoints(cell, layer, pt1, pt2)}
    Create a rectangular shape with the given corner points in cell. Similar to geometry.rectanglebltr, but any of the corner points can be given in any order
    \begin{APIparameters}
        \parameter{cell}{object}
            Object in which the rectangle is created;
        \parameter{layer}{generics}
            Layer of the generated rectangular shape;
        \parameter{pt1}{point}
            First corner point of the generated rectangular shape;
        \parameter{pt2}{point}
            Second corner point of the generated rectangular shape;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{geometry.rectanglepath(cell, layer, pt1, pt2, width, extension)}
    Create a rectangular shape that is defined by its path-like endpoints. This function behaves like geometry.path, but takes only two points, not a list of points. This function likely will be removed in the future, use geometry.rectanglebltr or geometry.rectanglepoints
    \begin{APIparameters}
        \parameter{cell}{object}
            Object in which the rectangle is created;
        \parameter{layer}{generics}
            Layer of the generated rectangular shape;
        \parameter{pt1}{point}
            First path point of the generated rectangular shape;
        \parameter{pt2}{point}
            Second path point of the generated rectangular shape;
        \parameter{width}{integer}
            Width of the path-like shape;
        \parameter{extension}{table}
            optional table argument containing the start/end extensions;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{geometry.rectanglearray(cell, layer, width, height, xshift, yshift, xrep, yrep, xpitch, ypitch)}
    Create an array of rectangles with the given width, height, repetition and pitch in cell
    \begin{APIparameters}
        \parameter{cell}{object}
            Object in which the rectangle is created;
        \parameter{layer}{generics}
            Layer of the generated rectangular shape;
        \parameter{width}{integer}
            Width of the generated rectangular shape;
        \parameter{height}{integer}
            Height of the generated rectangular shape;
        \parameter{xshift}{integer}
            Number of repetitions in x direction. The Rectangles are shifted so that an equal number is above and below;
        \parameter{yshift}{integer}
            Number of repetitions in y direction. The Rectangles are shifted so that an equal number is above and below;
        \parameter{xrep}{integer}
            Number of repetitions in x direction. The Rectangles are shifted so that an equal number is above and below;
        \parameter{yrep}{integer}
            Number of repetitions in y direction. The Rectangles are shifted so that an equal number is above and below;
        \parameter{xpitch}{integer}
            Pitch in x direction, used for repetition in x;
        \parameter{ypitch}{integer}
            Pitch in y direction, used for repetition in y;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{geometry.slotted\_rectangle(cell, layer, bl, tr, slotwidth, slotheight, slotxspace, slotxspace, slotedgexspace, slotedgeyspace)}
    Create a rectangle with slotting
    \begin{APIparameters}
        \parameter{cell}{object}
            Object in which the rectangle is created;
        \parameter{layer}{generics}
            Layer of the generated rectangular shape;
        \parameter{bl}{point}
            bottom-left point of rectangular area;
        \parameter{tr}{point}
            top-right point of rectangular area;
        \parameter{slotwidth}{integer}
            Width of the created slots (space in x-direction between the shapes);
        \parameter{slotheight}{integer}
            Height of the created slots (space in y-direction between the shapes);
        \parameter{slotxspace}{integer}
            Width of the regions between the slots;
        \parameter{slotxspace}{integer}
            Height of the regions between the slots;
        \parameter{slotedgexspace}{integer}
            Minimum width of the edge regions (they can be larger than this value);
        \parameter{slotedgeyspace}{integer}
            Minimum height of the edge regions (they can be larger than this value);
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{geometry.rectanglevlines(cell, layer, pt1, pt2, numlines, ratio)}
    Fill a rectangular area with vertical lines with a given ratio between width and spacing
    \begin{APIparameters}
        \parameter{cell}{object}
            Object in which the rectangle is created;
        \parameter{layer}{generics}
            Layer of the generated rectangular shape;
        \parameter{pt1}{point}
            First corner point of the target area;
        \parameter{pt2}{point}
            Second corner point of the target area;
        \parameter{numlines}{integer}
            Number of lines to be generated;
        \parameter{ratio}{number}
            Ratio between width and spacing of lines;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{geometry.rectanglevlines\_width\_space(cell, layer, pt1, pt2, width, space)}
    Fill a rectangular area with vertical lines with the given width and spacing. The given numbers are only targets, in some cases they can't be matched exactly.
    \begin{APIparameters}
        \parameter{cell}{object}
            Object in which the rectangle is created;
        \parameter{layer}{generics}
            Layer of the generated rectangular shape;
        \parameter{pt1}{point}
            First corner point of the target area;
        \parameter{pt2}{point}
            Second corner point of the target area;
        \parameter{width}{integer}
            Width target of lines to be generated;
        \parameter{space}{integer}
            Space target between lines to be generated;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{geometry.rectanglevlines\_settings(cell, layer, pt1, pt2, numlines, ratio)}
    Calculate the geometries of vertical lines to fill a rectangular area with a given ratio between width and spacing. This function is like geometry.rectanglevlines, but it does not actually create the lines. It return the width, heigh, space, offset and number of lines. These parameters can then be used to call geometry.rectanglearray. This function is useful if the parameters of the lines are required for further layout functions like placing vias.
    \begin{APIparameters}
        \parameter{cell}{object}
            Object in which the rectangle is created;
        \parameter{layer}{generics}
            Layer of the generated rectangular shape;
        \parameter{pt1}{point}
            First corner point of the target area;
        \parameter{pt2}{point}
            Second corner point of the target area;
        \parameter{numlines}{integer}
            Number of lines to be generated;
        \parameter{ratio}{number}
            Ratio between width and spacing of lines;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{geometry.rectanglevlines\_width\_space\_settings(cell, layer, pt1, pt2, width, space)}
    Calculate the geometries of vertical lines to fill a rectangular area with a given width and spacing. This function is like geometry.rectanglevlines\_width\_space, but it does not actually create the lines. It return the width, heigh, space, offset and number of lines. These parameters can then be used to call geometry.rectanglearray. This function is useful if the parameters of the lines are required for further layout functions like placing vias.
    \begin{APIparameters}
        \parameter{cell}{object}
            Object in which the rectangle is created;
        \parameter{layer}{generics}
            Layer of the generated rectangular shape;
        \parameter{pt1}{point}
            First corner point of the target area;
        \parameter{pt2}{point}
            Second corner point of the target area;
        \parameter{width}{integer}
            Width target of lines to be generated;
        \parameter{space}{integer}
            Space target between lines to be generated;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{geometry.rectanglehlines(cell, layer, pt1, pt2, numlines, ratio)}
    Fill a rectangular area with horizontal lines with a given ratio between width and spacing
    \begin{APIparameters}
        \parameter{cell}{object}
            Object in which the rectangle is created;
        \parameter{layer}{generics}
            Layer of the generated rectangular shape;
        \parameter{pt1}{point}
            First corner point of the target area;
        \parameter{pt2}{point}
            Second corner point of the target area;
        \parameter{numlines}{integer}
            Number of lines to be generated;
        \parameter{ratio}{number}
            Ratio between width and spacing of lines;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{geometry.rectanglehlines\_height\_space(cell, layer, pt1, pt2, height, space)}
    Fill a rectangular area with horizontal lines with the given height and spacing. The given numbers are only targets, in some cases they can't be matched exactly.
    \begin{APIparameters}
        \parameter{cell}{object}
            Object in which the rectangle is created;
        \parameter{layer}{generics}
            Layer of the generated rectangular shape;
        \parameter{pt1}{point}
            First corner point of the target area;
        \parameter{pt2}{point}
            Second corner point of the target area;
        \parameter{height}{integer}
            Height target of lines to be generated;
        \parameter{space}{integer}
            Space target of lines to be generated;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{geometry.rectanglehlines\_settings(cell, layer, pt1, pt2, numlines, ratio)}
    Calculate the geometries of horizontal lines to fill a rectangular area with a given ratio between width and spacing. This function is like geometry.rectanglehlines, but it does not actually create the lines. It return the width, heigh, space, offset and number of lines. These parameters can then be used to call geometry.rectanglearray. This function is useful if the parameters of the lines are required for further layout functions like placing vias.
    \begin{APIparameters}
        \parameter{cell}{object}
            Object in which the rectangle is created;
        \parameter{layer}{generics}
            Layer of the generated rectangular shape;
        \parameter{pt1}{point}
            First corner point of the target area;
        \parameter{pt2}{point}
            Second corner point of the target area;
        \parameter{numlines}{integer}
            Number of lines to be generated;
        \parameter{ratio}{number}
            Ratio between width and spacing of lines;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{geometry.rectanglehlines\_width\_space\_settings(cell, layer, pt1, pt2, width, space)}
    Calculate the geometries of horizontal lines to fill a rectangular area with a given width and spacing. This function is like geometry.rectanglehlines\_width\_space, but it does not actually create the lines. It return the width, heigh, space, offset and number of lines. These parameters can then be used to call geometry.rectanglearray. This function is useful if the parameters of the lines are required for further layout functions like placing vias.
    \begin{APIparameters}
        \parameter{cell}{object}
            Object in which the rectangle is created;
        \parameter{layer}{generics}
            Layer of the generated rectangular shape;
        \parameter{pt1}{point}
            First corner point of the target area;
        \parameter{pt2}{point}
            Second corner point of the target area;
        \parameter{width}{integer}
            Width target of lines to be generated;
        \parameter{space}{integer}
            Space target between lines to be generated;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{geometry.rectangle\_fill\_in\_boundary(cell, layer, width, height, xpitch, ypitch, xstartshift, ystartshift, boundary, excludes)}
    Fill a given boundary (a polygon) with rectangles of a given width and height. If given, the rectangles are not placed in the regions defined by the exclude rectangles. The excludes table should contain polygons
    \begin{APIparameters}
        \parameter{cell}{object}
            Object in which the rectangle is created;
        \parameter{layer}{generics}
            Layer of the generated rectangular shape;
        \parameter{width}{integer}
            Width of the rectangles;
        \parameter{height}{integer}
            Height of the rectangles;
        \parameter{xpitch}{integer}
            Pitch in x-direction;
        \parameter{ypitch}{integer}
            Pitch in y-direction;
        \parameter{xstartshift}{integer}
            Shift the start of the rectangle placment algorithm in x-direction;
        \parameter{ystartshift}{integer}
            Shift the start of the rectangle placment algorithm in y-direction;
        \parameter{boundary}{pointlist}
            List of points defining fill boundary (a polygon);
        \parameter{excludes}{table}
            Collection of excludes (polygons);
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{geometry.polygon(cell, layer, pts)}
    Create a polygon shape with the given points in cell
    \begin{APIparameters}
        \parameter{cell}{object}
            Object in which the polygon is created;
        \parameter{layer}{generics}
            Layer of the generated rectangular shape;
        \parameter{pts}{pointlist}
            List of points that make up the polygon;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{geometry.path(cell, layer, pts, width, extension)}
    Create a path shape with the given points and width in cell
    \begin{APIparameters}
        \parameter{cell}{object}
            Object in which the path is created;
        \parameter{layer}{generics}
            Layer of the generated rectangular shape;
        \parameter{pts}{pointlist}
            List of points where the path passes through;
        \parameter{width}{integer}
            width of the path. Must be even;
        \parameter{extension}{table}
            optional table argument containing the start/end extensions;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{geometry.path\_manhatten(cell, layer, pts, width, extension)}
    Create a manhatten path shape with the given points and width in cell. This only allows vertical or horizontal movements
    \begin{APIparameters}
        \parameter{cell}{object}
            Object in which the path is created;
        \parameter{layer}{generics}
            Layer of the generated rectangular shape;
        \parameter{pts}{pointlist}
            List of points where the path passes through;
        \parameter{width}{integer}
            width of the path. Must be even;
        \parameter{extension}{table}
            optional table argument containing the start/end extensions;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{geometry.path\_2x(cell, layer, ptstart, ptend, width)}
    Create a path that starts at ptstart and ends at ptend by moving first in x direction, then in y-direction (similar to an 'L')
    \begin{APIparameters}
        \parameter{cell}{object}
            Object in which the path is created;
        \parameter{layer}{generics}
            Layer of the generated rectangular shape;
        \parameter{ptstart}{point}
            Start point of the path;
        \parameter{ptend}{point}
            End point of the path;
        \parameter{width}{integer}
            width of the path. Must be even;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{geometry.path\_2y(cell, layer, ptstart, ptend, width)}
    Create a path that starts at ptstart and ends at ptend by moving first in y direction, then in x-direction (similar to an capital greek gamma)
    \begin{APIparameters}
        \parameter{cell}{object}
            Object in which the path is created;
        \parameter{layer}{generics}
            Layer of the generated rectangular shape;
        \parameter{ptstart}{point}
            Start point of the path;
        \parameter{ptend}{point}
            End point of the path;
        \parameter{width}{integer}
            width of the path. Must be even;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{geometry.path\_3x(cell, layer, ptstart, ptend, width, position)}
    Create a path that starts at ptstart and ends at ptend by moving first in x direction, then in y-direction. Different from path\_2x this make a bend in the middle between the start and the end point. The position factor influences where the middle point lies. It is a linear interpolation between the start- and the end-point, with a factor of 0.5 leading to exactly the middle. Values closer to 0 shift this point to the beginning, values closer to 1 shift this point to the end.
    \begin{APIparameters}
        \parameter{cell}{object}
            Object in which the path is created;
        \parameter{layer}{generics}
            Layer of the generated rectangular shape;
        \parameter{ptstart}{point}
            Start point of the path;
        \parameter{ptend}{point}
            End point of the path;
        \parameter{width}{integer}
            width of the path. Must be even;
        \parameter{position}{number}
            position factor (a number between 0 and 1);
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{geometry.path\_3y(cell, layer, ptstart, ptend, width, position)}
    Create a path that starts at ptstart and ends at ptend by moving first in y direction, then in x-direction. Different from path\_2x this make a bend in the middle between the start and the end point. The position factor influences where the middle point lies. It is a linear interpolation between the start- and the end-point, with a factor of 0.5 leading to exactly the middle. Values closer to 0 shift this point to the beginning, values closer to 1 shift this point to the end.
    \begin{APIparameters}
        \parameter{cell}{object}
            Object in which the path is created;
        \parameter{layer}{generics}
            Layer of the generated rectangular shape;
        \parameter{ptstart}{point}
            Start point of the path;
        \parameter{ptend}{point}
            End point of the path;
        \parameter{width}{integer}
            width of the path. Must be even;
        \parameter{position}{number}
            position factor (a number between 0 and 1);
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{geometry.path\_cshape(cell, layer, ptstart, ptend, ptoffset, width)}
    Create a path shape that starts and ends at the start and end point, respectively and passes through the offset point. Only the x-coordinate of the offset point is taken, creating a shape resembling a (possibly inverter) 'C'
    \begin{APIparameters}
        \parameter{cell}{object}
            Object in which the path is created;
        \parameter{layer}{generics}
            Layer of the generated rectangular shape;
        \parameter{ptstart}{point}
            Start point of the path;
        \parameter{ptend}{point}
            End point of the path;
        \parameter{ptoffset}{point}
            Offset point;
        \parameter{width}{integer}
            width of the path. Must be even;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{geometry.path\_ushape(cell, layer, ptstart, ptend, ptoffset, width)}
    Create a path shape that starts and ends at the start and end point, respectively and passes through the offset point. Only the y-coordinate of the offset point is taken, creating a shape resembling a (possibly inverter) 'U'
    \begin{APIparameters}
        \parameter{cell}{object}
            Object in which the path is created;
        \parameter{layer}{generics}
            Layer of the generated rectangular shape;
        \parameter{ptstart}{point}
            Start point of the path;
        \parameter{ptend}{point}
            End point of the path;
        \parameter{ptoffset}{point}
            Offset point;
        \parameter{width}{integer}
            width of the path. Must be even;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{geometry.path\_points\_xy(ptstart, pts)}
    Create a point list for use in geometry.path that contains only horizontal and vertical movements based on a list of points or scalars.
This function only creates the resulting list of points, no shapes by itself.
A movement can be a point, in which case two resulting movements are created: first x, than y (or vice versa, depending on the current state).
A scalar movement moves relatively by that amount (in x or y, again depending on the state)
This function does the same as geometry.path\_points\_yx, but starts in x-direction
    \begin{APIparameters}
        \parameter{ptstart}{point}
            Start point of the path;
        \parameter{pts}{pointlist}
            List of points or scalars;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{geometry.path\_points\_yx(ptstart, pts)}
    Create a point list for use in geometry.path that contains only horizontal and vertical movements based on a list of points or scalars.
This function only creates the resulting list of points, no shapes by itself.
A movement can be a point, in which case two resulting movements are created: first x, than y (or vice versa, depending on the current state).
A scalar movement moves relatively by that amount (in x or y, again depending on the state)
This function does the same as geometry.path\_points\_xy, but starts in y-direction
    \begin{APIparameters}
        \parameter{ptstart}{point}
            Start point of the path;
        \parameter{pts}{pointlist}
            List of points or scalars;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{geometry.viabltr(cell, firstmetal, lastmetal, bl, tr)}
    Create vias (single or stack) in a rectangular area with the given corner points in cell
    \begin{APIparameters}
        \parameter{cell}{object}
            Object in which the via is created;
        \parameter{firstmetal}{integer}
            Number of the first metal. Negative values are possible;
        \parameter{lastmetal}{integer}
            Number of the last metal. Negative values are possible;
        \parameter{bl}{point}
            Bottom-left point of the generated rectangular shape;
        \parameter{tr}{point}
            Top-right point of the generated rectangular shape;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{geometry.viabarebltr(cell, firstmetal, lastmetal, bl, tr)}
    Create vias (single or stack) in a rectangular area with the given corner points in cell. This function is like viabltr, but no metals are drawn
    \begin{APIparameters}
        \parameter{cell}{object}
            Object in which the via is created;
        \parameter{firstmetal}{integer}
            Number of the first metal. Negative values are possible;
        \parameter{lastmetal}{integer}
            Number of the last metal. Negative values are possible;
        \parameter{bl}{point}
            Bottom-left point of the generated rectangular shape;
        \parameter{tr}{point}
            Top-right point of the generated rectangular shape;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{geometry.viabltr\_xcontinuous(cell, firstmetal, lastmetal, bl, tr)}
    Create vias (single or stack) in a rectangular area with the given corner points in cell. This function creates vias that can be abutted in x-direction. For this, the space between cuts and the surroundings are equalized
    \begin{APIparameters}
        \parameter{cell}{object}
            Object in which the via is created;
        \parameter{firstmetal}{integer}
            Number of the first metal. Negative values are possible;
        \parameter{lastmetal}{integer}
            Number of the last metal. Negative values are possible;
        \parameter{bl}{point}
            Bottom-left point of the generated rectangular shape;
        \parameter{tr}{point}
            Top-right point of the generated rectangular shape;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{geometry.viabltr\_ycontinuous(cell, firstmetal, lastmetal, bl, tr)}
    Create vias (single or stack) in a rectangular area with the given corner points in cell. This function creates vias that can be abutted in y-direction. For this, the space between cuts and the surroundings are equalized
    \begin{APIparameters}
        \parameter{cell}{object}
            Object in which the via is created;
        \parameter{firstmetal}{integer}
            Number of the first metal. Negative values are possible;
        \parameter{lastmetal}{integer}
            Number of the last metal. Negative values are possible;
        \parameter{bl}{point}
            Bottom-left point of the generated rectangular shape;
        \parameter{tr}{point}
            Top-right point of the generated rectangular shape;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{geometry.viabltr\_continuous(cell, firstmetal, lastmetal, bl, tr)}
    Create vias (single or stack) in a rectangular area with the given corner points in cell. This function creates vias that can be abutted in both x- and y-direction. For this, the space between cuts and the surroundings are equalized
    \begin{APIparameters}
        \parameter{cell}{object}
            Object in which the via is created;
        \parameter{firstmetal}{integer}
            Number of the first metal. Negative values are possible;
        \parameter{lastmetal}{integer}
            Number of the last metal. Negative values are possible;
        \parameter{bl}{point}
            Bottom-left point of the generated rectangular shape;
        \parameter{tr}{point}
            Top-right point of the generated rectangular shape;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{geometry.viabarebltr\_xcontinuous(cell, firstmetal, lastmetal, bl, tr)}
    Create vias (single or stack) in a rectangular area with the given corner points in cell. This function creates vias that can be abutted in x-direction. For this, the space between cuts and the surroundings are equalized. This function is like viabltr\_xcontinuous, but no metals are drawn
    \begin{APIparameters}
        \parameter{cell}{object}
            Object in which the via is created;
        \parameter{firstmetal}{integer}
            Number of the first metal. Negative values are possible;
        \parameter{lastmetal}{integer}
            Number of the last metal. Negative values are possible;
        \parameter{bl}{point}
            Bottom-left point of the generated rectangular shape;
        \parameter{tr}{point}
            Top-right point of the generated rectangular shape;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{geometry.viabarebltr\_ycontinuous(cell, firstmetal, lastmetal, bl, tr)}
    Create vias (single or stack) in a rectangular area with the given corner points in cell. This function creates vias that can be abutted in y-direction. For this, the space between cuts and the surroundings are equalized. This function is like viabltr\_ycontinuous, but no metals are drawn
    \begin{APIparameters}
        \parameter{cell}{object}
            Object in which the via is created;
        \parameter{firstmetal}{integer}
            Number of the first metal. Negative values are possible;
        \parameter{lastmetal}{integer}
            Number of the last metal. Negative values are possible;
        \parameter{bl}{point}
            Bottom-left point of the generated rectangular shape;
        \parameter{tr}{point}
            Top-right point of the generated rectangular shape;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{geometry.viabarebltr\_continuous(cell, firstmetal, lastmetal, bl, tr)}
    Create vias (single or stack) in a rectangular area with the given corner points in cell. This function creates vias that can be abutted in both x- and y-direction. For this, the space between cuts and the surroundings are equalized. This function is like viabltr\_continuous, but no metals are drawn
    \begin{APIparameters}
        \parameter{cell}{object}
            Object in which the via is created;
        \parameter{firstmetal}{integer}
            Number of the first metal. Negative values are possible;
        \parameter{lastmetal}{integer}
            Number of the last metal. Negative values are possible;
        \parameter{bl}{point}
            Bottom-left point of the generated rectangular shape;
        \parameter{tr}{point}
            Top-right point of the generated rectangular shape;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{geometry.contactbltr(cell, layer, bl, tr)}
    Create contacts in a rectangular area with the given corner points in cell
    \begin{APIparameters}
        \parameter{cell}{object}
            Object in which the contact is created;
        \parameter{layer}{string}
            Identifier of the contact type. Possible values: 'gate', 'active', 'sourcedrain';
        \parameter{bl}{point}
            Bottom-left point of the generated rectangular shape;
        \parameter{tr}{point}
            Top-right point of the generated rectangular shape;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{geometry.contactbarebltr(cell, layer, bl, tr)}
    Create contacts in a rectangular area with the given corner points in cell. This function creates 'bare' contacts, so only the cut layers, no surrouning metals or semi-conductor layers
    \begin{APIparameters}
        \parameter{cell}{object}
            Object in which the contact is created;
        \parameter{layer}{string}
            Identifier of the contact type. Possible values: 'gate', 'active', 'sourcedrain';
        \parameter{bl}{point}
            Bottom-left point of the generated rectangular shape;
        \parameter{tr}{point}
            Top-right point of the generated rectangular shape;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{geometry.cross(cell, layer, width, height, crosssize)}
    Create a cross shape in the given cell. The cross is made up by two overlapping rectangles in horizontal and in vertical direction.
    \begin{APIparameters}
        \parameter{cell}{object}
            Object in which the cross is created;
        \parameter{layer}{generics}
            Layer of the generated cross shape;
        \parameter{width}{integer}
            Width of the generated cross shape;
        \parameter{height}{integer}
            Height of the generated cross shape;
        \parameter{crosssize}{integer}
            Cross size of the generated cross shape (the 'width' of the rectangles making up the cross);
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{geometry.unequal\_ring\_pts(cell, layer, outerbl, outertr, innerbl, innertr)}
    Create a ring shape with unequal ring widths in the given cell, defined by the corner points
    \begin{APIparameters}
        \parameter{cell}{object}
            Object in which the ring is created;
        \parameter{layer}{generics}
            Layer of the generated ring shape;
        \parameter{outerbl}{point}
            Outer lower-left corner of the generated ring shape;
        \parameter{outertr}{point}
            Outer upper-right corner of the generated ring shape;
        \parameter{innerbl}{point}
            Inner lower-left corner of the generated ring shape;
        \parameter{innertr}{point}
            Inner upper-right corner of the generated ring shape;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{geometry.unequal\_ring(cell, layer, center, width, height, leftringwidth, rightringwidth, topringwidth, bottomringwidth)}
    Create a ring shape with unequal ring widths in the given cell
    \begin{APIparameters}
        \parameter{cell}{object}
            Object in which the ring is created;
        \parameter{layer}{generics}
            Layer of the generated ring shape;
        \parameter{center}{point}
            Center of the generated ring shape;
        \parameter{width}{integer}
            Width of the generated ring shape;
        \parameter{height}{integer}
            Height of the generated ring shape;
        \parameter{leftringwidth}{integer}
            Left ring width of the generated ring shape (the 'width' of the path making up the left part of the ring);
        \parameter{rightringwidth}{integer}
            Right ring width of the generated ring shape (the 'width' of the path making up the right part of the ring);
        \parameter{topringwidth}{integer}
            Top ring width of the generated ring shape (the 'width' of the path making up the top part of the ring);
        \parameter{bottomringwidth}{integer}
            Bottom ring width of the generated ring shape (the 'width' of the path making up the bottom part of the ring);
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{geometry.ring(cell, layer, center, width, height, ringwidth)}
    Create a ring shape width equal ring widths in the given cell. Like geometry.unequal\_ring, but all widths are the same
    \begin{APIparameters}
        \parameter{cell}{object}
            Object in which the ring is created;
        \parameter{layer}{generics}
            Layer of the generated ring shape;
        \parameter{center}{point}
            Center of the generated ring shape;
        \parameter{width}{integer}
            Width of the generated ring shape;
        \parameter{height}{integer}
            Height of the generated ring shape;
        \parameter{ringwidth}{integer}
            Ring width of the generated ring shape (the 'width' of the path making up the ring);
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{geometry.curve(cell, layer, origin, segments, grid, allow45)}
    Create a curve shape width in the given cell. Segments must be added for a curve to be meaningful. See the functions for adding curve segments: curve.lineto, curve.arcto and curve.cubicto
    \begin{APIparameters}
        \parameter{cell}{object}
            Object in which the ring is created;
        \parameter{layer}{generics}
            Layer of the generated ring shape;
        \parameter{origin}{point}
            Start point of the curve;
        \parameter{segments}{table}
            Table of curve segments;
        \parameter{grid}{integer}
            Grid for rasterization of the curve;
        \parameter{allow45}{boolean}
            Start point of the curve;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{geometry.curve(cell, layer, origin, segments, grid, allow45)}
    Like geometry.curve, but rasterize the curve right now. Typically, the rasterization happens later in the layout generation process (it is resolved when the design is exported, depending whether the export format supports arbitrary curves, in which case there is no rasterization). This function is useful to generate rasterized curves for export formats that support arbitrary curves.
    \begin{APIparameters}
        \parameter{cell}{object}
            Object in which the ring is created;
        \parameter{layer}{generics}
            Layer of the generated ring shape;
        \parameter{origin}{point}
            Start point of the curve;
        \parameter{segments}{table}
            Table of curve segments;
        \parameter{grid}{integer}
            Grid for rasterization of the curve;
        \parameter{allow45}{boolean}
            Start point of the curve;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{set(...)}
    define a set of possible values that a parameter can take. Only useful within a parameter definition of a pcell
    \begin{APIparameters}
        \parameter{...}{...}
            variable number of arguments, usually strings or integers;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{interval(lower, upper)}
    define an interval of possible values that a parameter can take. Only useful within a parameter definition of a pcell
    \begin{APIparameters}
        \parameter{lower}{integer}
            lower (inklusive) bound of the interval;
        \parameter{upper}{integer}
            upper (inklusive) bound of the interval;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{even()}
    define that a parameter must be even. Only useful within a parameter definition of a pcell
    \begin{APIparameters}
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{odd()}
    define that a parameter must be odd. Only useful within a parameter definition of a pcell
    \begin{APIparameters}
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{positive()}
    define that a parameter must be positive. Only useful within a parameter definition of a pcell
    \begin{APIparameters}
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{negative()}
    define that a parameter must be negative. Only useful within a parameter definition of a pcell
    \begin{APIparameters}
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{enable(bool, value)}
    multiply a value with 1 or 0, depending on a boolean parameter. Essentially val * (bool and 1 or 0)
    \begin{APIparameters}
        \parameter{bool}{boolean}
            boolean for enable/disable;
        \parameter{value}{number}
            value to be enabled/disabled;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{evenodddiv2(value)}
    divide a value by 2. If it is odd, return floor(val / 2) and ceil(val / 2), otherwise return val / 2
    \begin{APIparameters}
        \parameter{value}{integer}
            value to divide;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{divevenup(value, div)}
    approximately divide a value by the divisor, so that the result is even. If this can't be achieved with the original value, increment it until it works
    \begin{APIparameters}
        \parameter{value}{integer}
            value to divide;
        \parameter{div}{integer}
            divisor;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{divevendown(value, div)}
    approximately divide a value by the divisor, so that the result is even. If this can't be achieved with the original value, decrement it until it works
    \begin{APIparameters}
        \parameter{value}{integer}
            value to divide;
        \parameter{div}{integer}
            divisor;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{dprint(...)}
    debug print. Works like regular print (which is not available in pcell definitions). Only prints something when opc is called with --enable-dprint
    \begin{APIparameters}
        \parameter{...}{...}
            variable arguments that should be printed;
    \end{APIparameters}
\end{APIfunc}
\subsection{layouthelpers Module}
\begin{APIfunc}{layouthelpers.place\_bus(cell, layer, pts, numbits, width, space)}
    place a bus with 'numbits' lines with the given 'width' and 'space'. The bus is defined by the path points (like a regular path), which define the center of the bus.
    \begin{APIparameters}
        \parameter{cell}{object}
            cell to place bus in;
        \parameter{layer}{generics}
            layer of the bus shapes;
        \parameter{pts}{pointlist}
            path point defining the middle of the bus;
        \parameter{numbits}{integer}
            number of bits;
        \parameter{width}{integer}
            width of the bus lines;
        \parameter{space}{integer}
            space between the bus lines;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{layouthelpers.place\_guardring(cell, bl, tr, xspace, yspace, anchorprefix, options)}
    place a guardring in a cell with a defined boundary and spacing
    \begin{APIparameters}
        \parameter{cell}{object}
            cell to place guardring in;
        \parameter{bl}{point}
            bottom-left boundary corner;
        \parameter{tr}{point}
            top-right boundary corner;
        \parameter{xspace}{integer}
            space in x-direction between boundary and guardring;
        \parameter{yspace}{integer}
            space in y-direction between boundary and guardring;
        \parameter{anchorprefix}{string}
            anchor prefix for inherited anchors (cell inherits the 'innerboundary' and 'outerboundary' area anchors). If this is nil, no anchors are inherited;
        \parameter{options}{table}
            placement options;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{layouthelpers.place\_guardring\_with\_hole(cell, bl, tr, bl, tr, xspace, yspace, anchorprefix, options)}
    place a guardring with a well hole in a cell with a defined boundary and spacing
    \begin{APIparameters}
        \parameter{cell}{object}
            cell to place guardring in;
        \parameter{bl}{point}
            bottom-left boundary corner;
        \parameter{tr}{point}
            top-right boundary corner;
        \parameter{bl}{point}
            bottom-left hole boundary corner;
        \parameter{tr}{point}
            top-right hole boundary corner;
        \parameter{xspace}{integer}
            space in x-direction between boundary and guardring;
        \parameter{yspace}{integer}
            space in y-direction between boundary and guardring;
        \parameter{anchorprefix}{string}
            anchor prefix for inherited anchors (cell inherits the 'innerboundary' and 'outerboundary' area anchors). If this is nil, no anchors are inherited;
        \parameter{options}{table}
            placement options;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{layouthelpers.place\_welltap(cell, bl, tr, anchorprefix, options)}
    place a welltap in a cell with a defined boundary and spacing
    \begin{APIparameters}
        \parameter{cell}{object}
            cell to place guardring in;
        \parameter{bl}{point}
            bottom-left boundary corner;
        \parameter{tr}{point}
            top-right boundary corner;
        \parameter{anchorprefix}{string}
            anchor prefix for inherited anchors (cell inherits the 'boundary' area anchor);
        \parameter{options}{table}
            placement options;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{layouthelpers.place\_maximum\_width\_via(cell, firstmetal, lastmetal, pt1, pt2)}
    place a via (or a via stack) in an object. The function behaves like geometry.viabltr, but takes into account the maximum width of the metal layers. This means that possibly not all vias are created with the full width of the given region. This means that the first point (pt1) must touch the actual shape that should connect to the via. Therefore, pt1 and pt2 don't have to be the lower-left and the top-right corner points. The maximum widths are specified by the technology constraint file (entries "Maximum Mn Width", where 'n' is an integer). If no values are specified, the full width of the via region is used, in which case the function behaves exactly like geometry.viabltr (except for the order of the points).
    \begin{APIparameters}
        \parameter{cell}{object}
            Object in which the via is created;
        \parameter{firstmetal}{integer}
            Number of the first metal. Negative values are possible;
        \parameter{lastmetal}{integer}
            Number of the last metal. Negative values are possible;
        \parameter{pt1}{point}
            first corner point of the to-be-created via;
        \parameter{pt2}{point}
            second corner point of the to-be-created via;
    \end{APIparameters}
\end{APIfunc}
\subsection{object Module}
\begin{APIfunc}{object.abut\_area\_anchor\_bottom(cell, anchorname, targercell, targetanchorname)}
    translate the cell so that the specified area anchor is abutted to the bottom of the target area anchor of the specified target cell. This only changes the y coordinate
    \begin{APIparameters}
        \parameter{cell}{object}
            cell to be moved;
        \parameter{anchorname}{string}
            abutment anchor;
        \parameter{targercell}{object}
            alignment target cell;
        \parameter{targetanchorname}{string}
            target abutment anchor;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{object.abut\_area\_anchor\_left(cell, anchorname, targercell, targetanchorname)}
    translate the cell so that the specified area anchor is abutted to the left of the target area anchor of the specified target cell. This only changes the x coordinate
    \begin{APIparameters}
        \parameter{cell}{object}
            cell to be moved;
        \parameter{anchorname}{string}
            abutment anchor;
        \parameter{targercell}{object}
            alignment target cell;
        \parameter{targetanchorname}{string}
            target abutment anchor;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{object.abut\_area\_anchor\_right(cell, anchorname, targercell, targetanchorname)}
    translate the cell so that the specified area anchor is abutted to the right of the target area anchor of the specified target cell. This only changes the x coordinate
    \begin{APIparameters}
        \parameter{cell}{object}
            cell to be moved;
        \parameter{anchorname}{string}
            abutment anchor;
        \parameter{targercell}{object}
            alignment target cell;
        \parameter{targetanchorname}{string}
            target abutment anchor;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{object.abut\_area\_anchor\_top(cell, anchorname, targercell, targetanchorname)}
    translate the cell so that the specified area anchor is abutted to the top of the target area anchor of the specified target cell. This only changes the y coordinate
    \begin{APIparameters}
        \parameter{cell}{object}
            cell to be moved;
        \parameter{anchorname}{string}
            abutment anchor;
        \parameter{targercell}{object}
            alignment target cell;
        \parameter{targetanchorname}{string}
            target abutment anchor;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{object.abut\_bottom(cell)}
    translate the cell so that its alignment box (outer boundary) is abutted-bottom to the origin. This only changes the y coordinate
    \begin{APIparameters}
        \parameter{cell}{object}
            cell to be abutted;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{object.abut\_bottom(cell, targercell)}
    translate the cell so that its alignment box is abutted to the bottom of the alignment box of the specified target cell. This only changes the y coordinate
    \begin{APIparameters}
        \parameter{cell}{object}
            cell to be abutted;
        \parameter{targercell}{object}
            abutment target cell;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{object.abut\_left(cell)}
    translate the cell so that its alignment box (outer boundary) is abutted-left to the origin. This only changes the x coordinate
    \begin{APIparameters}
        \parameter{cell}{object}
            cell to be abutted;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{object.abut\_left(cell, targercell)}
    translate the cell so that its alignment box is abutted to the left of the alignment box of the specified target cell. This only changes the y coordinate
    \begin{APIparameters}
        \parameter{cell}{object}
            cell to be abutted;
        \parameter{targercell}{object}
            abutment target cell;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{object.abut\_right(cell)}
    translate the cell so that its alignment box (outer boundary) is abutted-right to the origin. This only changes the x coordinate
    \begin{APIparameters}
        \parameter{cell}{object}
            cell to be abutted;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{object.abut\_right(cell, targercell)}
    translate the cell so that its alignment box is abutted to the right of the alignment box of the specified target cell. This only changes the y coordinate
    \begin{APIparameters}
        \parameter{cell}{object}
            cell to be abutted;
        \parameter{targercell}{object}
            abutment target cell;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{object.abut\_top(cell)}
    translate the cell so that its alignment box (outer boundary) is abutted-top to the origin. This only changes the x coordinate
    \begin{APIparameters}
        \parameter{cell}{object}
            cell to be abutted;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{object.abut\_top(cell, targercell)}
    translate the cell so that its alignment box is abutted to the top of the alignment box of the specified target cell. This only changes the y coordinate
    \begin{APIparameters}
        \parameter{cell}{object}
            cell to be abutted;
        \parameter{targercell}{object}
            abutment target cell;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{object.add\_anchor(cell, name, where)}
    add an anchor to an object
    \begin{APIparameters}
        \parameter{cell}{object}
            object to which an anchor should be added;
        \parameter{name}{string}
            name of the anchor;
        \parameter{where}{point}
            location of the anchor;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{object.add\_area\_anchor\_bltr(cell, name, bl, tr)}
    Similar to add\_area\_anchor, but takes to lower-left and upper-right corner points of the rectangular area
    \begin{APIparameters}
        \parameter{cell}{object}
            object to which an anchor should be added;
        \parameter{name}{string}
            name of the anchor;
        \parameter{bl}{point}
            bottom-left point of the rectangular area;
        \parameter{tr}{point}
            bottom-left point of the rectangular area;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{object.add\_bus\_port(cell, name, layer, where, startindex, endindex, xpitch, ypitch)}
    add a bus port (multiple ports like vout[0:4]) to a cell. The port expression is portname[startindex:endindex] and portname[i] is placed at 'where' with an offset of ((i - 1) * xpitch, (i - 1) * ypitch)
    \begin{APIparameters}
        \parameter{cell}{object}
            object to which a port should be added;
        \parameter{name}{string}
            base name of the port;
        \parameter{layer}{generics}
            layer of the port;
        \parameter{where}{point}
            location of the port;
        \parameter{startindex}{integer}
            start index of the bus port;
        \parameter{endindex}{integer}
            end index of the bus port;
        \parameter{xpitch}{integer}
            pitch in x direction;
        \parameter{ypitch}{integer}
            pitch in y direction;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{object.add\_child\_array(cell, child, instname, xrep, yrep, xpitch, ypitch)}
    Add a child as an arrayed object to the given cell. The child array has xrep * yrep elements, with a pitch of xpitch and ypitch, respectively. The array grows to the upper-left, with the first placed untranslated. The pitch does not have to be explicitly given: If the child has an alignment box, the xpitch and ypitch are deferred from this box, if they are not given in the call. In this case, it is an error if no alignment box is present in child. As with object.add\_child: don't use the original child object after this call unless it is object.add\_child or object.add\_child\_array
    \begin{APIparameters}
        \parameter{cell}{object}
            Object to which the child is added;
        \parameter{child}{object}
            Child to add;
        \parameter{instname}{string}
            Instance name (not used by all exports);
        \parameter{xrep}{integer}
            Number of repetitions in x direction;
        \parameter{yrep}{integer}
            Number of repetitions in y direction;
        \parameter{xpitch}{integer}
            Optional itch in x direction, used for repetition in x. If not given, this parameter is derived from the alignment box;
        \parameter{ypitch}{integer}
            Optional itch in y direction, used for repetition in y. If not given, this parameter is derived from the alignment box;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{object.add\_layer\_boundary(cell, layer, boundary)}
    Add a layer boundary to an object. A layer boundary is useful for automatic filling
    \begin{APIparameters}
        \parameter{cell}{object}
            object to which the layer boundary should be added;
        \parameter{layer}{generics}
            layer for the layer boundary;
        \parameter{boundary}{pointlist}
            the boundary (a polygon);
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{object.add\_layer\_boundary\_rectangular(cell, layer, bl, tr)}
    Add a rectangular layer boundary to an object. A layer boundary is useful for automatic filling
    \begin{APIparameters}
        \parameter{cell}{object}
            object to which the layer boundary should be added;
        \parameter{layer}{generics}
            layer for the layer boundary;
        \parameter{bl}{point}
            lower-left corner point of the rectangular boundary;
        \parameter{tr}{point}
            upper-right corner point of the rectangular boundary;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{object.add\_port(cell, name, layer, where)}
    add a port to a cell. Works like add\_anchor, but additionally a layer is expected
    \begin{APIparameters}
        \parameter{cell}{object}
            object to which a port should be added;
        \parameter{name}{string}
            name of the port;
        \parameter{layer}{generics}
            layer of the port;
        \parameter{where}{point}
            location of the port;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{object.add\_port\_with\_anchor(cell, name, layer, where)}
    add a port to a cell. Works like add\_anchor, but additionally a layer is expected. This function also adds an anchor to the cell (named like the port)
    \begin{APIparameters}
        \parameter{cell}{object}
            object to which a port should be added;
        \parameter{name}{string}
            name of the port;
        \parameter{layer}{generics}
            layer of the port;
        \parameter{where}{point}
            location of the port;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{object.align\_area\_anchor\_bottom(cell, anchorname, targercell, targetanchorname)}
    translate the cell so that the specified area anchor is aligned to the bottom of the target area anchor of the specified target cell. This only changes the y coordinate
    \begin{APIparameters}
        \parameter{cell}{object}
            cell to be moved;
        \parameter{anchorname}{string}
            alignment anchor;
        \parameter{targercell}{object}
            alignment target cell;
        \parameter{targetanchorname}{string}
            target alignment anchor;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{object.align\_area\_anchor\_left(cell, anchorname, targercell, targetanchorname)}
    translate the cell so that the specified area anchor is aligned to the left of the target area anchor of the specified target cell. This only changes the x coordinate
    \begin{APIparameters}
        \parameter{cell}{object}
            cell to be moved;
        \parameter{anchorname}{string}
            alignment anchor;
        \parameter{targercell}{object}
            alignment target cell;
        \parameter{targetanchorname}{string}
            target alignment anchor;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{object.align\_area\_anchor\_right(cell, anchorname, targercell, targetanchorname)}
    translate the cell so that the specified area anchor is aligned to the right of the target area anchor of the specified target cell. This only changes the x coordinate
    \begin{APIparameters}
        \parameter{cell}{object}
            cell to be moved;
        \parameter{anchorname}{string}
            alignment anchor;
        \parameter{targercell}{object}
            alignment target cell;
        \parameter{targetanchorname}{string}
            target alignment anchor;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{object.align\_area\_anchor(cell, anchorname, targercell, targetanchorname)}
    translate the cell so that the specified area anchor is aligned to the target area anchor of the specified target cell. This changes both the x- and the y-coordinate
    \begin{APIparameters}
        \parameter{cell}{object}
            cell to be moved;
        \parameter{anchorname}{string}
            alignment anchor;
        \parameter{targercell}{object}
            alignment target cell;
        \parameter{targetanchorname}{string}
            target alignment anchor;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{object.align\_area\_anchor\_top(cell, anchorname, targercell, targetanchorname)}
    translate the cell so that the specified area anchor is aligned to the top of the target area anchor of the specified target cell. This only changes the y-coordinate
    \begin{APIparameters}
        \parameter{cell}{object}
            cell to be moved;
        \parameter{anchorname}{string}
            alignment anchor;
        \parameter{targercell}{object}
            alignment target cell;
        \parameter{targetanchorname}{string}
            target alignment anchor;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{object.align\_area\_anchor\_x(cell, anchorname, targercell, targetanchorname)}
    translate the cell so that the specified area anchor is aligned to the target area anchor of the specified target cell. This changes only the x-coordinate
    \begin{APIparameters}
        \parameter{cell}{object}
            cell to be moved;
        \parameter{anchorname}{string}
            alignment anchor;
        \parameter{targercell}{object}
            alignment target cell;
        \parameter{targetanchorname}{string}
            target alignment anchor;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{object.align\_area\_anchor\_y(cell, anchorname, targercell, targetanchorname)}
    translate the cell so that the specified area anchor is aligned to the target area anchor of the specified target cell. This changes only the y-coordinate
    \begin{APIparameters}
        \parameter{cell}{object}
            cell to be moved;
        \parameter{anchorname}{string}
            alignment anchor;
        \parameter{targercell}{object}
            alignment target cell;
        \parameter{targetanchorname}{string}
            target alignment anchor;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{object.align\_bottom(cell, targercell)}
    translate the cell so that its alignment box is aligned to the bottom of the alignment box of the specified target cell. This only changes the y coordinate
    \begin{APIparameters}
        \parameter{cell}{object}
            cell to be aligned;
        \parameter{targercell}{object}
            alignment target cell;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{object.align\_bottom\_origin(cell)}
    translate the cell so that its alignment box (outer boundary) is aligned-bottom to the origin. This only changes the y coordinate
    \begin{APIparameters}
        \parameter{cell}{object}
            cell to be aligned;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{object.align\_bottom\_origin(cell)}
    translate the cell so that its alignment box (outer boundary) is aligned-left to the origin. This only changes the x coordinate
    \begin{APIparameters}
        \parameter{cell}{object}
            cell to be aligned;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{object.align\_left(cell, targercell)}
    translate the cell so that its alignment box is aligned to the left of the alignment box of the specified target cell. This only changes the x coordinate
    \begin{APIparameters}
        \parameter{cell}{object}
            cell to be aligned;
        \parameter{targercell}{object}
            alignment target cell;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{object.alignment\_box\_include\_point(cell, pt)}
    extend the alignment box of a cell in a way that the given point is included in it. The alignment box is never shrunken, only enlarged.
    \begin{APIparameters}
        \parameter{cell}{object}
            cell to extend the alignment box of;
        \parameter{pt}{point}
            point to be included in the alignment box of the cell;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{object.alignment\_box\_include\_x(cell, pt)}
    like alignment\_box\_include\_point, but only change the x-coordinates of the alignment box. The y-coordinate is ignored, the second argument is a point only for convenience.
    \begin{APIparameters}
        \parameter{cell}{object}
            cell to extend the alignment box of;
        \parameter{pt}{point}
            point to be included in the alignment box of the cell;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{object.alignment\_box\_include\_y(cell, pt)}
    like alignment\_box\_include\_point, but only change the y-coordinates of the alignment box. The x-coordinate is ignored, the second argument is a point only for convenience.
    \begin{APIparameters}
        \parameter{cell}{object}
            cell to extend the alignment box of;
        \parameter{pt}{point}
            point to be included in the alignment box of the cell;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{object.align\_bottom\_origin(cell)}
    translate the cell so that its alignment box (outer boundary) is aligned-right to the origin. This only changes the x coordinate
    \begin{APIparameters}
        \parameter{cell}{object}
            cell to be aligned;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{object.align\_right(cell, targercell)}
    translate the cell so that its alignment box is aligned to the right of the alignment box of the specified target cell. This only changes the x coordinate
    \begin{APIparameters}
        \parameter{cell}{object}
            cell to be aligned;
        \parameter{targercell}{object}
            alignment target cell;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{object.align\_bottom\_origin(cell)}
    translate the cell so that its alignment box (outer boundary) is aligned-top to the origin. This only changes the y coordinate
    \begin{APIparameters}
        \parameter{cell}{object}
            cell to be aligned;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{object.align\_top(cell, targercell)}
    translate the cell so that its alignment box is aligned to the top of the alignment box of the specified target cell. This only changes the y coordinate
    \begin{APIparameters}
        \parameter{cell}{object}
            cell to be aligned;
        \parameter{targercell}{object}
            alignment target cell;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{object.clear\_alignment\_box(cell)}
    clear (remove) the alignment box of a cell. Useful to set a new alignment box with object.set\_alignment\_box(...)
    \begin{APIparameters}
        \parameter{cell}{object}
            cell to clear the alignment box of;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{object.copy(cell)}
    copy an object
    \begin{APIparameters}
        \parameter{cell}{object}
            Object to copy;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{object.create\_object\_handle(cell, reference)}
    create an object handle of a reference cell and store it in a parent cell. This is used internally when a cell is added for the first time as child. This function is exposed to the user in order to explicitly create these handles. They are useful when multiple cells in a hierarchy add the same object as a child, which would not be possible otherwise (this would require either a complete copy of the object with a new name or the cell hierarchy would contain the same object twice)
    \begin{APIparameters}
        \parameter{cell}{object}
            parent cell to add the reference to;
        \parameter{reference}{object}
            the reference cell, of which a handle is created;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{object.create(cellname)}
    create a new object. A name must be given. Hierarchical exports use this name to identify layout cells and no checks for duplication are done. Therefore the user must make sure that every name is unique. Note that this will probably change in the future
    \begin{APIparameters}
        \parameter{cellname}{string}
            the name of the layout cell;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{object.create\_pseudo()}
    create a new object without a name. This kind of object behaves exactly like a regular object, but it can't be added as a child to a parent object. It is intended to be used as a flat container for shapes that are merged into another cell. This function is there to express this intent, but other than this there are no advantages of using this function over object.create() (except that one does not have to come up with a name)
    \begin{APIparameters}
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{object.exchange(cell, othercell)}
    Take over internal state of the other object, effectively making this the main cell. The object handle to 'othercell' must not be used afterwards as this object is destroyed. This function is only really useful in cells that act as a parameter wrapper for other cells (e.g. dffpq -> dff)
    \begin{APIparameters}
        \parameter{cell}{object}
            Object which should take over the other object;
        \parameter{othercell}{object}
            Object which should be taken over. The object handle must not be used after this operation;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{object.extend\_alignment\_box(cell, extouterblx, extouterbly, extoutertrx, extoutertry, extinnerblx, extinnerbly, extinnertrx, extinnertry)}
    extend an existing object alignment box. Takes eight values for the extension of the four corner points making up the alignment box
    \begin{APIparameters}
        \parameter{cell}{object}
            cell to add the alignment box to;
        \parameter{extouterblx}{integer}
            extension of outer-left coordinate;
        \parameter{extouterbly}{integer}
            extension of outer-bottom coordinate;
        \parameter{extoutertrx}{integer}
            extension of outer-right coordinate;
        \parameter{extoutertry}{integer}
            extension of outer-top coordinate;
        \parameter{extinnerblx}{integer}
            extension of inner-left coordinate;
        \parameter{extinnerbly}{integer}
            extension of inner-bottom coordinate;
        \parameter{extinnertrx}{integer}
            extension of inner-right coordinate;
        \parameter{extinnertry}{integer}
            extension of inner-top coordinate;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{object.extend\_alignment\_box\_x\_symmetrical(cell, extx)}
    extend an existing object alignment box. Takes only one value for the extension of the four corner points and extends all x-coordinates of the box symmetrically in the left/right direction
    \begin{APIparameters}
        \parameter{cell}{object}
            cell to add the alignment box to;
        \parameter{extx}{integer}
            x-extension;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{object.extend\_alignment\_box\_xy\_symmetrical(cell, extx, exty)}
    extend an existing object alignment box. Takes two values for the extension of the four corner points and extends all x- and y-coordinates of the box symmetrically in the left/right direction. This function is the same as calling the individual alignment box extension functions for x- and y-directions individually
    \begin{APIparameters}
        \parameter{cell}{object}
            cell to add the alignment box to;
        \parameter{extx}{integer}
            x-extension;
        \parameter{exty}{integer}
            y-extension;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{object.extend\_alignment\_box\_y\_symmetrical(cell, exty)}
    extend an existing object alignment box. Takes only one value for the extension of the four corner points and extends all y-coordinates of the box symmetrically in the left/right direction
    \begin{APIparameters}
        \parameter{cell}{object}
            cell to add the alignment box to;
        \parameter{exty}{integer}
            y-extension;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{object.flatten\_inline(cell)}
    resolve the cell by placing all shapes from all children in the parent cell. This operates in-place and modifies the object. Copy the cell or use object:flatten() if this is unwanted
    \begin{APIparameters}
        \parameter{cell}{object}
            Object which should be flattened;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{object.flatten\_inline(cell)}
    resolve the cell by placing all shapes from all children in the parent cell. This operates in-place and modifies the object. Copy the cell if this is unwanted
    \begin{APIparameters}
        \parameter{cell}{object}
            Object which should be flattened;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{object.flatten(cell)}
    resolve the cell by placing all shapes from all children in the parent cell. This does not change the original object and creates a copy.
    \begin{APIparameters}
        \parameter{cell}{object}
            Object which should be flattened;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{object.flipx(cell)}
    flip the entire object in x direction. This is similar to mirror\_at\_yaxis (note the x vs. y), but is done in-place. The object is translated so that it is still in its original location. Works best on objects with an alignment box, since this is used to calculate the required translation. On other objects, this operation can be time-consuming as an accurate bounding box has to be computed. It is recommended not to use this function on objects without an alignment box because the result is not always ideal
    \begin{APIparameters}
        \parameter{cell}{object}
            object to be flipped in y-direction;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{object.flipy(cell)}
    flip the entire object in y direction. This is similar to mirror\_at\_xaxis (note the y vs. x), but is done in-place. The object is translated so that it is still in its original location. Works best on objects with an alignment box, since this is used to calculate the required translation. On other objects, this operation can be time-consuming as an accurate bounding box has to be computed. It is recommended not to use this function on objects without an alignment box because the result is not always ideal
    \begin{APIparameters}
        \parameter{cell}{object}
            object to be flipped in y-direction;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{object.get\_alignment\_anchor(cell, anchorname)}
    Retrieve an alignment anchor from a cell. These anchors are the defining points of the alignment box. Valid anchor names are 'outerbl', 'outerbr', 'outertl', 'outertr', 'innerbl', 'innerbr', 'innertl' and 'innertr'. This function returns a point that contains the position of the specified anchor, corrected by the cell transformation. A non-existing anchor is an error
    \begin{APIparameters}
        \parameter{cell}{object}
            object to get an anchor from;
        \parameter{anchorname}{string}
            name of the alignment anchor;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{object.get\_all\_regular\_anchors(cell, anchorname)}
    Create a table containing all regular (non-area and non-alignment) anchors of a cell. The table can be iterated with standard lua methods (pairs)
    \begin{APIparameters}
        \parameter{cell}{object}
            object to get an anchor from;
        \parameter{anchorname}{string}
            name of the anchor;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{object.get\_anchor(cell, anchorname)}
    Retrieve an anchor from a cell. This function returns a point that contains the position of the specified anchor, corrected by the cell transformation. Retrieving non-existing anchor raises an error.
    \begin{APIparameters}
        \parameter{cell}{object}
            object to get an anchor from;
        \parameter{anchorname}{string}
            name of the anchor;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{object.get\_area\_anchor\_height(cell, anchorname)}
    Retrieve the height (an integer) of an area anchor from a cell. A non-existing anchor is an error
    \begin{APIparameters}
        \parameter{cell}{object}
            object to get an anchor from;
        \parameter{anchorname}{string}
            name of the anchor;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{object.get\_area\_anchor(cell, anchorname)}
    Retrieve an area anchor from a cell. This function returns a table with two points (bl (bottom-left) and tr (top-right)) that contain the position of the specified area anchor, corrected by the cell transformation. Furthermore, the individual coordinates are also available as skalar values with the keys 'b', 't', 'l' and 'r'. Retrieving a non-existing anchor raises an error
    \begin{APIparameters}
        \parameter{cell}{object}
            object to get an anchor from;
        \parameter{anchorname}{string}
            name of the anchor;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{object.get\_area\_anchor\_width(cell, anchorname)}
    Retrieve the width (an integer) of an area anchor from a cell. A non-existing anchor is an error
    \begin{APIparameters}
        \parameter{cell}{object}
            object to get an anchor from;
        \parameter{anchorname}{string}
            name of the anchor;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{object.get\_array\_anchor(cell, xindex, yindex, anchorname)}
    Like object.get\_anchor, but works on child arrays. The first two argument are the x- and the y-index (starting at 1, 1). Accessing an array anchor of a non-array object is an error
    \begin{APIparameters}
        \parameter{cell}{object}
            object to get an anchor from;
        \parameter{xindex}{integer}
            x-index;
        \parameter{yindex}{integer}
            y-index;
        \parameter{anchorname}{string}
            name of the anchor;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{object.get\_array\_area\_anchor(cell, xindex, yindex, anchorname)}
    Like object.get\_area\_anchor, but works on child arrays. The first two argument are the x- and the y-index (starting at 1, 1). Accessing an array anchor of a non-array object is an error
    \begin{APIparameters}
        \parameter{cell}{object}
            object to get an anchor from;
        \parameter{xindex}{integer}
            x-index;
        \parameter{yindex}{integer}
            y-index;
        \parameter{anchorname}{string}
            name of the anchor;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{object.get\_boundary(cell)}
    Retrieve the boundary of an object. If no explicit boundary exists, it is calculated from the extrem coordinates of all shapes (bounding box). The boundary is returned as a table containing the points. A boundary is not necessarily rectangular, but automatically-calculated boundaries are
    \begin{APIparameters}
        \parameter{cell}{object}
            object to get the boundary from;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{object.get\_layer\_boundary(cell, layer)}
    Retrieve the layer boundary of an object. If the cell has no layer boundaries at all, an empty table is returned. Otherwise, if the layer boundary for the specified layer does not exist, the bounding box of the cell is returned. If the layer boundary exists, it is returned. For this case, object.set\_empty\_layer\_boundary() is useful.
    \begin{APIparameters}
        \parameter{cell}{object}
            object to get the boundary from;
        \parameter{layer}{generics}
            layer;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{object.get\_ports(cell)}
    return a table which contains key-value pairs with all ports of a cell. The key is the portname, the value the corresponding point.
    \begin{APIparameters}
        \parameter{cell}{object}
            object to get the ports from;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{object.has\_boundary(cell)}
    check if the object has a boundary
    \begin{APIparameters}
        \parameter{cell}{object}
            cell to add the alignment box to;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{object.has\_layer\_boundary(cell, layer)}
    check if the object has a layer boundary for the specified layer
    \begin{APIparameters}
        \parameter{cell}{object}
            cell to add the alignment box to;
        \parameter{layer}{generics}
            layer for the layer boundary;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{object.inherit\_alignment\_box(cell, othercell)}
    inherit the alignment box from another cell. This EXPANDS the current alignment box, if any is present. This means that this function can be called multiple times with different objects to establish an overall alignment box
    \begin{APIparameters}
        \parameter{cell}{object}
            cell to add the alignment box to;
        \parameter{othercell}{object}
            cell to inherit the alignment box from;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{object.inherit\_anchor\_as(cell, othercell, prefix)}
    inherit all anchors from another cell with an attached prefix.
    \begin{APIparameters}
        \parameter{cell}{object}
            cell to add the anchor to;
        \parameter{othercell}{object}
            cell to inherit the anchor from;
        \parameter{prefix}{string}
            prefix of all inherited anchors;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{object.inherit\_anchor\_as(cell, othercell, anchorname, newname)}
    inherit an anchor from another cell under a different name.
    \begin{APIparameters}
        \parameter{cell}{object}
            cell to add the anchor to;
        \parameter{othercell}{object}
            cell to inherit the anchor from;
        \parameter{anchorname}{string}
            anchor name of the to-be-inherited anchor;
        \parameter{newname}{string}
            new name of the inherited anchor;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{object.inherit\_anchor(cell, othercell, anchorname)}
    inherit an anchor from another cell.
    \begin{APIparameters}
        \parameter{cell}{object}
            cell to add the anchor to;
        \parameter{othercell}{object}
            cell to inherit the anchor from;
        \parameter{anchorname}{string}
            anchor name of the to-be-inherited anchor;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{object.inherit\_area\_anchor\_as(cell, othercell, anchorname, newname)}
    inherit an area anchor from another cell under a different name.
    \begin{APIparameters}
        \parameter{cell}{object}
            cell to add the anchor to;
        \parameter{othercell}{object}
            cell to inherit the anchor from;
        \parameter{anchorname}{string}
            anchor name of the to-be-inherited anchor;
        \parameter{newname}{string}
            new name of the inherited anchor;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{object.inherit\_area\_anchor(cell, othercell, anchorname)}
    inherit an area anchor from another cell.
    \begin{APIparameters}
        \parameter{cell}{object}
            cell to add the anchor to;
        \parameter{othercell}{object}
            cell to inherit the anchor from;
        \parameter{anchorname}{string}
            anchor name of the to-be-inherited anchor;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{object.inherit\_boundary(cell, othercell)}
    inherit the boundary from another cell.
    \begin{APIparameters}
        \parameter{cell}{object}
            cell to add the boundary to;
        \parameter{othercell}{object}
            cell to inherit the boundary from;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{object.merge\_into(cell, othercell)}
    add all shapes and children from othercell to the cell -> 'dissolve' othercell in cell
    \begin{APIparameters}
        \parameter{cell}{object}
            Object to which the child is added;
        \parameter{othercell}{object}
            Other layout cell to be merged into the cell;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{object.merge\_into\_with\_ports(cell, othercell)}
    add all shapes, children and ports from othercell to the cell -> 'dissolve' othercell in cell
    \begin{APIparameters}
        \parameter{cell}{object}
            Object to which the child is added;
        \parameter{othercell}{object}
            Other layout cell to be merged into the cell;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{object.mirror\_at\_origin(cell)}
    mirror the entire object at the origin
    \begin{APIparameters}
        \parameter{cell}{object}
            Cell to be mirrored;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{object.mirror\_at\_xaxis(cell)}
    mirror the entire object at the x axis
    \begin{APIparameters}
        \parameter{cell}{object}
            Cell to be mirrored;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{object.mirror\_at\_yaxis(cell)}
    mirror the entire object at the y axis
    \begin{APIparameters}
        \parameter{cell}{object}
            Cell to be mirrored;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{object.move\_point(cell, source, target)}
    translate (move) the object so that the source point lies on the target. Usually the source point is an anchor of the object, but that is not a necessity. The points are just references for the delta vector and can be any points.
    \begin{APIparameters}
        \parameter{cell}{object}
            cell which should be moved;
        \parameter{source}{point}
            source point;
        \parameter{target}{point}
            target point;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{object.move\_point\_x(cell, source, target)}
    translate (move) the object so that the x-coorindate of the source point lies on the x-coordinate target. Usually the source point is an anchor of the object, but that is not a necessity. The points are just references for the delta vector and can be any points.
    \begin{APIparameters}
        \parameter{cell}{object}
            cell which should be moved;
        \parameter{source}{point}
            source point;
        \parameter{target}{point}
            target point;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{object.move\_point\_y(cell, source, target)}
    translate (move) the object so that the y-coorindate of the source point lies on the y-coordinate target. Usually the source point is an anchor of the object, but that is not a necessity. The points are just references for the delta vector and can be any points.
    \begin{APIparameters}
        \parameter{cell}{object}
            cell which should be moved;
        \parameter{source}{point}
            source point;
        \parameter{target}{point}
            target point;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{object.add\_child(cell, child, instname)}
    Add a child object (instance) to the given cell. This make 'cell' the parent of the child (it manages its memory). This means that you should not use the original child object any more after this call (unless it is object.add\_child or object.add\_child\_array)
    \begin{APIparameters}
        \parameter{cell}{object}
            Object to which the child is added;
        \parameter{child}{object}
            Child to add;
        \parameter{instname}{string}
            Instance name (not used by all exports);
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{object.move\_to(cell, x, y)}
    move the cell to the specified coordinates (absolute movement). If x is a point, x and y are taken from this point
    \begin{APIparameters}
        \parameter{cell}{object}
            cell to be moved;
        \parameter{x}{integer}
            x coordinate (can be a point, in this case x and y are taken from this point);
        \parameter{y}{integer}
            y coordinate;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{object.rasterize\_curves(cell)}
    rasterize all curves in the object. This is usually not needed, as this happens during the cell export, if required. This function is useful if this should be done regardless of the export capabilities, but then there also is the geometry function geomtry.curve\_rasterized
    \begin{APIparameters}
        \parameter{cell}{object}
            cell to be moved;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{object.reset\_translation(cell)}
    reset all previous translations (transformations are kept)
    \begin{APIparameters}
        \parameter{cell}{object}
            cell to be resetted;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{object.rotate\_90\_left(cell)}
    rotate the entire object 90 degrees counter-clockwise with respect to the origin
    \begin{APIparameters}
        \parameter{cell}{object}
            cell to be rotated;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{object.rotate\_90\_right(cell)}
    rotate the entire object 90 degrees clockwise with respect to the origin
    \begin{APIparameters}
        \parameter{cell}{object}
            cell to be rotated;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{object.set\_alignment\_box(cell, bl, tr)}
    set the alignment box of an object. Overwrites any previous existing alignment boxes
    \begin{APIparameters}
        \parameter{cell}{object}
            cell to add the alignment box to;
        \parameter{bl}{point}
            bottom-left corner of alignment box;
        \parameter{tr}{point}
            top-right corner of alignment box;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{object.set\_boundary\_rectangular(cell, pts)}
    set the cell boundary (rectangular)
    \begin{APIparameters}
        \parameter{cell}{object}
            cell to add the boundary to;
        \parameter{pts}{pointlist}
            polygon boundary;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{object.set\_boundary(cell, pts)}
    set the cell boundary (polygon)
    \begin{APIparameters}
        \parameter{cell}{object}
            cell to add the boundary to;
        \parameter{pts}{pointlist}
            polygon boundary;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{object.set\_empty\_layer\_boundary(cell, layer)}
    Set the layer boundary of this object for the specified layer to empty. A layer boundary is useful for automatic filling, an empty layer boundary indicates that filling can take place everywhere. This function is required if fill is to be placed within the regular boundary of the object, because the regular boundary is used as layer boundary if the latter is not present.
    \begin{APIparameters}
        \parameter{cell}{object}
            object to which the layer boundary should be added;
        \parameter{layer}{generics}
            layer for the layer boundary;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{object.translate(cell, x, y)}
    translate the cell by the specified offsets (relative movement). If x is a point, x and y are taken from this point
    \begin{APIparameters}
        \parameter{cell}{object}
            cell to be translated;
        \parameter{x}{integer}
            x offset (can be a point, in this case x and y are taken from this point);
        \parameter{y}{integer}
            y offset;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{object.translate\_x(cell, x)}
    translate the cell by the specified x offset (relative movement).
    \begin{APIparameters}
        \parameter{cell}{object}
            cell to be translated;
        \parameter{x}{integer}
            x offset;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{object.translate\_y(cell, y)}
    translate the cell by the specified y offset (relative movement).
    \begin{APIparameters}
        \parameter{cell}{object}
            cell to be translated;
        \parameter{y}{integer}
            y offset;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{object.width\_height\_alignmentbox(cell)}
    get the width and the height of the alignment box. A non-existing alignment box triggers an error
    \begin{APIparameters}
        \parameter{cell}{object}
            cell to compute width and height;
    \end{APIparameters}
\end{APIfunc}
\subsection{pcell Module}
\begin{APIfunc}{pcell.set\_property(property, value)}
    set a property of a pcell. Not many properties are supported currently, so this function is very rarely used. The base cell of the standard cell library uses it to be hidden, but that's the only current use
    \begin{APIparameters}
        \parameter{property}{string}
            property to set;
        \parameter{value}{any}
            value of the property;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{pcell.add\_parameter(name, defaultvalue, opt)}
    add a parameter to a pcell definition. Must be called in parameters(). The parameter options table can contain the following fields: 'argtype': (type of the parameter, usually deduced from the default value), 'posvals': possible parameter values, see functions 'even', 'odd', 'interval', 'positive', 'negative' and 'set'; 'follow': copy the values from the followed parameter to this one if not explicitly specified; 'readonly': make parameter readonly
    \begin{APIparameters}
        \parameter{name}{string}
            parameter name;
        \parameter{defaultvalue}{any}
            default parameter value (can be any lua type);
        \parameter{opt}{table}
            options table;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{pcell.add\_parameters(args)}
    add multiple parameters to a cell. Internally, this calls pcell.add\_parameter, so this function is merely a shorthand for multiple calls to pcell.parameter. Hint for the usage: in lua tables, a trailing comma after the last entry is explicitely allowed. However, this is a variable number of arguments for a function call, where the list has to be well-defined. A common error is a trailing comma after the last entry
    \begin{APIparameters}
        \parameter{args}{...}
            argument list of single parameter entries;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{pcell.get\_parameters(cellname)}
    access the (updated) parameter values of another cell
    \begin{APIparameters}
        \parameter{cellname}{string}
            cellname of the cell whose parameters should be queried;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{pcell.push\_overwrites(cellname, parameters)}
    overwrite parameters of other cells. This works across pcell limits and can be called before pcell layouts are created. This also affects cells that are created in sub-cells. This works like a stack (one stack per cell), so it can be applied multiple times
    \begin{APIparameters}
        \parameter{cellname}{string}
            cellname of the to-be-overwritten cell;
        \parameter{parameters}{table}
            table with key-value pairs;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{pcell.pop\_overwrites(cellname)}
    pop one entry of overwrites from the overwrite stack
    \begin{APIparameters}
        \parameter{cellname}{string}
            cellname of the overwrite stack;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{pcell.check\_expression(expression, message)}
    check valid parameter values with expressions. If parameter values depend on some other parameter or the posval function of parameter definitions do not offer enough flexibility, parameters can be checked with arbitrary lua expressions. This function must be called in parameters()
    \begin{APIparameters}
        \parameter{expression}{string}
            expression to check;
        \parameter{message}{string}
            custom message which is displayed if the expression could not be satisfied;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{pcell.create\_layout(cellname, objectname, parameters)}
    Create a layout based on a parametric cell
    \begin{APIparameters}
        \parameter{cellname}{string}
            cellname of the to-be-generated layout cell in the form libname/cellname;
        \parameter{objectname}{string}
            name of the to-be-generated object. This name will be used as identifier in exports that support hierarchies (e.g. GDSII, SKILL);
        \parameter{parameters}{table}
            a table with key-value pairs to be used for the layout pcell. The parameter must exist in the pcell, otherwise this triggers an error;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{pcell.create\_layout\_env(cellname, objectname, parameters, environment)}
    Create a layout based on a parametric cell with a given cell environment
    \begin{APIparameters}
        \parameter{cellname}{string}
            cellname of the to-be-generated layout cell in the form libname/cellname;
        \parameter{objectname}{string}
            name of the to-be-generated object. This name will be used as identifier in exports that support hierarchies (e.g. GDSII, SKILL);
        \parameter{parameters}{table}
            a table with key-value pairs to be used for the layout pcell. The parameter must exist in the pcell, otherwise this triggers an error;
        \parameter{environment}{table}
            a table containing the environment for all cells called from this cell. The content of the environment can contain anything and is defined by the cells. It is useful in order to pass a set of common options to multiple cells;
    \end{APIparameters}
\end{APIfunc}
\subsection{placement Module}
\begin{APIfunc}{placement.create\_floorplan\_aspectratio(instances, utilization, aspectration)}
    create a floorplan configuration based on utilization and an aspectratio. The 'instances' table is the result of parsing and processing verilog netlists. This function is intended to be called in a place-and-route-script for --import-verilog
    \begin{APIparameters}
        \parameter{instances}{table}
            instances table;
        \parameter{utilization}{number}
            utilization factor, must be between 0 and 1;
        \parameter{aspectration}{number}
            aspectratio (width / height) of the floorplan;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{placement.create\_floorplan\_fixed\_rows(instances, utilization, rows)}
    create a floorplan configuration based on utilization and a fixed number of rows. The 'instances' table is the result of parsing and processing verilog netlists. This function is intended to be called in a place-and-route-script for --import-verilog
    \begin{APIparameters}
        \parameter{instances}{table}
            instances table;
        \parameter{utilization}{number}
            utilization factor, must be between 0 and 1;
        \parameter{rows}{integer}
            number of rows;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{placement.optimize(instances, nets, floorplan)}
    minimize wire length by optimizing the placement of the instances by a simulated annealing algorithm. This function returns a table with the rows and columns of the placement of the instances. It is intended to be called in a place-and-route-script for --import-verilog
    \begin{APIparameters}
        \parameter{instances}{table}
            instances table;
        \parameter{nets}{table}
            nets table;
        \parameter{floorplan}{table}
            floorplan configuration;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{placement.manual(instances, plan)}
    create a placement of instances manually. This function expects a row-column table with all instance names. Thus the instance names must match the ones found in the instances table (from the verilog netlist). This function then updates all required references in the row-column table, that are needed for further processing (e.g. routing). This function is useful for small designs, especially in a hierarchical flow
    \begin{APIparameters}
        \parameter{instances}{table}
            instances table;
        \parameter{plan}{table}
            row-column table;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{placement.insert\_filler\_names(rows, width)}
    equalize placement rows by inserting fillers in every row.The method tries to equalize spacing between cells.This function is intended to be called in a place-and-route-script for --import-verilog
    \begin{APIparameters}
        \parameter{rows}{table}
            placement rows table;
        \parameter{width}{integer}
            width as multiple of transistor gates. Must be equal to or larger than every row;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{placement.create\_reference\_rows(cellnames, xpitch)}
    prepare a row placement table for further placement functions by parsing a definition given in 'cellnames'.This table contains the individual rows of the placment, which every row consiting of individual cells.Cell entries can either be given by just the name of the standard cell (the 'reference') or the instance name ('instance') and the reference name ('reference')This function is meant to be used in pcell definitions
    \begin{APIparameters}
        \parameter{cellnames}{table}
            row placement table with cellnames;
        \parameter{xpitch}{integer}
            minimum cell pitch in x direction;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{placement.digital()}
    
    \begin{APIparameters}
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{placement.rowwise(parent, cellsdef, flipfirst, noflip)}
    place cells in a row-wise manner in a parent cell. The cells definition contains definitions for every row, which in turn contain entries with two keys: 'reference' (an object) and 'instance' (an instance name). The placed cells are aligned by their alignment boxes and grow into the upper-right direction. This means that the first entry in the first row is the bottom-left-most cell. This function is useful for digital standard cell layouts (and in fact called by placement.digital, which offers a more high-level interface), but it can also be useful for regular analog structures
    \begin{APIparameters}
        \parameter{parent}{object}
            parent cell to place cells in;
        \parameter{cellsdef}{table}
            cells definition containing rows with entries for 'reference' (an object) and 'instance' (an instance name, must be unique);
        \parameter{flipfirst}{boolean}
            flip the first row;
        \parameter{noflip}{boolean}
            don't flip cells when advancing a row (useful for standard cell blocks that occupy an even number of rows);
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{placement.rowwise\_flat(parent, cellsdef, flipfirst, noflip)}
    like placement.rowwise, but merges cells into parents (flat)
    \begin{APIparameters}
        \parameter{parent}{object}
            parent cell to place cells in;
        \parameter{cellsdef}{table}
            cells definition containing rows with entries for 'reference' (an object) and 'instance' (an instance name, must be unique);
        \parameter{flipfirst}{boolean}
            flip the first row;
        \parameter{noflip}{boolean}
            don't flip cells when advancing a row (useful for standard cell blocks that occupy an even number of rows);
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{placement.place\_at\_origins(toplevel, cell, basename, origins)}
    place cells in a toplevel cells at the specified origins. The instances are named accordingly to the basename (with \_1, \_2, etc. appended). This is a more low-level placement function (compared to placement.place\_within\_boundary), which is called by the higher-level functions. In some cases, using this function directly can be useful. The function returns all placed children in a table.
    \begin{APIparameters}
        \parameter{toplevel}{object}
            toplevel cell to place cells in;
        \parameter{cell}{object}
            cell which will be placed in the toplevel cell;
        \parameter{basename}{string}
            basename for the instance names;
        \parameter{origins}{pointlist}
            origins where cells are placed;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{placement.place\_within\_boundary(toplevel, cell, basename, targetarea, excludes)}
    automatically place a cell multiple times in a toplevel cell. The cell instances will be placed in the given target area and given names based on the given basename. An optional table can hold list of points (polygons), which describe areas that should not be filled. The x- and y-pitch of the cell are inferred from the alignment box. The function returns all plced children in a table.
    \begin{APIparameters}
        \parameter{toplevel}{object}
            toplevel cell to place cells in;
        \parameter{cell}{object}
            cell which will be placed in the toplevel cell;
        \parameter{basename}{string}
            basename for the instance names;
        \parameter{targetarea}{pointlist}
            target area (a polygon);
        \parameter{excludes}{table}
            optional list of polygons with fill excludes;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{placement.place\_within\_boundary\_merge(toplevel, cell, targetarea, excludes)}
    same as placement.place\_with\_boundary, but merges the cells (instead of adding them as children). Since only children need instance names, the 'basename' parameter is not present for this function
    \begin{APIparameters}
        \parameter{toplevel}{object}
            toplevel cell to place cells in;
        \parameter{cell}{object}
            cell which will be placed in the toplevel cell;
        \parameter{targetarea}{pointlist}
            target area (a polygon);
        \parameter{excludes}{table}
            optional list of polygons with fill excludes;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{placement.place\_within\_rectangular\_boundary(toplevel, cell, basename, targetbl, targettr)}
    place fill in a rectangular boundary. This function behaves like placement.place\_with\_boundary, but it takes the corner points (bottom-left and top-right) as inputs. Furthermore, no excludes are accepted. This means that the entire rectangular boundary is filled. This function is magnitudes faster than placement.place\_with\_boundary (as no point-in-polygon checks are required and a more efficient data representation for the resulting array can be used), so consider using this function if no excludes are required.
    \begin{APIparameters}
        \parameter{toplevel}{object}
            toplevel cell to place cells in;
        \parameter{cell}{object}
            cell which will be placed in the toplevel cell;
        \parameter{basename}{string}
            basename for the instance names;
        \parameter{targetbl}{point}
            bottom-left corner point of target area;
        \parameter{targettr}{point}
            top-right corner point of target area;
    \end{APIparameters}
\end{APIfunc}
\subsection{point Module}
\begin{APIfunc}{point.create(x, y)}
    create a point from an x- and y-coordinate
    \begin{APIparameters}
        \parameter{x}{integer}
            x-coordinate of new point;
        \parameter{y}{integer}
            y-coordinate of new point;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{point.combine\_12(pt1, pt2)}
    create a new point by combining the coordinates of two other points. The new point is made up by x1 and y2
    \begin{APIparameters}
        \parameter{pt1}{point}
            point for the x-coordinate of the new point;
        \parameter{pt2}{point}
            point for the y-coordinate of the new point;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{point.combine\_21(pt1, pt2)}
    create a new point by combining the coordinates of two other points. The new point is made up by x2 and y1. This function is equivalent to combine\_12 with swapped arguments
    \begin{APIparameters}
        \parameter{pt1}{point}
            point for the y-coordinate of the new point;
        \parameter{pt2}{point}
            point for the x-coordinate of the new point;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{point.combine(pt1, pt2)}
    combine two points into a new one by taking the arithmetic average of their coordinates, that is x = 0.5 * (x1 + x2), y = 0.5 * (y1 + y2)
    \begin{APIparameters}
        \parameter{pt1}{point}
            first point for the new point;
        \parameter{pt2}{point}
            second point for the new point;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{point.copy(point)}
    copy a point. Can be used as module function or as a point method
    \begin{APIparameters}
        \parameter{point}{point}
            point which should be copied;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{point.getx(point)}
    get the x-coordinate from a point. Can be used as module function or as a point method
    \begin{APIparameters}
        \parameter{point}{point}
            point whose x-coordinate should be queried;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{point.gety(point)}
    get the y-coordinate from a point. Can be used as module function or as a point method
    \begin{APIparameters}
        \parameter{point}{point}
            point whose y-coordinate should be queried;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{point.translate(point, x, y)}
    translate a point in x and y. Can be used as module function or as a point method
    \begin{APIparameters}
        \parameter{point}{point}
            point to translate;
        \parameter{x}{integer}
            x delta by which the point should be translated;
        \parameter{y}{integer}
            y delta by which the point should be translated;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{point.translate\_x(point, x)}
    translate a point in x. Can be used as module function or as a point method
    \begin{APIparameters}
        \parameter{point}{point}
            point to translate;
        \parameter{x}{integer}
            x delta by which the point should be translated;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{point.translate\_y(point, y)}
    translate a point in y. Can be used as module function or as a point method
    \begin{APIparameters}
        \parameter{point}{point}
            point to translate;
        \parameter{y}{integer}
            y delta by which the point should be translated;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{point.xdistance(pt1, pt2)}
    calculate the y-distance between two points, (the ordering of input parameters matters, it is pt1.x - pt2.x)
    \begin{APIparameters}
        \parameter{pt1}{point}
            point 1;
        \parameter{pt2}{point}
            point 2;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{point.xdistance\_abs(pt1, pt2)}
    calculate the x-distance between two points, but return the absolute (regardless of the ordering of input parameters)
    \begin{APIparameters}
        \parameter{pt1}{point}
            point 1;
        \parameter{pt2}{point}
            point 2;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{point.ydistance(pt1, pt2)}
    calculate the y-distance between two points, (the ordering of input parameters matters, it is pt1.y - pt2.y)
    \begin{APIparameters}
        \parameter{pt1}{point}
            point 1;
        \parameter{pt2}{point}
            point 2;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{point.ydistance\_abs(pt1, pt2)}
    calculate the y-distance between two points, but return the absolute (regardless of the ordering of input parameters)
    \begin{APIparameters}
        \parameter{pt1}{point}
            point 1;
        \parameter{pt2}{point}
            point 2;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{point.xaverage(point)}
    calculate the arithmetic average of the x-coordinates of two points
    \begin{APIparameters}
        \parameter{point}{point}
            point which should be unwrapped;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{point.yaverage(point)}
    calculate the arithmetic average of the y-coordinates of two points
    \begin{APIparameters}
        \parameter{point}{point}
            point which should be unwrapped;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{point.fix(pt, grid)}
    fix the x- and y-coordinate from a point on a certain grid, that is 120 would become 100 on a grid of 100. This function behaves like floor(), no rounding is done
    \begin{APIparameters}
        \parameter{pt}{point}
            point to fix to the grid;
        \parameter{grid}{integer}
            grid on which the coordinates should be fixed;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{point.operator+(pt1, pt2)}
    sum two points. This is the same as point.combine
    \begin{APIparameters}
        \parameter{pt1}{point}
            first point for the sum;
        \parameter{pt2}{point}
            second point for the sum;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{point.operator-(pt1, pt2)}
    create a new point representing the difference of two points
    \begin{APIparameters}
        \parameter{pt1}{point}
            first point for the subtraction (the minuend);
        \parameter{pt2}{point}
            second point for the subtraction (the subtrahend);
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{point.operator..(pt1, pt2)}
    combine two points into a new one. Takes the x-coordinate from the first point and the y-coordinate from the second one. Equivalent to point.combine\_12(pt1, pt2)
    \begin{APIparameters}
        \parameter{pt1}{point}
            point for the x-coordinate of the new point;
        \parameter{pt2}{point}
            point for the y-coordinate of the new point;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{point.unwrap(point)}
    unwrap: get the x- and y-coordinate from a point. Can be used as module function or as a point method
    \begin{APIparameters}
        \parameter{point}{point}
            point which should be unwrapped;
    \end{APIparameters}
\end{APIfunc}
\subsection{routing Module}
\begin{APIfunc}{routing.legalize()}
    
    \begin{APIparameters}
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{routing.route()}
    
    \begin{APIparameters}
    \end{APIparameters}
\end{APIfunc}
\subsection{technology Module}
\begin{APIfunc}{technology.get\_dimension(property)}
    Get critical technology dimensions such as minimum metal width. Predominantly used in pcell parameter definitions, but not necessarily restricted to that. There is a small set of technology properties that are used in the standard opc cells, but there is currently no proper definitions of the supported fields. See basic/mosfet and basic/cmos for examples
    \begin{APIparameters}
        \parameter{property}{string}
            technology property name;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{technology.has\_layer(layer)}
    Check if the chosen technology supports a certain layer
    \begin{APIparameters}
        \parameter{layer}{generics}
            generic layer which should be checked;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{technology.has\_multiple\_patterning(metalnumber)}
    Check if the chosen metal layer (represented by the metal index) supports multiple patterning
    \begin{APIparameters}
        \parameter{metalnumber}{integer}
            metal index;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{technology.multiple\_patterning\_number(metalnumber)}
    Get the number of available mask for a metal layer that supports multiple patterning (otherwise the result is 0)
    \begin{APIparameters}
        \parameter{metalnumber}{integer}
            metal index;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{technology.resolve\_metal(index)}
    resolve negative metal indices to their 'real' value (e.g. in a metal stack with five metals -1 becomes 5, -3 becomes 3). This function does not do anything if the index is positive
    \begin{APIparameters}
        \parameter{index}{integer}
            metal index to be resolved;
    \end{APIparameters}
\end{APIfunc}
\subsection{util Module}
\begin{APIfunc}{util.xmirror(pts, xcenter)}
    create a copy of the points in pts (a table) with all x-coordinates mirrored with respect to xcenter
    \begin{APIparameters}
        \parameter{pts}{pointlist}
            list of points;
        \parameter{xcenter}{integer}
            mirror center;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{util.ymirror(pts, ycenter)}
    create a copy of the points in pts (a table) with all y-coordinates mirrored with respect to ycenter
    \begin{APIparameters}
        \parameter{pts}{pointlist}
            list of points;
        \parameter{ycenter}{integer}
            mirror center;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{util.xymirror(pts, xcenter, ycenter)}
    create a copy of the points in pts (a table) with all x- and y-coordinates mirrored with respect to xcenter and ycenter, respectively
    \begin{APIparameters}
        \parameter{pts}{pointlist}
            list of points;
        \parameter{xcenter}{integer}
            mirror center x-coordinate;
        \parameter{ycenter}{integer}
            mirror center y-coordinate;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{util.filter\_forward(pts, fun)}
    iterate forward through the list of points and create a new list with copied points that match the predicate. The predicate function is called with every point.
    \begin{APIparameters}
        \parameter{pts}{pointlist}
            point array to append to;
        \parameter{fun}{function}
            filter function;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{util.filter\_backward(pts, fun)}
    iterate backward through the list of points and create a new list with copied points that match the predicate. The predicate function is called with every point.
    \begin{APIparameters}
        \parameter{pts}{pointlist}
            point array to append to;
        \parameter{fun}{function}
            filter function;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{util.merge\_forwards(pts, pts2)}
    append all points from pts2 to pts1. Iterate pts2 forward. Operates in-place, thus pts is modified
    \begin{APIparameters}
        \parameter{pts}{pointlist}
            point array to append to;
        \parameter{pts2}{pointlist}
            point array to append from;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{util.merge\_backwards(pts, pts2)}
    append all points from pts2 to pts1. Iterate pts2 backwards. Operates in-place, thus pts is modified
    \begin{APIparameters}
        \parameter{pts}{pointlist}
            point array to append to;
        \parameter{pts2}{pointlist}
            point array to append from;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{util.reverse(pts)}
    create a copy of the point array with the order of points reversed
    \begin{APIparameters}
        \parameter{pts}{pointlist}
            point array;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{util.make\_insert\_xy(pts, index)}
    create a function that inserts points into a point array. XY mode, thus points are given as two coordinates. If an index is given, insert at that position. Mostly useful with 1 as an index or not index at all (append)
    \begin{APIparameters}
        \parameter{pts}{pointlist}
            point array;
        \parameter{index}{integer}
            optional index;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{util.make\_insert\_pts(pts, index)}
    create a function that inserts points into a point array. Point mode, thus points are given as single points. If an index is given, insert at that position. Mostly useful with 1 as an index or not index at all (append)
    \begin{APIparameters}
        \parameter{pts}{pointlist}
            point array;
        \parameter{index}{integer}
            optional index;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{util.range(lower, upper, incr)}
    create a table with numeric entries between lower and upper (both inclusive). The entries spacing is specified by the increment (default 1)
    \begin{APIparameters}
        \parameter{lower}{integer}
            lower (inclusive) bound;
        \parameter{upper}{integer}
            upper (inclusive) bound;
        \parameter{incr}{integer}
            increment;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{util.remove(t, comp)}
    create a shallow copy of a table with certain elements matching the given criteria removed. The 'comp' parameter can either be a value, which will be compared directly to the entries or a comparison function. If the result of the function call is 'true', the entry is NOT included in the results table.
    \begin{APIparameters}
        \parameter{t}{table}
            array;
        \parameter{comp}{any}
            comparison value of function;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{util.remove\_index(t, index)}
    create a shallow copy of a table with the element at the 'index' removed
    \begin{APIparameters}
        \parameter{t}{table}
            array;
        \parameter{index}{integer}
            index of to-be-removed element;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{util.remove\_inplace(t, comp)}
    remove certain elements matching the given criteria. The 'comp' parameter can either be a value, which will be compared directly to the entries or a comparison function. If the result of the function call is 'true', the entry is NOT included in the results table.
    \begin{APIparameters}
        \parameter{t}{table}
            array;
        \parameter{comp}{any}
            comparison value of function;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{util.remove\_index\_inplace(t, index)}
    remove the element of the given table at the given index (actually just a wrapper for table.remove)
    \begin{APIparameters}
        \parameter{t}{table}
            array;
        \parameter{index}{integer}
            index of to-be-removed element;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{util.fill\_all\_with(num, filler)}
    create an array-like table with one entry repeated N times. This is useful, for example, for specifying gate contacts for basic/cmos
    \begin{APIparameters}
        \parameter{num}{integer}
            number of repetitions;
        \parameter{filler}{any}
            value which should be repeated. Can be anything, but probably most useful with strings or numbers;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{util.fill\_predicate\_with(num, filler, predicate, other)}
    create an array-like table with two entries (total number of entries is N). This function (compared to fill\_all\_with, fill\_odd\_with and fill\_even\_with) allows for more complex patterns. To do this, a predicate (a function) is called on every index. If the predicate is true, the first entry is inserted, otherwise the second one. This function is useful, for example, for specifying gate contacts for basic/cmos. Counting starts at 1, so the first entry will be 'other'
    \begin{APIparameters}
        \parameter{num}{integer}
            number of repetitions;
        \parameter{filler}{any}
            value which should be repeated at even numbers. Can be anything, but probably most useful with strings or numbers;
        \parameter{predicate}{function}
            predicate which is called with every index;
        \parameter{other}{any}
            value which should be repeated at odd numbers. Can be anything, but probably most useful with strings or numbers;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{util.fill\_even\_with(num, filler, other)}
    create an array-like table with two entries repeated N / 2 times, alternating. Counting starts at 1. This is useful, for example, for specifying gate contacts for basic/cmos. Counting starts at 1, so the first entry will be 'other'
    \begin{APIparameters}
        \parameter{num}{integer}
            number of repetitions;
        \parameter{filler}{any}
            value which should be repeated at even numbers. Can be anything, but probably most useful with strings or numbers;
        \parameter{other}{any}
            value which should be repeated at odd numbers. Can be anything, but probably most useful with strings or numbers;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{util.fill\_odd\_with(num, filler, other)}
    create an array-like table with two entries repeated N / 2 times, alternating. Counting starts at 1. This is useful, for example, for specifying gate contacts for basic/cmos. Counting starts at 1, so the first entry will be 'filler'
    \begin{APIparameters}
        \parameter{num}{integer}
            number of repetitions;
        \parameter{filler}{any}
            value which should be repeated at odd numbers. Can be anything, but probably most useful with strings or numbers;
        \parameter{other}{any}
            value which should be repeated at even numbers. Can be anything, but probably most useful with strings or numbers;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{util.clone\_shallow(table)}
    create a shallow copy of a table. This function creates a copy of the given table, where all first-level values are copied. If those values are tables, they reference the same table as the original object.
    \begin{APIparameters}
        \parameter{table}{table}
            table;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{util.add\_options(baseoptions, additionaloptions)}
    create a copy of the baseoptions table and add all key-value pairs found in additionaloptions. This function clones baseoptions so the original is not altered. This copy is flat, so only the first-level elements are copied (e.g. tables will reference the same object). This function is useful to modify a set of base options for several devices such as mosfets, which only differ in a few options
    \begin{APIparameters}
        \parameter{baseoptions}{table}
            base options;
        \parameter{additionaloptions}{table}
            additional options;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{util.ratio\_split\_even(value, ratio)}
    create two values that sum up to the input value and have the specified ratio. The values are adjusted so that both of them are even, possibly changing the ratio slightly. The input value must be even
    \begin{APIparameters}
        \parameter{value}{integer}
            value for division;
        \parameter{ratio}{number}
            target ratio of the two result values;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{util.rectangle\_to\_polygon(bl, tr, leftext, rightext, bottomext, topext)}
    convert a two-point rectangle to a polygon describing this rectangle. Optionally, the polygon can be extended in the four directions (left/right/bottom/top). This function is useful for creating fill layer boundaries or fill target regions
    \begin{APIparameters}
        \parameter{bl}{point}
            lower-left corner of the rectangle;
        \parameter{tr}{point}
            upper-right corner of the rectangle;
        \parameter{leftext}{integer}
            left extension;
        \parameter{rightext}{integer}
            right extension;
        \parameter{bottomext}{integer}
            bottom extension;
        \parameter{topext}{integer}
            top extension;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{util.any\_of(comp, table, ...)}
    return true if any of the values in the array part of the table compare true (either directly to the given value or the function call is true). If a comparison function is given it is called with every element of the array and (if present) any additional parameters to util.any\_of are passed to the function, following the array element
    \begin{APIparameters}
        \parameter{comp}{any}
            either a value for direct comparison or a comparison function;
        \parameter{table}{table}
            array-like table;
        \parameter{...}{...}
            additional arguments passed to comparison function;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{util.any\_of(comp, table, ...)}
    return true if all of the values in the array part of the table compare true (either directly to the given value or the function call is true). If a comparison function is given it is called with every element of the array and (if present) any additional parameters to util.all\_of are passed to the function, following the array element
    \begin{APIparameters}
        \parameter{comp}{any}
            either a value for direct comparison or a comparison function;
        \parameter{table}{table}
            array-like table;
        \parameter{...}{...}
            additional arguments passed to comparison function;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{util.transform\_points(pts, func)}
    transform all points in a list of points. This function creates a copy of the point list (the points are copied too). Every point is transformed by the transformation function. Any return values of the function are ignored, the function should transform the given point in-place.
    \begin{APIparameters}
        \parameter{pts}{pointlist}
            the point list;
        \parameter{func}{function}
            the transformation function;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{util.fix\_to\_grid\_higher(coordinate, grid)}
    fix a coordinate to a multiple of the given grid. This function works like a 'ceil(ing)' function, so the resulting number is either higher or equal. This means that this function does not behave symmetrically for negative and positive input. If this is required, use util.fix\_to\_grid\_abs\_higher.
    \begin{APIparameters}
        \parameter{coordinate}{integer}
            coordinate;
        \parameter{grid}{integer}
            grid;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{util.fix\_to\_grid\_lower(coordinate, grid)}
    fix a coordinate to a multiple of the given grid. This function works like a 'floor(ing)' function, so the resulting number is either lower or equal. This means that this function does not behave symmetrically for negative and positive input. If this is required, use util.fix\_to\_grid\_abs\_lower.
    \begin{APIparameters}
        \parameter{coordinate}{integer}
            coordinate;
        \parameter{grid}{integer}
            grid;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{util.fix\_to\_grid\_abs\_higher(coordinate, grid)}
    fix a coordinate to a multiple of the given grid. This function works like a 'ceil(ing)' function, but it is computed on the absolute value, so the absolute of the resulting number is either higher or equal. This means that this function does behave symmetrically for negative and positive input. If this is unwanted, use util.fix\_to\_grid\_higher.
    \begin{APIparameters}
        \parameter{coordinate}{integer}
            coordinate;
        \parameter{grid}{integer}
            grid;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{util.fix\_to\_grid\_abs\_lower(coordinate, grid)}
    fix a coordinate to a multiple of the given grid. This function works like a 'floor(ing)' function, but it is computed on the absolute value, so the absolute of the resulting number is either lower or equal. This means that this function does behave symmetrically for negative and positive input. If this is unwanted, use util.fix\_to\_grid\_lower.
    \begin{APIparameters}
        \parameter{coordinate}{integer}
            coordinate;
        \parameter{grid}{integer}
            grid;
    \end{APIparameters}
\end{APIfunc}
\begin{APIfunc}{util.fix\_to\_grid\_abs\_lower(coordinate, grid)}
    fix a coordinate to a multiple of the given grid. This function works like a 'floor(ing)' function, but it is computed on the absolute value, so the absolute of the resulting number is either lower or equal. This means that this function does behave symmetrically for negative and positive input. If this is unwanted, use util.fix\_to\_grid\_lower.
    \begin{APIparameters}
        \parameter{coordinate}{integer}
            coordinate;
        \parameter{grid}{integer}
            grid;
    \end{APIparameters}
\end{APIfunc}

\end{document}
% vim: ft=tex
